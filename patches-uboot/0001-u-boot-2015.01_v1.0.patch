diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 5eb1d03..0b7f213 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -682,6 +682,10 @@ config RMOBILE
 	bool "Renesas ARM SoCs"
 	select CPU_V7
 
+config RZA1
+	bool "Renesas RZ/A1H ARM SoCs"
+	select CPU_V7
+
 config TARGET_CM_FX6
 	bool "Support cm_fx6"
 	select CPU_V7
@@ -827,6 +831,8 @@ source "arch/arm/cpu/arm926ejs/orion5x/Kconfig"
 
 source "arch/arm/cpu/armv7/rmobile/Kconfig"
 
+source "arch/arm/cpu/armv7/rza1/Kconfig"
+
 source "arch/arm/cpu/armv7/s5pc1xx/Kconfig"
 
 source "arch/arm/cpu/armv7/tegra-common/Kconfig"
diff --git a/arch/arm/cpu/armv7/Makefile b/arch/arm/cpu/armv7/Makefile
index 409e6f5..ab56e0a 100644
--- a/arch/arm/cpu/armv7/Makefile
+++ b/arch/arm/cpu/armv7/Makefile
@@ -53,6 +53,7 @@ obj-$(CONFIG_MX6) += mx6/
 obj-$(CONFIG_OMAP34XX) += omap3/
 obj-$(CONFIG_OMAP44XX) += omap4/
 obj-$(CONFIG_OMAP54XX) += omap5/
+obj-$(CONFIG_RZA1) += rza1/
 obj-$(CONFIG_RMOBILE) += rmobile/
 obj-$(CONFIG_ARCH_S5PC1XX) += s5pc1xx/
 obj-$(CONFIG_SOCFPGA) += socfpga/
diff --git a/arch/arm/cpu/armv7/rza1/Kconfig b/arch/arm/cpu/armv7/rza1/Kconfig
new file mode 100644
index 0000000..71cfb22
--- /dev/null
+++ b/arch/arm/cpu/armv7/rza1/Kconfig
@@ -0,0 +1,16 @@
+if RZA1
+
+choice
+	prompt "Renesas RZ/A1H ARM SoCs board select"
+
+config TARGET_RSKRZA1
+	bool "RSK-RZA/1 board"
+
+endchoice
+
+config SYS_SOC
+	default "rza1"
+
+source "board/renesas/rskrza1/Kconfig"
+
+endif
diff --git a/arch/arm/cpu/armv7/rza1/Makefile b/arch/arm/cpu/armv7/rza1/Makefile
new file mode 100644
index 0000000..ee3af05
--- /dev/null
+++ b/arch/arm/cpu/armv7/rza1/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2013 Renesas Solutions Corp.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += timer.o
+obj-y += cpu_info.o
+obj-y += emac.o
diff --git a/arch/arm/cpu/armv7/rza1/config.mk b/arch/arm/cpu/armv7/rza1/config.mk
new file mode 100644
index 0000000..07be1aa
--- /dev/null
+++ b/arch/arm/cpu/armv7/rza1/config.mk
@@ -0,0 +1 @@
+PLATFORM_CPPFLAGS += -mno-unaligned-access
diff --git a/arch/arm/cpu/armv7/rza1/cpu_info.c b/arch/arm/cpu/armv7/rza1/cpu_info.c
new file mode 100644
index 0000000..618b5e1
--- /dev/null
+++ b/arch/arm/cpu/armv7/rza1/cpu_info.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2012-2013 Renesas Solutions Corp.
+ * Copyright (C) 2012 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#ifdef CONFIG_ARCH_CPU_INIT
+int arch_cpu_init(void)
+{
+	icache_enable();
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+void enable_caches(void)
+{
+	dcache_enable();
+}
+#endif
diff --git a/arch/arm/cpu/armv7/rza1/emac.c b/arch/arm/cpu/armv7/rza1/emac.c
new file mode 100644
index 0000000..acd55b4
--- /dev/null
+++ b/arch/arm/cpu/armv7/rza1/emac.c
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/errno.h>
+#include <netdev.h>
+
+int cpu_eth_init(bd_t *bis)
+{
+	int ret = -ENODEV;
+#ifdef CONFIG_SH_ETHER
+	ret = sh_eth_initialize(bis);
+#endif
+	return ret;
+}
diff --git a/arch/arm/cpu/armv7/rza1/timer.c b/arch/arm/cpu/armv7/rza1/timer.c
new file mode 100644
index 0000000..fb00c65
--- /dev/null
+++ b/arch/arm/cpu/armv7/rza1/timer.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2008-2013 Renesas Solutions Corp.
+ * Copyright (C) 2007,2008 Nobobuhiro Iwamatsu <iwamatsu@nigauri.org>
+ *
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/rza1-regs.h>
+#include <asm/processor.h>
+
+#define OSTM0CTL_D	0x02	/* free run mode, disable interrupt */
+#define OST_MAX_COUNTER (0xFFFFFFFF)
+#define OST_TIMER_RESET (0xFFFFFFFF)
+
+static vu_long ost0_timer;
+
+static void ost_timer_start(unsigned int timer)
+{
+	writeb(readb(OSTM0TS) | 0x01, OSTM0TS);
+}
+
+static void ost_timer_stop(unsigned int timer)
+{
+	writeb(readb(OSTM0TT) | 0x01, OSTM0TT);
+}
+
+int timer_init(void)
+{
+	ost0_timer = 0;
+
+	readb(OSTM0CTL);
+	writeb(OSTM0CTL_D, OSTM0CTL);
+
+	/* User Device 0 only */
+	ost_timer_stop(0);
+	writel(OST_TIMER_RESET, OSTM0CMP);
+	ost_timer_start(0);
+
+	return 0;
+}
+
+unsigned long long get_ticks(void)
+{
+	return ost0_timer;
+}
+
+static vu_long cmcnt = 0;
+static unsigned long get_usec (void)
+{
+	ulong data = readl(OSTM0CNT);
+	ulong diff;
+
+	if (data >= cmcnt)
+		diff = data - cmcnt;
+	else
+		diff = (OST_TIMER_RESET - cmcnt) + data;
+
+	ost0_timer += diff;
+
+	cmcnt = data;
+
+	/* Timer source clock (P0) is 33.33 Mhz */
+	return (unsigned long)(ost0_timer / 33);
+}
+
+/* return msec */
+ulong get_timer(ulong base)
+{
+	const ulong timecnt = OST_TIMER_RESET / (33 * 1000); /*130150*/
+	ulong now = (get_usec() / 1000);
+	
+	if (now >= base)
+		return now - base;
+	else
+		return ((timecnt + 1) - base) + now;
+}
+
+void __udelay(unsigned long usec)
+{
+	unsigned long end = get_usec() + usec;
+
+	while (get_usec() < end)
+		continue;
+}
+
+unsigned long get_tbclk(void)
+{
+	return CONFIG_SYS_HZ;
+}
diff --git a/arch/arm/include/asm/arch-rza1/rza1-regs.h b/arch/arm/include/asm/arch-rza1/rza1-regs.h
new file mode 100644
index 0000000..dc493df
--- /dev/null
+++ b/arch/arm/include/asm/arch-rza1/rza1-regs.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright (C) 2013-2014 Renesas Solutions Corp.
+*/
+
+#ifndef _RZA1_REGS_H
+#define _RZA1_REGS_H
+
+/*
+ *  Register bases.
+ */
+#define RZA1_WDT_BASE            (0xFCFE0000)
+#define RZA1_FRQCR_BASE          (0xFCFE0010)
+#define RZA1_STBCR_BASE          (0xFCFE0020)
+#define RZA1_PCTR_BASE           (0xFCFE3000)
+#define RZA1_OST_BASE            (0xFCFEC000)
+#define RZA1_BCR_BASE            (0x3FFFC000)
+#define RZA1_SDRAM_BASE          (0x3FFFC000)
+
+/* Clock Registers */
+#define FRQCR (RZA1_FRQCR_BASE + 0x00)
+#define FRQCR2 (RZA1_FRQCR_BASE + 0x04)
+
+/* Watchdog Registers */
+#define WTCSR (RZA1_WDT_BASE + 0x00) /* Watchdog Timer Control Register */
+#define WTCNT (RZA1_WDT_BASE + 0x02) /* Watchdog Timer Counter Register */
+#define WRCSR (RZA1_WDT_BASE + 0x04) /* Watchdog Reset Control Register */
+
+/* OSTimer Registers */
+#define OSTM0CMP (RZA1_OST_BASE + 0x000)
+#define OSTM0CNT (RZA1_OST_BASE + 0x004)
+#define OSTM0TE  (RZA1_OST_BASE + 0x010)
+#define OSTM0TS  (RZA1_OST_BASE + 0x014)
+#define OSTM0TT  (RZA1_OST_BASE + 0x018)
+#define OSTM0CTL (RZA1_OST_BASE + 0x020)
+#define OSTM1CMP (RZA1_OST_BASE + 0x400)
+#define OSTM1CNT (RZA1_OST_BASE + 0x404)
+#define OSTM1TE  (RZA1_OST_BASE + 0x410)
+#define OSTM1TS  (RZA1_OST_BASE + 0x414)
+#define OSTM1TT  (RZA1_OST_BASE + 0x418)
+#define OSTM1CTL (RZA1_OST_BASE + 0x420)
+
+/* Standby controller registers (chapter 55) */
+#define STBCR1 (RZA1_STBCR_BASE + 0x00)
+#define STBCR2 (RZA1_STBCR_BASE + 0x04)
+#define STBCR3 (RZA1_STBCR_BASE + 0x400)
+#define STBCR4 (RZA1_STBCR_BASE + 0x404)
+#define STBCR5 (RZA1_STBCR_BASE + 0x408)
+#define STBCR6 (RZA1_STBCR_BASE + 0x40c)
+#define STBCR7 (RZA1_STBCR_BASE + 0x410)
+#define STBCR8 (RZA1_STBCR_BASE + 0x414)
+#define STBCR9 (RZA1_STBCR_BASE + 0x418)
+#define STBCR10 (RZA1_STBCR_BASE + 0x41c)
+#define STBCR11 (RZA1_STBCR_BASE + 0x420)
+#define STBCR12 (RZA1_STBCR_BASE + 0x424)
+#define STBCR13 (RZA1_STBCR_BASE + 0x450)
+
+/* Port0 Control register */
+#define JPPR0   (RZA1_PCTR_BASE + 0x000)
+#define JPMC0   (RZA1_PCTR_BASE + 0x040)
+#define JPMCSR0 (RZA1_PCTR_BASE + 0x090)
+#define JPIBC0  (RZA1_PCTR_BASE + 0x400)
+#define PPR0    (RZA1_PCTR_BASE + 0x200)
+#define PMC0    (RZA1_PCTR_BASE + 0x400)
+#define PMCSR0  (RZA1_PCTR_BASE + 0x900)
+#define PIBC0   (RZA1_PCTR_BASE + 0x4000)
+/* Port1 Control register */
+#define P1      (RZA1_PCTR_BASE + 0x0004)
+#define PM1     (RZA1_PCTR_BASE + 0x0304)
+#define PMC1    (RZA1_PCTR_BASE + 0x0404)
+#define PFC1    (RZA1_PCTR_BASE + 0x0504)
+#define PFCE1   (RZA1_PCTR_BASE + 0x0604)
+#define PFCAE1  (RZA1_PCTR_BASE + 0x0a04)
+#define PIBC1   (RZA1_PCTR_BASE + 0x4004)
+#define PBDC1   (RZA1_PCTR_BASE + 0x4104)
+#define PIPC1   (RZA1_PCTR_BASE + 0x4204)
+/* Port2 Control register */
+#define P2      (RZA1_PCTR_BASE + 0x0008)
+#define PM2     (RZA1_PCTR_BASE + 0x0308)
+#define PMC2    (RZA1_PCTR_BASE + 0x0408)
+#define PFC2    (RZA1_PCTR_BASE + 0x0508)
+#define PFCE2   (RZA1_PCTR_BASE + 0x0608)
+#define PFCAE2  (RZA1_PCTR_BASE + 0x0a08)
+#define PIBC2   (RZA1_PCTR_BASE + 0x4008)
+#define PBDC2   (RZA1_PCTR_BASE + 0x4108)
+#define PIPC2   (RZA1_PCTR_BASE + 0x4208)
+/* Port3 Control register */
+#define P3      (RZA1_PCTR_BASE + 0x000c)
+#define PM3     (RZA1_PCTR_BASE + 0x030c)
+#define PMC3    (RZA1_PCTR_BASE + 0x040c)
+#define PFC3    (RZA1_PCTR_BASE + 0x050c)
+#define PFCE3   (RZA1_PCTR_BASE + 0x060c)
+#define PFCAE3  (RZA1_PCTR_BASE + 0x0a0c)
+#define PIBC3   (RZA1_PCTR_BASE + 0x400c)
+#define PBDC3   (RZA1_PCTR_BASE + 0x410c)
+#define PIPC3   (RZA1_PCTR_BASE + 0x420c)
+/* Port4 Control register */
+#define P4      (RZA1_PCTR_BASE + 0x0010)
+#define PM4     (RZA1_PCTR_BASE + 0x0310)
+#define PMC4    (RZA1_PCTR_BASE + 0x0410)
+#define PFC4    (RZA1_PCTR_BASE + 0x0510)
+#define PFCE4   (RZA1_PCTR_BASE + 0x0610)
+#define PFCAE4  (RZA1_PCTR_BASE + 0x0a10)
+#define PIBC4   (RZA1_PCTR_BASE + 0x4010)
+#define PBDC4   (RZA1_PCTR_BASE + 0x4110)
+#define PIPC4   (RZA1_PCTR_BASE + 0x4210)
+/* Port5 Control register */
+#define P5      (RZA1_PCTR_BASE + 0x0014)
+#define PM5     (RZA1_PCTR_BASE + 0x0314)
+#define PMC5    (RZA1_PCTR_BASE + 0x0414)
+#define PFC5    (RZA1_PCTR_BASE + 0x0514)
+#define PFCE5   (RZA1_PCTR_BASE + 0x0614)
+#define PFCAE5  (RZA1_PCTR_BASE + 0x0a14)
+#define PIBC5   (RZA1_PCTR_BASE + 0x4014)
+#define PBDC5   (RZA1_PCTR_BASE + 0x4114)
+#define PIPC5   (RZA1_PCTR_BASE + 0x4214)
+/* Port6 Control register */
+#define P6      (RZA1_PCTR_BASE + 0x0018)
+#define PM6     (RZA1_PCTR_BASE + 0x0318)
+#define PMC6    (RZA1_PCTR_BASE + 0x0418)
+#define PFC6    (RZA1_PCTR_BASE + 0x0518)
+#define PFCE6   (RZA1_PCTR_BASE + 0x0618)
+#define PFCAE6  (RZA1_PCTR_BASE + 0x0a18)
+#define PIBC6   (RZA1_PCTR_BASE + 0x4018)
+#define PBDC6   (RZA1_PCTR_BASE + 0x4118)
+#define PIPC6   (RZA1_PCTR_BASE + 0x4218)
+/* Port7 Control register */
+#define P7      (RZA1_PCTR_BASE + 0x001c)
+#define PM7     (RZA1_PCTR_BASE + 0x031c)
+#define PMC7    (RZA1_PCTR_BASE + 0x041c)
+#define PFC7    (RZA1_PCTR_BASE + 0x051c)
+#define PFCE7   (RZA1_PCTR_BASE + 0x061c)
+#define PFCAE7  (RZA1_PCTR_BASE + 0x0a1c)
+#define PIBC7   (RZA1_PCTR_BASE + 0x401c)
+#define PBDC7   (RZA1_PCTR_BASE + 0x411c)
+#define PIPC7 (RZA1_PCTR_BASE + 0x421c)
+/* Port8 Control register */
+#define P8      (RZA1_PCTR_BASE + 0x0020)
+#define PM8     (RZA1_PCTR_BASE + 0x0320)
+#define PMC8    (RZA1_PCTR_BASE + 0x0420)
+#define PFC8    (RZA1_PCTR_BASE + 0x0520)
+#define PFCE8   (RZA1_PCTR_BASE + 0x0620)
+#define PFCAE8  (RZA1_PCTR_BASE + 0x0a20)
+#define PIBC8   (RZA1_PCTR_BASE + 0x4020)
+#define PBDC8   (RZA1_PCTR_BASE + 0x4120)
+#define PIPC8   (RZA1_PCTR_BASE + 0x4220)
+/* Port9 Control register */
+#define P9      (RZA1_PCTR_BASE + 0x0024)
+#define PM9     (RZA1_PCTR_BASE + 0x0324)
+#define PMC9    (RZA1_PCTR_BASE + 0x0424)
+#define PFC9    (RZA1_PCTR_BASE + 0x0524)
+#define PFCE9   (RZA1_PCTR_BASE + 0x0624)
+#define PFCAE9  (RZA1_PCTR_BASE + 0x0a24)
+#define PIBC9   (RZA1_PCTR_BASE + 0x4024)
+#define PBDC9   (RZA1_PCTR_BASE + 0x4124)
+#define PIPC9   (RZA1_PCTR_BASE + 0x4224)
+/* Port10 Control register */
+#define P10      (RZA1_PCTR_BASE + 0x0028)
+#define PM10     (RZA1_PCTR_BASE + 0x0328)
+#define PMC10    (RZA1_PCTR_BASE + 0x0428)
+#define PFC10    (RZA1_PCTR_BASE + 0x0528)
+#define PFCE10   (RZA1_PCTR_BASE + 0x0628)
+#define PFCAE10  (RZA1_PCTR_BASE + 0x0a28)
+#define PIBC10   (RZA1_PCTR_BASE + 0x4028)
+#define PBDC10   (RZA1_PCTR_BASE + 0x4128)
+#define PIPC10   (RZA1_PCTR_BASE + 0x4228)
+/* Port11 Control register */
+#define P11      (RZA1_PCTR_BASE + 0x002c)
+#define PM11     (RZA1_PCTR_BASE + 0x032c)
+#define PMC11    (RZA1_PCTR_BASE + 0x042c)
+#define PFC11    (RZA1_PCTR_BASE + 0x052c)
+#define PFCE11   (RZA1_PCTR_BASE + 0x062c)
+#define PFCAE11  (RZA1_PCTR_BASE + 0x0a2c)
+#define PIBC11   (RZA1_PCTR_BASE + 0x402c)
+#define PBDC11   (RZA1_PCTR_BASE + 0x412c)
+#define PIPC11   (RZA1_PCTR_BASE + 0x422c)
+
+/* Bus State Contoller registers */
+#define CMNCR  (RZA1_BCR_BASE + 0x00)
+#define CS0BCR (RZA1_BCR_BASE + 0x04)
+#define CS0WCR (RZA1_BCR_BASE + 0x28)
+#define CS1BCR (RZA1_BCR_BASE + 0x08)
+#define CS1WCR (RZA1_BCR_BASE + 0x2c)
+#define CS2BCR (RZA1_BCR_BASE + 0x0c)
+#define CS2WCR (RZA1_BCR_BASE + 0x30)
+#define CS3BCR (RZA1_BCR_BASE + 0x10)
+#define CS3WCR (RZA1_BCR_BASE + 0x34)
+
+/* SDRAM controller registers */
+#define SDCR   (RZA1_SDRAM_BASE + 0x4c)
+#define RTCOR  (RZA1_SDRAM_BASE + 0x58)
+#define RTCSR  (RZA1_SDRAM_BASE + 0x50)
+
+/* Power-Down Registers (Chapter 55) */
+#define SWRSTCR1 0xFCFE0460	/* Software reset control register 1 */
+#define SWRSTCR2 0xFCFE0464	/* Software reset control register 2 */
+#define SWRSTCR3 0xFCFE0468	/* Software reset control register 3 */
+#define SYSCR1 0xFCFE0400	/* System control register 1 */
+#define SYSCR2 0xFCFE0404	/* System control register 2 */
+#define SYSCR3 0xFCFE0408	/* System control register 3 */
+#define CPUSTS 0xFCFE0018	/* CPU status register */
+#define STBREQ1 0xFCFE0030	/* Standby request register 1 */
+#define STBREQ2 0xFCFE0034	/* Standby request register 2 */
+#define STBACK1 0xFCFE0040	/* Standby acknowledge register 1 */
+#define STBACK2 0xFCFE0044	/* Standby acknowledge register 2 */
+#define RRAMKP 0xFCFF1800	/* On-chip data-retention RAM area setting register */
+#define DSCTR 0xFCFF1802	/* Deep standby control register */
+#define DSSSR 0xFCFF1804	/* Deep standby cancel source select register */
+#define DSESR 0xFCFF1806	/* Deep standby cancel edge select register */
+#define DSFR 0xFCFF1808	/* Deep standby cancel source flag register */
+#define XTALCTR 0xFCFF1810	/* XTAL crystal oscillator gain control register */
+
+
+
+#endif				/* _RZA1_REGS_H */
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
index d4a447b..fecae18 100644
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -1108,6 +1108,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_KZM9G                4140
 #define MACH_TYPE_COLIBRI_T30          4493
 #define MACH_TYPE_APALIS_T30           4513
+#define MACH_TYPE_RSKRZA1              4533
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -14261,6 +14262,18 @@ extern unsigned int __machine_arch_type;
 # define machine_is_apalis_t30()	(0)
 #endif
 
+#ifdef CONFIG_MACH_RSKRZA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSKRZA1
+# endif
+# define machine_is_rskrza1()	(machine_arch_type == MACH_TYPE_RSKRZA1)
+#else
+# define machine_is_rskrza1()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff --git a/arch/arm/include/asm/macro.h b/arch/arm/include/asm/macro.h
index 1c8c425..d69fa8d 100644
--- a/arch/arm/include/asm/macro.h
+++ b/arch/arm/include/asm/macro.h
@@ -28,7 +28,8 @@
 
 .macro	write16, addr, data
 	ldr	r4, =\addr
-	ldrh	r5, =\data
+	ldr	r5, =\data /* avoid this error. "invalid literal constant:
+			      pool needs to be closer" */
 	strh	r5, [r4]
 .endm
 
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
index f606255..2c47812 100644
--- a/arch/arm/lib/board.c
+++ b/arch/arm/lib/board.c
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
  * (C) Copyright 2002-2006
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
diff --git a/board/renesas/rskrza1/Kconfig b/board/renesas/rskrza1/Kconfig
new file mode 100644
index 0000000..396a229
--- /dev/null
+++ b/board/renesas/rskrza1/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_RSKRZA1
+
+config SYS_BOARD
+	default "rskrza1"
+
+config SYS_VENDOR
+	default "renesas"
+
+config SYS_CONFIG_NAME
+	default "rskrza1"
+
+endif
diff --git a/board/renesas/rskrza1/MAINTAINERS b/board/renesas/rskrza1/MAINTAINERS
new file mode 100644
index 0000000..f111ee0
--- /dev/null
+++ b/board/renesas/rskrza1/MAINTAINERS
@@ -0,0 +1,6 @@
+RSKRZA1 BOARD
+#M:	-
+S:	Maintained
+F:	board/renesas/rskrza1/
+F:	include/configs/rskrza1.h
+F:	configs/rskrza1_defconfig
diff --git a/board/renesas/rskrza1/Makefile b/board/renesas/rskrza1/Makefile
new file mode 100644
index 0000000..0ecc397
--- /dev/null
+++ b/board/renesas/rskrza1/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2015 Renesas Electronics
+# Copyright (C) 2015 Chris Brandt
+# Copyright (C) 2015 Justin Waters
+#
+# SPDX-License-Identifier:	GPL-2.0+
+
+obj-y	:= rskrza1.o
+obj-y	+= lowlevel_init.o
diff --git a/board/renesas/rskrza1/lowlevel_init.S b/board/renesas/rskrza1/lowlevel_init.S
new file mode 100644
index 0000000..204866f
--- /dev/null
+++ b/board/renesas/rskrza1/lowlevel_init.S
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2008-2014 Renesas Solutions Corp.
+ * Copyright (C) 2012 Renesas Electronics Europe Ltd.
+ * Copyright (C) 2012 Phil Edworthy
+ * Copyright (C) 2008 Nobuhiro Iwamatsu
+ *
+ * Based on board/renesas/rsk7264/lowlevel_init.S
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+#include <config.h>
+#include <version.h>
+#include <asm/arch/rza1-regs.h>
+#include <asm/macro.h>
+
+	.global	lowlevel_init
+
+	.text
+	.align	2
+
+lowlevel_init:
+	/* PL310 init */
+	write32 0x3fffff80, 0x00000001
+
+	/* Disable WDT */
+	write16	WTCSR, WTCSR_D
+	write16	WTCNT, WTCNT_D
+
+	/* Disable Register Bank interrupts */
+	/* write16 IBNR, IBNR_D */
+
+	/* Set clocks */
+	write16	FRQCR, FRQCR_D
+
+	/* Enable all peripherals(Standby Control) */
+	write8 STBCR3, STBCR3_D
+	write8 STBCR4, STBCR4_D
+	write8 STBCR5, STBCR5_D
+	write8 STBCR6, STBCR6_D
+	write8 STBCR7, STBCR7_D
+	write8 STBCR8, STBCR8_D
+	write8 STBCR9, STBCR9_D
+	write8 STBCR10, STBCR10_D
+	write8 STBCR11, STBCR11_D
+	write8 STBCR12, STBCR12_D
+
+	/* Port Control Register */
+	/* Port1 Control register Reset */
+	write16 PIBC1, PIBC1_D
+	write16 PBDC1, PBDC1_D
+	write16 PM1, PM1_D
+	write16 PMC1, PMC1_D
+	write16 PIPC1, PIPC1_D
+
+	/* Port1 Control register Set */
+	write16 PBDC1, PBDC1_S
+	write16 PFC1, PFC1_S
+	write16 PFCE1, PFCE1_S
+	write16 PFCAE1, PFCAE1_S
+	write16 PIPC1, PIPC1_S
+	write16 PMC1, PMC1_S
+	write16 P1, P1_S
+	write16 PM1, PM1_S
+	write16 PIBC1, PIBC1_S
+	
+	/* Port2 Control register Reset */
+	write16 PIBC2, PIBC2_D
+	write16 PBDC2, PBDC2_D
+	write16 PM2, PM2_D
+	write16 PMC2, PMC2_D
+	write16 PIPC2, PIPC2_D
+
+	/* Port2 Control register Set */
+	write16 PBDC2, PBDC2_S
+	write16 PFC2, PFC2_S
+	write16 PFCE2, PFCE2_S
+	write16 PFCAE2, PFCAE2_S
+	write16 PIPC2, PIPC2_S
+	write16 PMC2, PMC2_S
+	write16 P2, P2_S
+	write16 PM2, PM2_S
+	write16 PIBC2, PIBC2_S
+
+	/* Port3 Control register Reset */
+	write16 PIBC3, PIBC3_D
+	write16 PBDC3, PBDC3_D
+	write16 PM3, PM3_D
+	write16 PMC3, PMC3_D
+	write16 PIPC3, PIPC3_D
+
+	/* Port3 Control register Set */
+	write16 PBDC3, PBDC3_S
+	write16 PFC3, PFC3_S
+	write16 PFCE3, PFCE3_S
+	write16 PFCAE3, PFCAE3_S
+	write16 PIPC3, PIPC3_S
+	write16 PMC3, PMC3_S
+	write16 P3, P3_S
+	write16 PM3, PM3_S
+	write16 PIBC3, PIBC3_S
+
+	/* Port4 Control register Reset */
+	write16 PIBC4, PIBC4_D
+	write16 PBDC4, PBDC4_D
+	write16 PM4, PM4_D
+	write16 PMC4, PMC4_D
+	write16 PIPC4, PIPC4_D
+
+	/* Port4 Control register Set */
+	write16 PBDC4, PBDC4_S
+	write16 PFC4, PFC4_S
+	write16 PFCE4, PFCE4_S
+	write16 PFCAE4, PFCAE4_S
+	write16 PIPC4, PIPC4_S
+	write16 PMC4, PMC4_S
+	write16 P4, P4_S
+	write16 PM4, PM4_S
+	write16 PIBC4, PIBC4_S
+
+	/* Port5 Control register Reset */
+	write16 PIBC5, PIBC5_D
+	write16 PBDC5, PBDC5_D
+	write16 PM5, PM5_D
+	write16 PMC5, PMC5_D
+	write16 PIPC5, PIPC5_D
+
+	/* Port5 Control register Set */
+	write16 PBDC5, PBDC5_S
+	write16 PFC5, PFC5_S
+	write16 PFCE5, PFCE5_S
+	write16 PFCAE5, PFCAE5_S
+	write16 PIPC5, PIPC5_S
+	write16 PMC5, PMC5_S
+	write16 P5, P5_S
+	write16 PM5, PM5_S
+	write16 PIBC5, PIBC5_S
+
+	/* Port6 Control register Reset */
+	write16 PIBC6, PIBC6_D
+	write16 PBDC6, PBDC6_D
+	write16 PM6, PM6_D
+	write16 PMC6, PMC6_D
+	write16 PIPC6, PIPC6_D
+
+	/* Port6 Control register Set */
+	write16 PBDC6, PBDC6_S
+	write16 PFC6, PFC6_S
+	write16 PFCE6, PFCE6_S
+	write16 PFCAE6, PFCAE6_S
+	write16 PIPC6, PIPC6_S
+	write16 PMC6, PMC6_S
+	write16 P6, P6_S
+	write16 PM6, PM6_S
+	write16 PIBC6, PIBC6_S
+
+	/* Port7 Control register Reset */
+	write16 PIBC7, PIBC7_D
+	write16 PBDC7, PBDC7_D
+	write16 PM7, PM7_D
+	write16 PMC7, PMC7_D
+	write16 PIPC7, PIPC7_D
+
+	/* Port7 Control register Set */
+	write16 PBDC7, PBDC7_S
+	write16 PFC7, PFC7_S
+	write16 PFCE7, PFCE7_S
+	write16 PFCAE7, PFCAE7_S
+	write16 PIPC7, PIPC7_S
+	write16 PMC7, PMC7_S
+	write16 P7, P7_S
+	write16 PM7, PM7_S
+	write16 PIBC7, PIBC7_S
+
+	/* Port8 Control register Reset */
+	write16 PIBC8, PIBC8_D
+	write16 PBDC8, PBDC8_D
+	write16 PM8, PM8_D
+	write16 PMC8, PMC8_D
+	write16 PIPC8, PIPC8_D
+
+	/* Port8 Control register Set */
+	write16 PBDC8, PBDC8_S
+	write16 PFC8, PFC8_S
+	write16 PFCE8, PFCE8_S
+	write16 PFCAE8, PFCAE8_S
+	write16 PIPC8, PIPC8_S
+	write16 PMC8, PMC8_S
+	write16 P8, P8_S
+	write16 PM8, PM8_S
+	write16 PIBC8, PIBC8_S
+
+	/* Port9 Control register Reset */
+	write16 PIBC9, PIBC9_D
+	write16 PBDC9, PBDC9_D
+	write16 PM9, PM9_D
+	write16 PMC9, PMC9_D
+	write16 PIPC9, PIPC9_D
+
+	/* Port9 Control register Set */
+	write16 PBDC9, PBDC9_S
+	write16 PFC9, PFC9_S
+	write16 PFCE9, PFCE9_S
+	write16 PFCAE9, PFCAE9_S
+	write16 PIPC9, PIPC9_S
+	write16 PMC9, PMC9_S
+	write16 P9, P9_S
+	write16 PM9, PM9_S
+	write16 PIBC9, PIBC9_S
+
+	/* Port10 Control register Reset */
+	write16 PIBC10, PIBC10_D
+	write16 PBDC10, PBDC10_D
+	write16 PM10, PM10_D
+	write16 PMC10, PMC10_D
+	write16 PIPC10, PIPC10_D
+
+	/* Port10 Control register Set */
+	write16 PBDC10, PBDC10_S
+	write16 PFC10, PFC10_S
+	write16 PFCE10, PFCE10_S
+	write16 PFCAE10, PFCAE10_S
+	write16 PIPC10, PIPC10_S
+	write16 PMC10, PMC10_S
+	write16 P10, P10_S
+	write16 PM10, PM10_S
+	write16 PIBC10, PIBC10_S
+
+	/* Port11 Control register Reset */
+	write16 PIBC11, PIBC11_D
+	write16 PBDC11, PBDC11_D
+	write16 PM11, PM11_D
+	write16 PMC11, PMC11_D
+	write16 PIPC11, PIPC11_D
+
+	/* Port11 Control register Set */
+	write16 PBDC11, PBDC11_S
+	write16 PFC11, PFC11_S
+	write16 PFCE11, PFCE11_S
+	write16 PFCAE11, PFCAE11_S
+	write16 PIPC11, PIPC11_S
+	write16 PMC11, PMC11_S
+	write16 P11, P11_S
+	write16 PM11, PM11_S
+	write16 PIBC11, PIBC11_S
+
+	/* Configure bus (CS0, CS1) */
+	write32 CS0WCR, CS0WCR_D
+	write32 CS0BCR, CS0BCR_D
+	write32 CS1WCR, CS1WCR_D
+	write32 CS1BCR, CS1BCR_D
+
+	/* Enable all internal RAM */
+	write8 SYSCR1, 0xFF
+	write8 SYSCR2, 0xFF
+	write8 SYSCR3, 0xFF
+
+	/* Configure SDRAM (CS2, CS3) */
+	write32	CS2BCR, CS2BCR_D
+	write32	CS2WCR, CS2WCR_D
+	write32	CS3BCR, CS3BCR_D
+	write32	CS3WCR, CS3WCR_D
+	write32	SDCR, SDCR_D
+	write32	RTCOR, RTCOR_D
+	write32	RTCSR, RTCSR_D
+
+	/* wait */
+	ldr	r3, REPEAT_D
+	mov	r2, #0
+repeat0:
+	add	r2, r2, #1
+	cmp	r2, r3
+	ble	repeat0
+	nop
+
+	ldr	r1, SDRAM_MODE_CS2
+	mov	r0, #0
+	str	r0, [r1]
+	ldr	r1, SDRAM_MODE_CS3
+	mov	r0, #0
+	str	r0, [r1]
+
+	nop
+	/* back to arch calling code */
+	mov	pc, lr
+
+	.align 4
+
+.align 2
+SDRAM_MODE_CS2:	.long 0x3FFFD040
+SDRAM_MODE_CS3:	.long 0x3FFFE040
+REPEAT_D:	.long 0x000033F1
diff --git a/board/renesas/rskrza1/rskrza1.c b/board/renesas/rskrza1/rskrza1.c
new file mode 100644
index 0000000..1c8950d
--- /dev/null
+++ b/board/renesas/rskrza1/rskrza1.c
@@ -0,0 +1,534 @@
+/*
+ * Copyright (C) 2008-2013 Renesas Solutions Corp.
+ * Copyright (C) 2012 Renesas Electronics Europe Ltd.
+ * Copyright (C) 2012 Phil Edworthy
+ * Copyright (C) 2008 Nobuhiro Iwamatsu
+ *
+ * Based on u-boot/board/rsk7264/rsk7264.c
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <i2c.h>
+#include <rtc.h>
+#include <asm/arch/rza1-regs.h>
+
+#include <spi.h>
+#include <spi_flash.h>
+
+//#define DEBUG
+
+int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len);
+struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int spi_mode);
+int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
+		const void *data, size_t data_len);
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	puts("BOARD: Renesas R7S72100\n");
+	return 0;
+}
+
+int board_init(void)
+{
+	gd->bd->bi_boot_params = (CONFIG_SYS_SDRAM_BASE + 0x100);
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	rtc_reset();	/* to start rtc */
+	return 0;
+}
+
+int board_late_init(void)
+{
+	u8 mac[6];
+	u8 tmp[1];
+
+	/* Read Mac Address and set*/
+	i2c_init(CONFIG_SYS_I2C_SPEED, 0);
+	i2c_set_bus_num(CONFIG_SYS_I2C_MODULE);
+
+	/*
+	 * PORT EXPANDER
+	 *
+	 * PX1.0  LED1             O  1  0=ON, 1=OFF
+	 * PX1.1  LED2             O  1  0=ON, 1=OFF
+	 * PX1.2  LED3             O  1  0=ON, 1=OFF
+	 * PX1.3  NOR_A25          O  0  Bit #25 of NOR Flash Addressing
+	 * PX1.4  PMOD1_RST        O  1  Reset for PMOD channel 1
+	 * PX1.5  PMOD2_RST        O  1  Reset for PMOD channel 2
+	 * PX1.6  SD_CONN_PWR_EN   O  0  Enable power supply for external SD card
+	 * PX1.7  SD_MMC_PWR_EN    O  1  Enable power supply for MMC card
+	 * 
+	 * PX2.0  PX1_EN0          O  0  0=LCD, 1=DV
+	 * PX2.1  PX1_EN1          O  1  0=General Data, 1=Ethernet
+	 * PX2.2  TFT_CS           O  0  Chip select for TFT
+	 * PX2.3  PX1_EN3          O  0  0=PWM timer channels, 1=ADC/DAC I/O lines
+	 * PX2.4  USB_OVR_CURRENT  I  1  Signal from USB power controller (over-current)
+	 * PX2.5  USB_PWR_ENA      O  0  Enable power supply for USB channel 0
+	 * PX2.6  USB_PWR_ENB      O  0  Enable power supply for USB channel 1
+	 * PX2.7  PX1_EN7          O  0  0=A18-A21, 1=SGOUT0-SGOUT4
+	 */
+
+	/* init PX01(IC34) */
+	tmp[0] = 0x00;
+	i2c_write(0x20, 3, 1, tmp, 1); /* config */
+	tmp[0] = 0x37;
+	i2c_write(0x20, 1, 1, tmp, 1); /* output */
+
+	/*init PX02(IC35) */
+	tmp[0] = 0x10;
+	i2c_write(0x21, 3, 1, tmp, 1); /* config */
+	tmp[0] = 0x12;
+	i2c_write(0x21, 1, 1, tmp, 1); /* output */
+
+	/* Read MAC address */
+	i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR,
+		 CONFIG_SH_ETHER_EEPROM_ADDR,
+		 CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+		 mac, 6);
+
+	if (is_valid_ether_addr(mac))
+		eth_setenv_enetaddr("ethaddr", mac);
+
+#if !defined(CONFIG_BOOT_MODE0)
+	printf(	"\t\t      SPI Flash Memory Map\n"
+		"\t\t------------------------------------\n"
+		"\t\t         Start      Size     SPI\n");
+	printf(	"\t\tu-boot:  0x%08X 0x%06X 0\n", 0,CONFIG_ENV_OFFSET);
+	printf(	"\t\t   env:  0x%08X 0x%06X 0\n", CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE);
+	printf(	"\t\t    DT:  0x%08X 0x%06X 0\n", CONFIG_ENV_OFFSET+CONFIG_ENV_SIZE,CONFIG_ENV_SECT_SIZE);
+	printf(	"\t\tKernel:  0x%08X 0x%06X 0+1 (size*=2)\n",0x100000, 0x280000);
+	printf(	"\t\trootfs:  0x%08X 0x%06X 0+1 (size*=2)\n",0x400000, 0x2000000-0x400000);
+#endif
+
+	/* Boot uImage in external SDRAM */
+	/* Rootfs is a squashfs image in memory mapped QSPI */
+	/* => run s_boot */
+	setenv("s1", "sf probe 0; sf read 09800000 C0000 2000"); // Read out DT blob
+	setenv("s2", "sf probe 0:1; sf read 09000000 100000 500000"); //Copy Kernel to SDRAM
+	setenv("s3", "bootm start 0x09000000 - 0x09800000 ; bootm loados ;"\
+			"fdt memory 0x08000000 0x02000000"); // Change memory address in DTB
+	setenv("s4", "qspi dual a4 d4 sdr"); // Change XIP interface to dual QSPI
+	setenv("sargs", "console=ttySC2,115200 console=tty0 ignore_loglevel root=/dev/mtdblock0"); // bootargs
+	setenv("s_boot", "run s1 s2 s3 s4; set bootargs ${sargs}; fdt chosen; bootm go"); // run the commands
+
+	/* Boot XIP using internal RAM */
+	/* Rootfs is a squashfs image in memory mapped QSPI */
+	/* => run x_boot */
+	/* Read out DT blob */
+	setenv("x1", "sf probe 0; sf read 20500000 C0000 2000");
+	/* Change memory address in DTB */
+	setenv("x2", "fdt addr 20500000 ; fdt memory 0x20000000 0x00A00000"); /* 10MB RAM */
+	/* Change XIP interface to dual QSPI */
+	setenv("x3", "qspi dual a4 d4 sdr");
+	setenv("xargs", "console=ttySC2,115200 console=tty0 ignore_loglevel root=/dev/mtdblock0"); // bootargs
+	setenv("x_boot", "run x1 x2 x3; set bootargs ${xargs}; fdt chosen; bootx 18200000 20500000"); // run the commands
+
+	/* Boot XIP using internal RAM */
+	/* Rootfs is a AXFS image in memory mapped QSPI */
+	/* => run xa_boot */
+	/* Read out DT blob */
+	setenv("xa1", "sf probe 0; sf read 20500000 C0000 2000");
+	/* Change memory address in DTB */
+	setenv("xa2", "fdt addr 20500000 ; fdt memory 0x20000000 0x00A00000"); /* 10MB RAM */
+	/* Change XIP interface to dual QSPI */
+	setenv("xa3", "qspi dual a4 d4 sdr");
+	setenv("xaargs", "console=ttySC2,115200 console=tty0 ignore_loglevel root=/dev/null rootflags=physaddr=0x18800000"); // bootargs
+	setenv("xa_boot", "run xa1 xa2 xa3; set bootargs ${xaargs}; fdt chosen; bootx 18200000 20500000"); // run the commands
+
+	return 0;
+}
+
+int dram_init(void)
+{
+#if (1 !=  CONFIG_NR_DRAM_BANKS)
+# error CONFIG_NR_DRAM_BANKS must set 1 in this board.
+#endif
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	gd->bd->bi_dram[0].size = CONFIG_SYS_SDRAM_SIZE;
+	gd->ram_size = CONFIG_SYS_SDRAM_SIZE * CONFIG_NR_DRAM_BANKS;
+
+	return 0;
+}
+
+void reset_cpu(ulong addr)
+{
+}
+
+void led_set_state(unsigned short value)
+{
+}
+
+/* XIP Kernel boot */
+int do_bootx(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong machid = MACH_TYPE_RSKRZA1;
+	void (*kernel_entry)(int zero, int arch, uint params);
+	ulong r2;
+	ulong img_addr;
+	char *endp;
+
+	/* need at least two arguments */
+	if (argc < 2)
+		goto usage;
+/*
+	if (argc < 2) {
+		if (strcmp(argv[3], "xxx") == 0) {
+			; ; ;
+		}
+	}
+*/
+	img_addr = simple_strtoul(argv[1], &endp, 16);
+	kernel_entry = (void (*)(int, int, uint))img_addr;
+
+#ifdef CONFIG_USB_DEVICE
+	udc_disconnect();
+#endif
+	cleanup_before_linux();
+
+	r2 = simple_strtoul(argv[2], NULL, 16);
+#if 0
+#ifdef CONFIG_OF_LIBFDT
+	if (images->ft_len)
+		r2 = (unsigned long)images->ft_addr;
+	else
+#endif
+		r2 = gd->bd->bi_boot_params;
+#endif
+	printf("Booting Linux...\n");
+
+	kernel_entry(0, machid, r2);
+
+	return 0;
+
+usage:
+	return CMD_RET_USAGE;
+}
+static char bootx_help_text[] =
+	"x_addr dt_addr\n    - boot XIP kernel in Flash\n"
+	"\t x_addr: Address of XIP kernel in Flash\n"
+	"\tdt_addr: Address of Device Tree blob image";
+U_BOOT_CMD(
+	bootx,	CONFIG_SYS_MAXARGS,	1,	do_bootx,
+	"boot XIP kernel in Flash", bootx_help_text
+);
+
+
+#define CMNCR_0	0x3FEFA000	/* Common control register */
+#define DRCR_0	0x3FEFA00C	/* Data Read Control Register */
+#define DRCMR_0	0x3FEFA010	/* Data Read Command Setting Register */
+#define DREAR_0 0x3FEFA014	/* Data read extended address setting register */
+#define DRENR_0 0x3FEFA01C	/* Data read enable setting register */
+#define DROPR_0 0x3FEFA018	/* Data read option setting register */
+#define DMDMCR_0 0x3FEFA058	/* SPI Mode Dummy Cycle Setting Register */
+#define DRDRENR_0 0x3FEFA05C	/* Data Read DDR Enable Register */
+
+
+struct read_mode {
+	u8 cmd;
+	char name[50];
+};
+#define READ_MODES 5
+const struct read_mode modes[READ_MODES] = {
+	{0x03, "Read Mode (3-byte Addr)"},
+	{0x0C, "Fast Read Mode (4-byte Addr)"},
+	{0x6C, "Quad Read Mode (4-byte Addr)"},
+	{0xEC, "Quad I/O Read Mode (4-byte Addr)"},
+	{0xEE, "Quad I/O DDR Read Mode (4-byte Addr)"},
+};
+
+/* QUAD SPI MODE */
+int do_qspi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct spi_flash *my_spi_flash;
+	int ret = 0;
+	int i;
+	u8 data[2];
+	u8 cmd;
+	u8 dual_chip;
+	u8 quad_data;
+	u8 quad_addr;
+	u8 ddr;
+	u32 dmdmcr, drenr, cmncr, drcmr, dropr, drdrenr;
+
+	/* need at least two arguments */
+	if (argc < 4)
+		goto usage;
+
+	if ( strcmp(argv[1], "single") == 0)
+		dual_chip = 0;
+	else if ( strcmp(argv[1], "dual") == 0)
+		dual_chip = 1;
+	else
+		goto usage;
+
+	if ( strcmp(argv[2], "a1") == 0)
+		quad_addr = 0;
+	else if ( strcmp(argv[2], "a4") == 0)
+		quad_addr = 1;
+	else
+		goto usage;
+
+	if ( strcmp(argv[3], "d1") == 0)
+		quad_data = 0;
+	else if ( strcmp(argv[3], "d4") == 0)
+		quad_data = 1;
+	else
+		goto usage;
+
+	if ( strcmp(argv[4], "sdr") == 0)
+		ddr = 0;
+	else if ( strcmp(argv[4], "ddr") == 0)
+		ddr = 1;
+	else
+		goto usage;
+
+	/* checks */
+	if( quad_addr && !quad_data )
+		return CMD_RET_USAGE;
+	if( ddr && !quad_addr )
+		return CMD_RET_USAGE;
+
+	/* Read initial register values */
+	dmdmcr = *(volatile u32 *)DMDMCR_0;
+	drenr = *(volatile u32 *)DRENR_0;
+	cmncr = *(volatile u32 *)CMNCR_0;
+	drcmr = *(volatile u32 *)DRCMR_0;
+	dropr = *(volatile u32 *)DROPR_0;
+	drdrenr = *(volatile u32 *)DRDRENR_0;
+
+	printf("Current Mode: ");
+	cmd = (drcmr >> 16) & 0xFF;
+	for( i=0; i < READ_MODES; i++) {
+		if( modes[i].cmd == cmd )
+			printf("%s\n",modes[i].name);
+	}
+
+	/* bus=0, cs=0, speed=1000000 */
+	if( dual_chip )
+		my_spi_flash = spi_flash_probe(0, 1, 1000000, SPI_MODE_3);
+	else
+		my_spi_flash = spi_flash_probe(0, 0, 1000000, SPI_MODE_3);
+
+	if (!my_spi_flash) {
+		printf("Failed to initialize SPI flash.");
+		return 1;
+	}
+
+	/* Read Status register (RDSR1 05h) */
+	ret |= spi_flash_cmd(my_spi_flash->spi, 0x05, &data[0], 1);
+
+	/* Read Configuration register (RDCR 35h) */
+	ret |= spi_flash_cmd(my_spi_flash->spi, 0x35, &data[1], 1);
+
+#ifdef DEBUG
+	printf("Initial Status register = %02X\n", data[0]);
+	printf("Initial Configuration register = %02X\n", data[1]);
+#endif
+
+	/**********************/
+	/* Spansion S25FL512S */
+	/**********************/
+
+	/* Skip SPI Flas configure if already correct */
+//	if ( data[1] != 0x02 ) {
+	if ( 1  ) {
+		data[0] = 0x00;	/* status reg: Don't Care */
+		if( quad_data )
+			data[1] = 0x02; /* confg reg: Set QUAD, LC=00b */
+		else
+			data[1] = 0x02; /* confg reg: clear QUAD, LC=00b */
+			//data[1] = 0x00; /* confg reg: clear QUAD, LC=00b */
+
+		if( quad_addr )
+#ifdef LC_SET_TO_11 /* Dangerous! Once you set LC=11, it break JTAG programming */
+			data[1] = 0xC2; /* confg reg: Set QUAD, LC=11b */
+#else
+			data[1] = 0x02; /* confg reg: Set QUAD, LC=00b */
+#endif
+		/* Send Write Enable (WREN 06h) */
+		ret |= spi_flash_cmd(my_spi_flash->spi, 0x06, NULL, 0);
+
+		/* Send Write Registers (WRR 01h) */
+		cmd = 0x01;
+		ret |= spi_flash_cmd_write(my_spi_flash->spi, &cmd, 1, data, 2);
+
+		/* Wait till WIP clears */
+		do
+			spi_flash_cmd(my_spi_flash->spi, 0x05, &data[0], 1);
+		while( data[0] & 0x01 );
+
+#ifdef DEBUG
+		ret |= spi_flash_cmd(my_spi_flash->spi, 0x05, &data[0], 1);
+		ret |= spi_flash_cmd(my_spi_flash->spi, 0x35, &data[1], 1);
+
+		printf("Status register after setting = %02X\n", data[0]);
+		printf("Configuration register after setting = %02X\n", data[1]);
+#endif
+	}
+
+	/* Done with SPI Flash */
+	spi_flash_free(my_spi_flash);
+
+	if ( ret )
+	{
+		printf("Failed to set SPI Flash Configuratin register.\n");
+		return 1;
+	}
+
+	/***************************/
+	/* Set up RZ SPI Registers */
+	/***************************/
+	/* Enable data swap (SFDE) */
+	/* Keeps the endian order of bytes the same on the internal bus
+	   regardless of how you fetched them over SPI */
+	cmncr |= 0x01000000UL;
+
+	if( dual_chip ) {
+		/* Switch to dual memory */
+		cmncr |= 0x00000001UL;
+
+	}
+	else {
+		/* Switch to single memory */
+		cmncr &= ~0x00000001UL;
+	}
+
+	/* 1-bit address, 4-bit data */
+	if( quad_data && !quad_addr ) {
+		/* Set read cmd to 0x6C (Quad Read) */
+		drcmr = 0x006C0000UL;
+
+		/* width: 1-bit cmd, 1-bit addr, 4-bit data */
+		/* address: 32 bits */
+		drenr = 0x00024f00UL;
+
+		/* According to the Spansion spec (Table 8.5), dummy cycles
+		   are needed when LC=00b for QUAD READ commands */
+		/* Add extra Dummy cycles between address and data */
+		dmdmcr = 0x00020007; /* 4 bit width, 8 cycles */
+		drenr |= 0x00008000; /* Set Dummy Cycle Enable (DME) */
+	}
+
+	/* 1-bit address, 1-bit data */
+	if( !quad_data && !quad_addr ) {
+		/* Set read cmd to 0x0C (FAST Read) */
+		drcmr =0x000C0000;
+
+		/* width: 1-bit cmd, 1-bit addr, 1-bit data */
+		/* address: 32 bits */
+		drenr = 0x00004f00;
+
+		/* According to the Spansion spec (Table 8.5), dummy cycles
+		   are needed when LC=00b for FAST READ commnds */
+		/* Add extra Dummy cycles between address and data */
+		dmdmcr = 0x00000007; /* 1 bit width, 8 cycles */
+		drenr |= 0x00008000; /* Set Dummy Cycle Enable (DME) */
+	}
+
+	/* 4-bit address, 4-bit data */
+	if( quad_addr ) {
+		/* Spansion S25FL512S */
+		/* Single Data Rate, Quad I/O Read, Latency Code =00b
+			<> command = 1-bit, 8 clocks
+			<> Addr(32bit) = 4-bit, 8 clocks,
+			<> Mode = 4-bit, 2 clocks
+			<> Dummy = 4-bit, 4 clocks
+			<> Data = 4-bit, 2 clocks x {length}
+
+			See "Figure 10.37 Quad I/O Read Command Sequence" in Spansion spec
+		*/
+
+		/* Set read cmd to 0xEC (Quad I/O) */
+		drcmr =0x00EC0000;
+
+		/* width: 1-bit cmd, 4-bit addr, 4-bit data */
+		/* address: 32 bits */
+		drenr = 0x02024f00;
+
+		/* Use Option data regsiters to output 0x00 to write the
+		   'mode' byte by sending OPD3 (at 4-bit) between address
+		   and dummy */
+		dropr = 0x00000000;
+		drenr |= 0x00200080;	// send OPD3 at 4-bits
+
+		/* According to the Spansion spec (Table 8.5), dummy cycles
+		   are needed when LC=00b for QUAD I/O READ commnds */
+		/* Add extra Dummy cycles between address and data */
+#ifdef LC_SET_TO_11 /* Dangerous! Once you set LC=11, it break JTAG programming */
+		dmdmcr = 0x00020000; /* 4 bit size, 1 cycle */
+#else
+		dmdmcr = 0x00020003; /* 4 bit size, 4 cycles */
+#endif
+		drenr |= 0x00008000; /* Set Dummy Cycle Enable (DME) */
+	}
+
+	if ( ddr ) {
+		printf( "WARNING: DDR mode doesn't actually work yet on the RSKRZA1 board.\n"
+			"   The Spansion SPI flash has an extra phase in the command stream\n"
+			"   that we can't account for.\n");
+
+		/* Set read cmd to 0xEE (Read DDR Quad I/O) */
+		drcmr =0x00EE0000;
+
+		/* Address, option and data all 4-bit DDR */
+		drdrenr = 0x00000111;
+
+		/* According to the Spansion spec (Table 8.5), dummy cycles
+		   are needed when LC=00b for READ DDR QUAD I/O commnds */
+		/* Add extra Dummy cycles between address and data */
+		dmdmcr = 0x00020005; /* 4 bit size, 6 cycles */
+		drenr |= 0x00008000; /* Set Dummy Cycle Enable (DME) */
+	}
+	else {
+		drdrenr = 0;
+	}
+
+	/* Set new register values */
+	*(volatile u32 *)DMDMCR_0 = dmdmcr;
+	*(volatile u32 *)DRENR_0 = drenr;
+	*(volatile u32 *)CMNCR_0 = cmncr;
+	*(volatile u32 *)DRCMR_0 = drcmr;
+	*(volatile u32 *)DROPR_0 = dropr;
+	*(volatile u32 *)DRDRENR_0 = drdrenr;
+
+	/* Allow 32MB of SPI addressing (POR default is only 16MB) */
+	*(volatile u32 *)DREAR_0 = 0x00000001;
+
+	/* Turn Read Burst on, Burst Length=2 uints (also set cache flush) */
+	/* Keep SSL low (SSLE=1) in case the next transfer is continugous with
+	   our last...saves on address cycle. */
+	*(u32 *)DRCR_0 = 0x00010301;
+	*(volatile u32 *)DRCR_0;	/* Read must be done after cache flush */
+
+	printf("New Mode: ");
+	cmd = (*(volatile long *)DRCMR_0 >> 16) & 0xFF;
+	for( i=0; i < READ_MODES; i++) {
+		if( modes[i].cmd == cmd )
+			printf("%s\n",modes[i].name);
+	}
+
+	return 0;
+usage:
+	return CMD_RET_USAGE;
+}
+static char qspi_help_text[] =
+	"Set the XIP Mode for QSPI\n"
+	"Usage: qspi [single|dual] [a1|a4] [d1|d4] [sdr|ddr]\n"
+	"  'a4' requries 'd4' to be set\n"
+	"  'ddr' requries 'd4' and 'a4' to be set\n";
+U_BOOT_CMD(
+	qspi,	CONFIG_SYS_MAXARGS,	1,	do_qspi,
+	"Change QSPI XIP Mode", qspi_help_text
+);
+
diff --git a/configs/rskrza1_defconfig b/configs/rskrza1_defconfig
new file mode 100644
index 0000000..06c119e
--- /dev/null
+++ b/configs/rskrza1_defconfig
@@ -0,0 +1,3 @@
+CONFIG_ARM=y
+CONFIG_RZA1=y
+CONFIG_TARGET_RSKRZA1=y
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index 6f3c86c..4316dd5 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -1,6 +1,7 @@
 #
 # (C) Copyright 2000-2007
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+# Copyright (C) 2013 Renesas Solutions Corp.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
@@ -32,3 +33,4 @@ obj-$(CONFIG_SYS_I2C_SH) += sh_i2c.o
 obj-$(CONFIG_SYS_I2C_SOFT) += soft_i2c.o
 obj-$(CONFIG_SYS_I2C_TEGRA) += tegra_i2c.o
 obj-$(CONFIG_SYS_I2C_ZYNQ) += zynq_i2c.o
+obj-$(CONFIG_SH_RIIC) += sh_riic.o
diff --git a/drivers/i2c/sh_riic.c b/drivers/i2c/sh_riic.c
new file mode 100644
index 0000000..4607894
--- /dev/null
+++ b/drivers/i2c/sh_riic.c
@@ -0,0 +1,527 @@
+/*
+ * RIIC bus driver
+ *
+ * Copyright (C) 2011-2013  Renesas Solutions Corp.
+ * Copyright (C) 2011 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
+ *
+ * Based on i2c-sh_mobile.c
+ * Portion Copyright (C) 2008 Magnus Damm
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#include <asm/errno.h>
+#include <common.h>
+#include <asm/io.h>
+
+#define RIIC_ICCR1	0x00
+#define RIIC_ICCR2	0x04
+#define RIIC_ICMR1	0x08
+#define RIIC_ICMR2	0x0c
+#define RIIC_ICMR3	0x10
+#define RIIC_ICFER	0x14
+#define RIIC_ICSER	0x18
+#define RIIC_ICIER	0x1c
+#define RIIC_ICSR1	0x20
+#define RIIC_ICSR2	0x24
+#define RIIC_ICBRL	0x34
+#define RIIC_ICBRH	0x38
+#define RIIC_ICDRT	0x3c
+#define RIIC_ICDRR	0x40
+
+/* ICCR1 */
+#define ICCR1_ICE	0x80
+#define ICCR1_IICRST	0x40
+#define ICCR1_CLO	0x20
+#define ICCR1_SOWP	0x10
+#define ICCR1_SCLO	0x08
+#define ICCR1_SDAO	0x04
+#define ICCR1_SCLI	0x02
+#define ICCR1_SDAI	0x01
+
+/* ICCR2 */
+#define ICCR2_BBSY	0x80
+#define ICCR2_MST	0x40
+#define ICCR2_TRS	0x20
+#define ICCR2_SP	0x08
+#define ICCR2_RS	0x04
+#define ICCR2_ST	0x02
+
+/* ICMR1 */
+#define ICMR1_MTWP	0x80
+#define ICMR1_CKS_MASK	0x70
+#define ICMR1_BCWP	0x08
+#define ICMR1_BC_MASK	0x07
+
+#define ICMR1_CKS(_x)	((_x << 4) & ICMR1_CKS_MASK)
+#define ICMR1_BC(_x)	((_x) & ICMR1_BC_MASK)
+
+/* ICMR2 */
+#define ICMR2_DLCS	0x80
+#define ICMR2_SDDL_MASK	0x70
+#define ICMR2_TMOH	0x04
+#define ICMR2_TMOL	0x02
+#define ICMR2_TMOS	0x01
+
+/* ICMR3 */
+#define ICMR3_SMBS	0x80
+#define ICMR3_WAIT	0x40
+#define ICMR3_RDRFS	0x20
+#define ICMR3_ACKWP	0x10
+#define ICMR3_ACKBT	0x08
+#define ICMR3_ACKBR	0x04
+#define ICMR3_NF_MASK	0x03
+
+/* ICFER */
+#define ICFER_FMPE	0x80
+#define ICFER_SCLE	0x40
+#define ICFER_NFE	0x20
+#define ICFER_NACKE	0x10
+#define ICFER_SALE	0x08
+#define ICFER_NALE	0x04
+#define ICFER_MALE	0x02
+#define ICFER_TMOE	0x01
+
+/* ICSER */
+#define ICSER_HOAE	0x80
+#define ICSER_DIDE	0x20
+#define ICSER_GCAE	0x08
+#define ICSER_SAR2E	0x04
+#define ICSER_SAR1E	0x02
+#define ICSER_SAR0E	0x01
+
+/* ICIER */
+#define ICIER_TIE	0x80
+#define ICIER_TEIE	0x40
+#define ICIER_RIE	0x20
+#define ICIER_NAKIE	0x10
+#define ICIER_SPIE	0x08
+#define ICIER_STIE	0x04
+#define ICIER_ALIE	0x02
+#define ICIER_TMOIE	0x01
+
+/* ICSR1 */
+#define ICSR1_HOA	0x80
+#define ICSR1_DID	0x20
+#define ICSR1_GCA	0x08
+#define ICSR1_AAS2	0x04
+#define ICSR1_AAS1	0x02
+#define ICSR1_AAS0	0x01
+
+/* ICSR2 */
+#define ICSR2_TDRE	0x80
+#define ICSR2_TEND	0x40
+#define ICSR2_RDRF	0x20
+#define ICSR2_NACKF	0x10
+#define ICSR2_STOP	0x08
+#define ICSR2_START	0x04
+#define ICSR2_AL	0x02
+#define ICSR2_TMOF	0x01
+
+/* ICBRH */
+#define ICBRH_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRH_BRH_MASK	0x1f
+
+/* ICBRL */
+#define ICBRL_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRL_BRL_MASK	0x1f
+
+#define RIIC_TIMEOUT	10000	/* 100msec (unit = 10usec) */
+
+struct riic_data {
+	unsigned int reg;
+};
+static struct riic_data i_pd[CONFIG_SYS_MAX_I2C_BUS] =
+	{ { CONFIG_SH_I2C_BASE0 },
+#ifdef CONFIG_SH_I2C_BASE1
+	  { CONFIG_SH_I2C_BASE1 },
+#endif
+#ifdef CONFIG_SH_I2C_BASE2
+	  { CONFIG_SH_I2C_BASE2 },
+#endif
+#ifdef CONFIG_SH_I2C_BASE3
+	  { CONFIG_SH_I2C_BASE3 },
+#endif
+#ifdef CONFIG_SH_I2C_BASE4
+	  { CONFIG_SH_I2C_BASE4 },
+#endif
+	};
+static struct riic_data *pd = &i_pd[0];
+
+static unsigned int current_bus;
+
+/**
+ * i2c_set_bus_num - change active I2C bus
+ *	@bus: bus index, zero based
+ *	@returns: 0 on success, non-0 on failure
+ */
+int i2c_set_bus_num(unsigned int bus)
+{
+	if ((bus < 0) || (bus >= CONFIG_SYS_MAX_I2C_BUS)) {
+		printf("Bad bus: %d\n", bus);
+		return -1;
+	}
+
+	pd = &i_pd[bus];
+	current_bus = bus;
+
+	return 0;
+}
+
+static unsigned char riic_read(struct riic_data *pd, unsigned long addr)
+{
+	return inb(pd->reg + addr);
+}
+
+static void riic_write(struct riic_data *pd, unsigned char data,
+		       unsigned long addr)
+{
+	outb(data, pd->reg + addr);
+}
+
+static void riic_set_bit(struct riic_data *pd, unsigned char val,
+			 unsigned long offset)
+{
+	unsigned char tmp;
+
+	tmp = riic_read(pd, offset) | val;
+	riic_write(pd, tmp, offset);
+}
+
+static void riic_clear_bit(struct riic_data *pd, unsigned char val,
+			   unsigned long offset)
+{
+	unsigned char tmp;
+
+	tmp = riic_read(pd, offset) & ~val;
+	riic_write(pd, tmp, offset);
+}
+
+static int riic_set_clock(struct riic_data *pd, int clock)
+{
+	switch (clock) {
+	case 100000:
+		riic_clear_bit(pd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(pd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(pd, ICMR1_CKS(3), RIIC_ICMR1);
+		riic_write(pd, ICBRH_RESERVED | 23, RIIC_ICBRH);
+		riic_write(pd, ICBRL_RESERVED | 23, RIIC_ICBRL);
+		break;
+	case 400000:
+		riic_clear_bit(pd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(pd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(pd, ICMR1_CKS(1), RIIC_ICMR1);
+		riic_write(pd, ICBRH_RESERVED | 20, RIIC_ICBRH);
+		riic_write(pd, ICBRL_RESERVED | 19, RIIC_ICBRL);
+		break;
+	case 1000000:
+		riic_set_bit(pd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(pd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(pd, ICMR1_CKS(0), RIIC_ICMR1);
+		riic_write(pd, ICBRH_RESERVED | 14, RIIC_ICBRH);
+		riic_write(pd, ICBRL_RESERVED | 14, RIIC_ICBRL);
+		break;
+
+	default:
+		printf("unsupported clock (%dkHz)\n", clock);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int riic_check_busy(void)
+{
+	if (riic_read(pd, RIIC_ICCR2) & ICCR2_BBSY) {
+		printf("i2c bus is busy.\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int riic_init_setting(struct riic_data *pd, int clock)
+{
+	int ret;
+
+	riic_clear_bit(pd, ICCR1_ICE, RIIC_ICCR1);
+	riic_set_bit(pd, ICCR1_IICRST, RIIC_ICCR1);
+	riic_clear_bit(pd, ICCR1_IICRST, RIIC_ICCR1);
+
+	riic_write(pd, ICSER_SAR0E, RIIC_ICSER);
+
+	riic_write(pd, ICMR1_BC(7), RIIC_ICMR1);
+	ret = riic_set_clock(pd, clock);
+	if (ret < 0)
+		return ret;
+
+	riic_set_bit(pd, ICCR1_ICE, RIIC_ICCR1);	/* Enable RIIC */
+	riic_set_bit(pd, ICMR3_RDRFS | ICMR3_WAIT | ICMR3_ACKWP, RIIC_ICMR3);
+
+	return 0;
+}
+
+static int riic_wait_for_icsr2(struct riic_data *pd, unsigned short bit)
+{
+	unsigned char icsr2;
+	int timeout = RIIC_TIMEOUT;
+
+	while (timeout-- > 0) {
+		icsr2 = riic_read(pd, RIIC_ICSR2);
+		if (icsr2 & ICSR2_NACKF)
+			return -EIO;
+		if (icsr2 & bit)
+			return 0;
+		udelay(10);
+	}
+
+	printf("%s: Timeout!(bit = %x icsr2 = %x, iccr2 = %x)\n", __func__,
+		bit, riic_read(pd, RIIC_ICSR2), riic_read(pd, RIIC_ICCR2));
+
+	return -ETIMEDOUT;
+}
+
+static int riic_check_nack_receive(void)
+{
+	if (riic_read(pd, RIIC_ICSR2) & ICSR2_NACKF) {
+		/* received NACK */
+		riic_clear_bit(pd, ICSR2_NACKF, RIIC_ICSR2);
+		riic_set_bit(pd, ICCR2_SP, RIIC_ICCR2);
+		riic_read(pd, RIIC_ICDRR);	/* dummy read */
+		return -1;
+	}
+	return 0;
+}
+
+static void riic_set_receive_ack(struct riic_data *pd, int ack)
+{
+	if (ack)
+		riic_clear_bit(pd, ICMR3_ACKBT, RIIC_ICMR3);
+	else
+		riic_set_bit(pd, ICMR3_ACKBT, RIIC_ICMR3);
+}
+
+static int riic_i2c_raw_write(u8 *buf, int len)
+{
+	int ret = 0;
+	int index = 0;
+
+	do {
+		ret = riic_check_nack_receive();
+		if (ret < 0)
+			return -1;
+
+		ret = riic_wait_for_icsr2(pd, ICSR2_TDRE);
+		if (ret < 0)
+			return -1;
+
+		riic_write(pd, buf[index++], RIIC_ICDRT);
+	} while (len > index);
+
+	return ret;
+}
+
+static int riic_i2c_raw_read(u8 *buf, int len)
+{
+	int dummy_read = 1;
+	int ret = 0;
+	int index = 0;
+
+	while ((len - 1) > index) {
+		ret = riic_wait_for_icsr2(pd, ICSR2_RDRF);
+		if (ret < 0)
+			return ret;
+
+		buf[index] = riic_read(pd, RIIC_ICDRR);
+		if (dummy_read)
+			dummy_read = 0;
+		else
+			index++;
+		riic_set_receive_ack(pd, 1);
+	}
+
+	ret = riic_wait_for_icsr2(pd, ICSR2_RDRF);
+	if (ret < 0)
+		return ret;
+
+	riic_clear_bit(pd, ICSR2_STOP, RIIC_ICSR2);
+	riic_set_bit(pd, ICCR2_SP, RIIC_ICCR2);
+
+	buf[index++] = riic_read(pd, RIIC_ICDRR);
+	riic_set_receive_ack(pd, 0);
+
+	return ret;
+}
+
+static int riic_send_mem_addr(u32 addr, int alen)
+{
+	int i;
+	u8 b[4];
+
+	if (alen > 4 || alen <= 0)
+		return -1;
+	/* change byte order and shift bit */
+	for (i = alen - 1; i >= 0; i--, addr >>= 8)
+		b[i] = addr & 0xff;
+
+	return riic_i2c_raw_write(b, alen);
+}
+
+static int riic_send_start_cond(int restart)
+{
+	int ret;
+
+	if (restart)
+		riic_set_bit(pd, ICCR2_RS, RIIC_ICCR2);
+	else
+		riic_set_bit(pd, ICCR2_ST, RIIC_ICCR2);
+
+	ret = riic_wait_for_icsr2(pd, ICSR2_START);
+	if (ret < 0)
+		return ret;
+	riic_clear_bit(pd, ICSR2_START, RIIC_ICSR2);
+
+	return ret;
+}
+
+static int riic_send_stop_cond(void)
+{
+	int ret;
+
+	riic_clear_bit(pd, ICSR2_STOP | ICSR2_NACKF, RIIC_ICSR2);
+	riic_set_bit(pd, ICCR2_SP, RIIC_ICCR2);
+
+	ret = riic_wait_for_icsr2(pd, ICSR2_STOP);
+	if (ret < 0)
+		return ret;
+
+	riic_clear_bit(pd, ICSR2_STOP | ICSR2_NACKF, RIIC_ICSR2);
+	return ret;
+}
+
+static int riic_send_dev_addr(u8 chip, int read)
+{
+	u8 buf = ((chip << 1) | read);
+
+	return riic_i2c_raw_write(&buf, 1);
+}
+
+int i2c_read(u8 chip, u32 addr, int alen, u8 *buffer, int len)
+{
+	int ret;
+
+	ret = riic_check_busy();
+	if (ret < 0)
+		return ret;
+
+	ret = riic_send_start_cond(0);
+	if (ret < 0)
+		goto force_exit;
+
+	/* send addr */
+	if (alen > 0) {
+		ret = riic_send_dev_addr(chip, 0);
+		if (ret < 0)
+			goto force_exit;
+
+		ret = riic_send_mem_addr(addr, alen);
+		if (ret < 0)
+			goto force_exit;
+
+		ret = riic_wait_for_icsr2(pd, ICSR2_TEND);
+		if (ret < 0)
+			goto force_exit;
+
+		/* restart */
+		ret = riic_send_start_cond(1);
+		if (ret < 0)
+			goto force_exit;
+	}
+	ret = riic_send_dev_addr(chip, 1);
+	if (ret < 0)
+		goto force_exit;
+	ret = riic_wait_for_icsr2(pd, ICSR2_RDRF);
+	if (ret < 0)
+		goto force_exit;
+
+	ret = riic_check_nack_receive();
+	if (ret < 0)
+		goto force_exit;
+
+	/* receive data */
+	ret = riic_i2c_raw_read(buffer, len);
+
+force_exit:
+	riic_send_stop_cond();
+
+	return ret;
+}
+
+int i2c_write(u8 chip, u32 addr, int alen, u8 *buffer, int len)
+{
+	int ret;
+
+	ret = riic_check_busy();
+	if (ret < 0)
+		return ret;
+
+	ret = riic_send_start_cond(0);
+	if (ret < 0)
+		goto force_exit;
+
+	/* send addr */
+	ret = riic_send_dev_addr(chip, 0);
+	if (ret < 0)
+		goto force_exit;
+
+	if (alen > 0) {
+		ret = riic_send_mem_addr(addr, alen);
+		if (ret < 0)
+			goto force_exit;
+	}
+
+	/* transmit data */
+	ret = riic_i2c_raw_write(buffer, len);
+	if (ret < 0)
+		goto force_exit;
+	ret = riic_wait_for_icsr2(pd, ICSR2_TEND);
+
+force_exit:
+	riic_send_stop_cond();
+
+	return ret;
+}
+
+unsigned int i2c_get_bus_num(void)
+{
+	return current_bus;
+}
+
+int i2c_probe(u8 chip)
+{
+	return 0;
+}
+
+void i2c_init(int speed, int slaveaddr)
+{
+	int bus = 0;
+
+	riic_init_setting(&i_pd[0], CONFIG_SYS_I2C_SPEED);
+
+#ifdef CONFIG_I2C_MULTI_BUS
+	for (bus = 1; bus < CONFIG_SYS_MAX_I2C_BUS; bus++) {
+		riic_init_setting(&i_pd[bus], CONFIG_SYS_I2C_SPEED);
+	}
+#endif
+	return;
+}
diff --git a/drivers/mtd/spi/sf_internal.h b/drivers/mtd/spi/sf_internal.h
index 785f7a9..c6a7124 100644
--- a/drivers/mtd/spi/sf_internal.h
+++ b/drivers/mtd/spi/sf_internal.h
@@ -43,13 +43,17 @@ enum {
 	SST_BP		= 1 << 3,
 	SST_WP		= 1 << 4,
 	WR_QPP		= 1 << 5,
+	SP_4B		= 1 << 6,
 };
 
 #define SST_WR		(SST_BP | SST_WP)
 
-#define SPI_FLASH_3B_ADDR_LEN		3
+//#define SPI_FLASH_3B_ADDR_LEN		3
+//#define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_3B_ADDR_LEN)
+//#define SPI_FLASH_16MB_BOUN		0x1000000
+#define SPI_FLASH_3B_ADDR_LEN		4
 #define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_3B_ADDR_LEN)
-#define SPI_FLASH_16MB_BOUN		0x1000000
+#define SPI_FLASH_16MB_BOUN		0xc000000
 
 /* CFI Manufacture ID's */
 #define SPI_FLASH_CFI_MFR_SPANSION	0x01
@@ -62,10 +66,12 @@ enum {
 #define CMD_ERASE_32K			0x52
 #define CMD_ERASE_CHIP			0xc7
 #define CMD_ERASE_64K			0xd8
+#define CMD_ERASE_SECTOR_4B		0xdc
 
 /* Write commands */
 #define CMD_WRITE_STATUS		0x01
 #define CMD_PAGE_PROGRAM		0x02
+#define CMD_PAGE_PROGRAM_4B		0x12
 #define CMD_WRITE_DISABLE		0x04
 #define CMD_READ_STATUS		0x05
 #define CMD_QUAD_PAGE_PROGRAM		0x32
@@ -77,6 +83,7 @@ enum {
 /* Read commands */
 #define CMD_READ_ARRAY_SLOW		0x03
 #define CMD_READ_ARRAY_FAST		0x0b
+#define CMD_READ_ARRAY_FAST_4B		0x0c
 #define CMD_READ_DUAL_OUTPUT_FAST	0x3b
 #define CMD_READ_DUAL_IO_FAST		0xbb
 #define CMD_READ_QUAD_OUTPUT_FAST	0x6b
diff --git a/drivers/mtd/spi/sf_ops.c b/drivers/mtd/spi/sf_ops.c
index 34bc54e..993a962 100644
--- a/drivers/mtd/spi/sf_ops.c
+++ b/drivers/mtd/spi/sf_ops.c
@@ -25,6 +25,15 @@ static void spi_flash_addr(u32 addr, u8 *cmd)
 	cmd[3] = addr >> 0;
 }
 
+static void spi_flash_4b_addr(u32 addr, u8 *cmd)
+{
+	/* cmd[0] is actual command */
+	cmd[1] = addr >> 24;
+	cmd[2] = addr >> 16;
+	cmd[3] = addr >> 8;
+	cmd[4] = addr >> 0;
+}
+
 int spi_flash_cmd_read_status(struct spi_flash *flash, u8 *rs)
 {
 	int ret;
@@ -91,6 +100,49 @@ int spi_flash_cmd_write_config(struct spi_flash *flash, u8 wc)
 
 	return 0;
 }
+
+int spansion_4b_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	struct spi_slave *spi = flash->spi;
+	unsigned long timebase;
+	int ret;
+	u8 status;
+	u8 check_status = 0x0;
+	u8 poll_bit = STATUS_WIP;
+	u8 cmd = flash->poll_cmd;
+
+	if (cmd == CMD_FLAG_STATUS) {
+		poll_bit = STATUS_PEC;
+		check_status = poll_bit;
+	}
+
+	timebase = get_timer(0);
+	do {
+		WATCHDOG_RESET();
+
+		ret = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
+		if (ret)
+			return -1;
+
+		ret = spi_xfer(spi, sizeof(status) * 8, NULL, &status, SPI_XFER_END);
+		if (ret)
+			return -1;
+
+		if ((status & poll_bit) == check_status)
+			return 0;
+
+	} while (get_timer(timebase) < timeout);
+
+	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
+
+	if ((status & poll_bit) == check_status)
+		return 0;
+
+	/* Timed out */
+	debug("SF: time out!\n");
+	return -1;
+}
+
 #endif
 
 #ifdef CONFIG_SPI_FLASH_BAR
@@ -165,6 +217,12 @@ int spi_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout)
 	u8 poll_bit = STATUS_WIP;
 	u8 cmd = flash->poll_cmd;
 
+#if defined(CONFIG_SPI_FLASH_SPANSION)
+	if (flash->four_byte) {
+		return spansion_4b_flash_cmd_wait_ready(flash, timeout);
+	}
+#endif
+
 	if (cmd == CMD_FLAG_STATUS) {
 		poll_bit = STATUS_PEC;
 		check_status = poll_bit;
@@ -270,7 +328,10 @@ int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 		if (ret < 0)
 			return ret;
 #endif
-		spi_flash_addr(erase_addr, cmd);
+		if (flash->four_byte)
+			spi_flash_4b_addr(erase_addr, cmd);
+		else
+			spi_flash_addr(erase_addr, cmd);
 
 		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
 		      cmd[2], cmd[3], erase_addr);
@@ -299,10 +360,20 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 
 	page_size = flash->page_size;
 
+	/* If Dual Flash chips (flagged with cs=1), you program twice
+	   as much data at once. */
+	if( flash->spi->cs == 1)
+		page_size *= 2;
+
 	cmd[0] = flash->write_cmd;
 	for (actual = 0; actual < len; actual += chunk_len) {
 		write_addr = offset;
 
+		/* If Dual Flash chips (flagged with cs=1), you send 2 bytes
+		   for each 1 address, so adjust address each time */
+		if( flash->spi->cs == 1)
+			write_addr = offset - actual/2;
+
 #ifdef CONFIG_SF_DUAL_FLASH
 		if (flash->dual_flash > SF_SINGLE_FLASH)
 			spi_flash_dual_flash(flash, &write_addr);
@@ -319,7 +390,10 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 			chunk_len = min(chunk_len,
 					(size_t)flash->spi->max_write_size);
 
-		spi_flash_addr(write_addr, cmd);
+		if (flash->four_byte)
+			spi_flash_4b_addr(write_addr, cmd);
+		else
+			spi_flash_addr(write_addr, cmd);
 
 		debug("SF: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %zu\n",
 		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
@@ -409,7 +483,10 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		else
 			read_len = remain_len;
 
-		spi_flash_addr(read_addr, cmd);
+		if (flash->four_byte)
+			spi_flash_4b_addr(read_addr, cmd);
+		else
+			spi_flash_addr(read_addr, cmd);
 
 		ret = spi_flash_read_common(flash, cmd, cmdsz, data, read_len);
 		if (ret < 0) {
diff --git a/drivers/mtd/spi/sf_params.c b/drivers/mtd/spi/sf_params.c
index c12e8c6..3f56691 100644
--- a/drivers/mtd/spi/sf_params.c
+++ b/drivers/mtd/spi/sf_params.c
@@ -61,9 +61,9 @@ const struct spi_flash_params spi_flash_params_table[] = {
 	{"S25FL128S_64K",  0x012018, 0x4d01,    64 * 1024,   256, RD_FULL,		     WR_QPP},
 	{"S25FL256S_256K", 0x010219, 0x4d00,   256 * 1024,   128, RD_FULL,		     WR_QPP},
 	{"S25FL256S_64K",  0x010219, 0x4d01,	64 * 1024,   512, RD_FULL,		     WR_QPP},
-	{"S25FL512S_256K", 0x010220, 0x4d00,   256 * 1024,   256, RD_FULL,		     WR_QPP},
-	{"S25FL512S_64K",  0x010220, 0x4d01,    64 * 1024,  1024, RD_FULL,		     WR_QPP},
-	{"S25FL512S_512K", 0x010220, 0x4f00,   256 * 1024,   256, RD_FULL,		     WR_QPP},
+	{"S25FL512S_256K", 0x010220, 0x4d00,   256 * 1024,   256, RD_FULL,	     SP_4B | WR_QPP},
+	{"S25FL512S_64K",  0x010220, 0x4d01,    64 * 1024,  1024, RD_FULL,	     SP_4B | WR_QPP},
+	{"S25FL512S_512K", 0x010220, 0x4f00,   256 * 1024,   256, RD_FULL,	     SP_4B | WR_QPP},
 #endif
 #ifdef CONFIG_SPI_FLASH_STMICRO		/* STMICRO */
 	{"M25P10",	   0x202011, 0x0,	32 * 1024,     4, RD_NORM,			  0},
diff --git a/drivers/mtd/spi/sf_probe.c b/drivers/mtd/spi/sf_probe.c
index ce9987f..b93d661 100644
--- a/drivers/mtd/spi/sf_probe.c
+++ b/drivers/mtd/spi/sf_probe.c
@@ -131,6 +131,7 @@ static int spi_flash_validate_params(struct spi_slave *spi, u8 *idcode,
 	flash->name = params->name;
 	flash->memory_map = spi->memory_map;
 	flash->dual_flash = flash->spi->option;
+	flash->four_byte = (params->flags & SP_4B)?1:0;
 
 	/* Assign spi_flash ops */
 #ifndef CONFIG_DM_SPI_FLASH
@@ -178,6 +179,9 @@ static int spi_flash_validate_params(struct spi_slave *spi, u8 *idcode,
 	} else if (params->flags & SECT_32K) {
 		flash->erase_cmd = CMD_ERASE_32K;
 		flash->erase_size = 32768 << flash->shift;
+	} else if (params->flags & SP_4B) {
+		flash->erase_cmd = CMD_ERASE_SECTOR_4B;
+		flash->erase_size = flash->sector_size;
 	} else {
 		flash->erase_cmd = CMD_ERASE_64K;
 		flash->erase_size = flash->sector_size;
@@ -188,6 +192,8 @@ static int spi_flash_validate_params(struct spi_slave *spi, u8 *idcode,
 	if (cmd) {
 		cmd = spi_read_cmds_array[cmd - 1];
 		flash->read_cmd = cmd;
+	} else if (params->flags & SP_4B) {
+		flash->read_cmd = CMD_READ_ARRAY_FAST_4B;
 	} else {
 		/* Go for default supported read cmd */
 		flash->read_cmd = CMD_READ_ARRAY_FAST;
@@ -196,6 +202,8 @@ static int spi_flash_validate_params(struct spi_slave *spi, u8 *idcode,
 	/* Not require to look for fastest only two write cmds yet */
 	if (params->flags & WR_QPP && flash->spi->op_mode_tx & SPI_OPM_TX_QPP)
 		flash->write_cmd = CMD_QUAD_PAGE_PROGRAM;
+	else if (params->flags & SP_4B)
+		flash->write_cmd = CMD_PAGE_PROGRAM_4B;
 	else
 		/* Go for default supported write cmd */
 		flash->write_cmd = CMD_PAGE_PROGRAM;
@@ -385,10 +393,11 @@ int spi_flash_probe_slave(struct spi_slave *spi, struct spi_flash *flash)
 	puts("\n");
 #endif
 #ifndef CONFIG_SPI_FLASH_BAR
-	if (((flash->dual_flash == SF_SINGLE_FLASH) &&
+	if (!(flash->four_byte) &&
+	    (((flash->dual_flash == SF_SINGLE_FLASH) &&
 	     (flash->size > SPI_FLASH_16MB_BOUN)) ||
 	     ((flash->dual_flash > SF_SINGLE_FLASH) &&
-	     (flash->size > SPI_FLASH_16MB_BOUN << 1))) {
+	     (flash->size > SPI_FLASH_16MB_BOUN << 1)))) {
 		puts("SF: Warning - Only lower 16MiB accessible,");
 		puts(" Full access #define CONFIG_SPI_FLASH_BAR\n");
 	}
diff --git a/drivers/net/sh_eth.c b/drivers/net/sh_eth.c
index 4bf493e..497bc31 100644
--- a/drivers/net/sh_eth.c
+++ b/drivers/net/sh_eth.c
@@ -405,10 +405,10 @@ static int sh_eth_config(struct sh_eth_dev *eth, bd_t *bd)
 	sh_eth_write(eth, val, MALR);
 
 	sh_eth_write(eth, RFLR_RFL_MIN, RFLR);
-#if defined(SH_ETH_TYPE_GETHER)
+#if defined(SH_ETH_TYPE_GETHER) || defined(SH_ETH_TYPE_RZ)
+#if !defined(CONFIG_CPU_RZA1)
 	sh_eth_write(eth, 0, PIPR);
 #endif
-#if defined(SH_ETH_TYPE_GETHER) || defined(SH_ETH_TYPE_RZ)
 	sh_eth_write(eth, APR_AP, APR);
 	sh_eth_write(eth, MPR_MP, MPR);
 	sh_eth_write(eth, TPAUSER_TPAUSE, TPAUSER);
@@ -455,7 +455,7 @@ static int sh_eth_config(struct sh_eth_dev *eth, bd_t *bd)
 		sh_eth_write(eth, 0, RTRATE);
 #endif
 	}
-#if defined(SH_ETH_TYPE_GETHER)
+#if defined(SH_ETH_TYPE_GETHER) && !defined(CONFIG_CPU_RZA1)
 	else if (phy->speed == 1000) {
 		printf(SHETHER_NAME ": 1000Base/");
 		sh_eth_write(eth, GECMR_1000B, GECMR);
@@ -478,6 +478,22 @@ err_phy_cfg:
 	return ret;
 }
 
+static int sh_eth_write_hwaddr(struct eth_device *dev)
+{
+	u32 val;
+	struct sh_eth_dev *eth = dev->priv;
+	
+	/* Set Mac address */
+	val = dev->enetaddr[0] << 24 | dev->enetaddr[1] << 16 |
+	    dev->enetaddr[2] << 8 | dev->enetaddr[3];
+	sh_eth_write(eth, val, MAHR);
+
+	val = dev->enetaddr[4] << 8 | dev->enetaddr[5];
+	sh_eth_write(eth, val, MALR);
+	
+	return 0;
+}
+
 static void sh_eth_start(struct sh_eth_dev *eth)
 {
 	/*
@@ -558,6 +574,7 @@ int sh_eth_initialize(bd_t *bd)
 	dev->halt = sh_eth_halt;
 	dev->send = sh_eth_send;
 	dev->recv = sh_eth_recv;
+	dev->write_hwaddr = sh_eth_write_hwaddr;
 	eth->port_info[eth->port].dev = dev;
 
 	sprintf(dev->name, SHETHER_NAME);
diff --git a/drivers/net/sh_eth.h b/drivers/net/sh_eth.h
index 5cb520c..f6287eb 100644
--- a/drivers/net/sh_eth.h
+++ b/drivers/net/sh_eth.h
@@ -1,7 +1,7 @@
 /*
  * sh_eth.h - Driver for Renesas SuperH ethernet controler.
  *
- * Copyright (C) 2008 - 2012 Renesas Solutions Corp.
+ * Copyright (C) 2008-2013 Renesas Solutions Corp.
  * Copyright (c) 2008 - 2012 Nobuhiro Iwamatsu
  * Copyright (c) 2007 Carlos Munoz <carlos@kenati.com>
  *
@@ -25,7 +25,9 @@
 #define ADDR_TO_PHY(addr)	((int)(addr) & ~0xe0000000)
 #endif
 #elif defined(CONFIG_ARM)
+#undef inl
 #define inl		readl
+#undef outl
 #define outl	writel
 #define ADDR_TO_PHY(addr)	((int)(addr))
 #define ADDR_TO_P2(addr)	(addr)
@@ -360,6 +362,8 @@ static const u16 sh_eth_offset_fast_sh4[SH_ETH_MAX_REGISTER_OFFSET] = {
 #define BASE_IO_ADDR	0xEE700200
 #elif defined(CONFIG_R7S72100)
 #define SH_ETH_TYPE_RZ
+#elif defined(CONFIG_CPU_RZA1)
+#define SH_ETH_TYPE_GETHER
 #define BASE_IO_ADDR	0xE8203000
 #endif
 
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index fdcbc00..4913d0b 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -1,6 +1,7 @@
 #
 # (C) Copyright 2001-2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+# Copyright (C) 2013 Renesas Solutions Corp.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
@@ -50,3 +51,4 @@ obj-$(CONFIG_RTC_RV3029) += rv3029.o
 obj-$(CONFIG_RTC_RX8025) += rx8025.o
 obj-$(CONFIG_RTC_S3C24X0) += s3c24x0_rtc.o
 obj-$(CONFIG_RTC_X1205) += x1205.o
+obj-$(CONFIG_RTC_RZA1) += rza1_rtc.o
diff --git a/drivers/rtc/rza1_rtc.c b/drivers/rtc/rza1_rtc.c
new file mode 100644
index 0000000..3fe43fd
--- /dev/null
+++ b/drivers/rtc/rza1_rtc.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2008-2014 Renesas Solutions Corp.
+ *
+ * Based on linux/drivers/rtc/rtc-sh.c
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <rtc.h>
+
+/*
+ * RZA1H RTC registers layout
+ */
+#define RTC_BASE	CONFIG_RTC_RZA1_BASE_ADDR
+
+#define R64CNT		(RTC_BASE + 0x00)
+#define RSECCNT		(RTC_BASE + 0x02)
+#define RMINCNT		(RTC_BASE + 0x04)
+#define RHRCNT		(RTC_BASE + 0x06)
+#define RWKCNT		(RTC_BASE + 0x08)
+#define RDAYCNT		(RTC_BASE + 0x0A)
+#define RMONCNT		(RTC_BASE + 0x0C)
+#define RYRCNT		(RTC_BASE + 0x0E)
+#define RSECAR		(RTC_BASE + 0x10)
+#define RMINAR		(RTC_BASE + 0x12)
+#define RHRAR		(RTC_BASE + 0x14)
+#define RWKAR		(RTC_BASE + 0x16)
+#define RDAYAR		(RTC_BASE + 0x18)
+#define RMONAR		(RTC_BASE + 0x1A)
+#define RYRAR		(RTC_BASE + 0x20)
+#define RCR1		(RTC_BASE + 0x1C)
+#define RCR2		(RTC_BASE + 0x1E)
+#define RCR3		(RTC_BASE + 0x24)
+#define RCR5		(RTC_BASE + 0x26)
+#define RFRH		(RTC_BASE + 0x2A)
+#define RFRL		(RTC_BASE + 0x2C)
+
+/* RCR1 Bits */
+#define RCR1_CF		0x80
+#define RCR1_CIE	0x10
+#define RCR1_AIE	0x08
+
+/* RCR2 Bits */
+#define RCR2_RTCEN	0x08
+#define RCR2_RESET	0x02
+#define RCR2_START	0x01
+
+/* RCR5 Bits */
+#define RCR5_RCKSEL00	0x00	/* select RTC_X1(32.768KHz) */
+#define RCR5_RCKSEL01	0x01	/* select EXTAL */
+#define RCR5_RCKSEL10	0x02	/* select RTC_X3 */
+
+static u8 rtc_read8(unsigned int addr)
+{
+	u8 val = *(volatile u8 *)addr;
+	return val;
+}
+
+static u16 rtc_read16(unsigned int addr)
+{
+	u16 val = *(volatile u16 *)addr;
+	return val;
+}
+
+static void rtc_write8(unsigned int addr, u8 val)
+{
+	*(volatile u8 *)addr = val;
+}
+
+static void rtc_write16(unsigned int addr, u16 val)
+{
+	*(volatile u16 *)addr = val;
+}
+
+int rtc_get(struct rtc_time *tmp)
+{
+	u8 cf_bit;
+
+	do {
+		u8 t;
+		u16 yr, yr100;
+
+		t = rtc_read8(RCR1);
+		t &= ~RCR1_CF;	/* clear CF bit */
+		rtc_write8(RCR1, t);
+
+		tmp->tm_sec = bcd2bin(rtc_read8(RSECCNT));
+		tmp->tm_min = bcd2bin(rtc_read8(RMINCNT));
+		tmp->tm_hour = bcd2bin(rtc_read8(RHRCNT));
+		tmp->tm_mday = bcd2bin(rtc_read8(RDAYCNT));
+		tmp->tm_mon = bcd2bin(rtc_read8(RMONCNT));
+		tmp->tm_wday = bcd2bin(rtc_read8(RWKCNT));
+
+		yr = rtc_read16(RYRCNT);
+		yr100 = bcd2bin(yr >> 8);
+		yr &= 0xff;
+		tmp->tm_year = (yr100 * 100 + bcd2bin(yr)) - 1900;
+
+		cf_bit = rtc_read8(RCR1) & RCR1_CF;
+
+	} while (cf_bit != 0);
+
+	/* to unify both the u-boot and the kernel in rtc system */
+	tmp->tm_year += 1900;
+
+	return 0;
+}
+
+int rtc_set(struct rtc_time *tmp)
+{
+	u8 t;
+	u16 year;
+
+	/* stop and reset */
+	t = rtc_read8(RCR2);
+	t |= RCR2_RESET;
+	t &= ~RCR2_START;
+	rtc_write8(RCR2, t);
+
+	rtc_write8(RMONCNT, bin2bcd(tmp->tm_mon));
+	rtc_write8(RWKCNT, bin2bcd(tmp->tm_wday));
+	rtc_write8(RDAYCNT, bin2bcd(tmp->tm_mday));
+	rtc_write8(RHRCNT, bin2bcd(tmp->tm_hour));
+	rtc_write8(RMINCNT, bin2bcd(tmp->tm_min));
+	rtc_write8(RSECCNT, bin2bcd(tmp->tm_sec));
+
+	year = (bin2bcd((tmp->tm_year) / 100) << 8) |
+		bin2bcd((tmp->tm_year) % 100);
+
+	rtc_write16(RYRCNT, year);
+
+	/* start */
+	t = rtc_read8(RCR2);
+	t |= RCR2_RTCEN | RCR2_START;
+	rtc_write8(RCR2, t);
+
+	return 0;
+}
+
+void rtc_reset(void)
+{
+	u8 t;
+
+	t = rtc_read8(RCR1);
+	t &= ~(RCR1_CIE | RCR1_AIE);	/* disable interrupts */
+	rtc_write8(RCR1, t);
+
+	rtc_write8(RCR5, RCR5_RCKSEL00);	/* set source clock */
+
+	/* start */
+	t = rtc_read8(RCR2);
+	t |= RCR2_RTCEN | RCR2_START;
+	rtc_write8(RCR2, t);
+}
diff --git a/drivers/serial/serial_sh.c b/drivers/serial/serial_sh.c
index 7c1f271..f948830 100644
--- a/drivers/serial/serial_sh.c
+++ b/drivers/serial/serial_sh.c
@@ -69,6 +69,9 @@ static int sh_serial_init(void)
 	sci_out(&sh_sci, SCFCR, SCFCR_RFRST|SCFCR_TFRST);
 	sci_in(&sh_sci, SCFCR);
 	sci_out(&sh_sci, SCFCR, 0);
+#ifdef CONFIG_CPU_RZA1
+	sci_out(&sh_sci, SCSPTR, 0x0053);
+#endif
 
 	serial_setbrg();
 	return 0;
diff --git a/drivers/serial/serial_sh.h b/drivers/serial/serial_sh.h
index ef88c8f..2c875ad 100644
--- a/drivers/serial/serial_sh.h
+++ b/drivers/serial/serial_sh.h
@@ -203,7 +203,7 @@ struct uart_port {
 #  define SCSPTR7 0xfffeB820 /* 16 bit SCIF */
 # endif
 # define SCSCR_INIT(port)	0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
-#elif defined(CONFIG_CPU_SH7269)
+#elif defined(CONFIG_CPU_SH7269) || defined(CONFIG_CPU_RZA1)
 # define SCSPTR0 0xe8007020 /* 16 bit SCIF */
 # define SCSPTR1 0xe8007820 /* 16 bit SCIF */
 # define SCSPTR2 0xe8008020 /* 16 bit SCIF */
@@ -213,6 +213,7 @@ struct uart_port {
 # define SCSPTR6 0xe800a020 /* 16 bit SCIF */
 # define SCSPTR7 0xe800a820 /* 16 bit SCIF */
 # define SCSCR_INIT(port)	0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
+# define SCIF_ORER 0x0001  /* overrun error bit */
 #elif defined(CONFIG_CPU_SH7619)
 # define SCSPTR0 0xf8400020 /* 16 bit SCIF */
 # define SCSPTR1 0xf8410020 /* 16 bit SCIF */
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index edbd520..7a9d71c 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -1,6 +1,7 @@
 #
 # (C) Copyright 2000-2007
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+# Copyright (C) 2013 Renesas Solutions Corp.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
@@ -38,6 +39,7 @@ obj-$(CONFIG_MXC_SPI) += mxc_spi.o
 obj-$(CONFIG_MXS_SPI) += mxs_spi.o
 obj-$(CONFIG_OC_TINY_SPI) += oc_tiny_spi.o
 obj-$(CONFIG_OMAP3_SPI) += omap3_spi.o
+obj-$(CONFIG_RZ_SPI) += rz_spi.o
 obj-$(CONFIG_SANDBOX_SPI) += sandbox_spi.o
 obj-$(CONFIG_SH_SPI) += sh_spi.o
 obj-$(CONFIG_SH_QSPI) += sh_qspi.o
diff --git a/drivers/spi/rz_spi.c b/drivers/spi/rz_spi.c
new file mode 100644
index 0000000..e895bfe
--- /dev/null
+++ b/drivers/spi/rz_spi.c
@@ -0,0 +1,933 @@
+/*
+ * RZ SPI driver
+ * /drivers/met/spi/rz_spi.c
+ *
+ * Copyright (C) 2013 NEC Corp.
+ *
+ * Based on /drivers/met/spi/sh_spi.c
+ *
+ * Copyright (C) 2011-2014 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+//#define DEBUG
+//#define DEBUG_DETAILED /* Print out all TX and RX data */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <asm/io.h>
+#include "rz_spi.h"
+
+#define	WAIT_HZ			1000	// TEND time out rate.
+#define	CMD_READ_ARRAY_FAST	0x0b	// EXT-READ dummy-cmd.
+
+static int qspi_set_config_register(struct stRzSpi*);
+static u32 qspi_calc_spbcr(struct stRzSpi* pstRzSpi);
+static int qspi_set_ope_mode(struct stRzSpi*,int);
+static int qspi_wait_for_tend(struct stRzSpi*);
+static void qspi_set_busio(struct stRzSpi*,u8);
+static int qspi_send_cmd(struct stRzSpi*,const u8*,unsigned int,int);
+static int qspi_send_data(struct stRzSpi*,const u8*,unsigned int);
+static int qspi_recv_data(struct stRzSpi*,u8*,unsigned int);
+
+/**
+ *
+ */
+struct spi_slave* spi_setup_slave(unsigned int unBus, unsigned int unCs,
+	unsigned int unMaxHz, unsigned int unMode)
+{
+	struct stRzSpi* pstRzSpi;
+
+	debug("call %s: bus(%d) cs(%0d) maxhz(%d) mode(%d))\n",
+		__func__, unBus, unCs, unMaxHz, unMode);
+
+	pstRzSpi = spi_alloc_slave(struct stRzSpi, unBus, unCs);
+	if(pstRzSpi == NULL){
+		printf("%s: malloc error.\n", __func__);
+		return NULL;
+	}
+
+	pstRzSpi->slave.bus		= unBus;
+	pstRzSpi->slave.cs		= unCs;
+	pstRzSpi->pRegBase		= (void*)CONFIG_RZA1_BASE_QSPI0;
+	pstRzSpi->u8BitsPerWord		= 8;
+	pstRzSpi->u32MaxSpeedHz		= unMaxHz;
+	pstRzSpi->unMode		= unMode;
+	pstRzSpi->u32DataBitw		= BITW_1BIT;
+	pstRzSpi->u32DummyCycle		= 0;
+
+	/* Save if we were usign 1 or 2 chips in data read mode
+	   (so we can put it back when we're done) */
+	if( qspi_read32(pstRzSpi, QSPI_CMNCR) & BSZ_DUAL )
+		pstRzSpi->data_read_dual = 1;
+	else
+		pstRzSpi->data_read_dual = 0;
+
+	if( pstRzSpi->slave.cs )
+		printf("SF: Dual SPI mode\n");
+
+	if (pstRzSpi->u8BitsPerWord == 0)
+		pstRzSpi->u8BitsPerWord = 8;
+
+	qspi_set_config_register(pstRzSpi);
+
+	return &pstRzSpi->slave;
+}
+
+/**
+ *
+ */
+void spi_free_slave(struct spi_slave* pstSpiSlave)
+{
+	debug("call %s: bus(%d) cs(%d)\n",
+	__func__, pstSpiSlave->bus, pstSpiSlave->cs);
+
+	free(to_rz_spi(pstSpiSlave));
+}
+
+/**
+ *
+ */
+int spi_claim_bus(struct spi_slave* pstSpiSlave)
+{
+	debug("call %s: bus(%d) cs(%d)\n",
+		__func__, pstSpiSlave->bus, pstSpiSlave->cs);
+	return 0;
+}
+
+/**
+ *
+ */
+void spi_release_bus(struct spi_slave* pstSpiSlave)
+{
+	debug("call %s: bus(%d) cs(%d)\n",
+		__func__, pstSpiSlave->bus, pstSpiSlave->cs);
+}
+
+/**
+ *
+ */
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	debug("call %s: bus(%d) cs(%d)\n", __func__, bus, cs);
+
+	/* This driver supports "bus = 0" and "cs = 0" only. */
+//	if (!bus && !cs)
+
+	// use cs=1 to mean we want to use 2 spi flashes
+	if (!bus && (cs ==0 || cs==1) )
+		return 1;
+	else
+		return 0;
+}
+
+/**
+ *
+ */
+void spi_cs_activate(struct spi_slave* pstSpiSlave)
+{
+	debug("call %s: bus(%d) cs(%d)\n",
+		__func__, pstSpiSlave->bus, pstSpiSlave->cs);
+}
+
+/**
+ *
+ */
+void spi_cs_deactivate(struct spi_slave* pstSpiSlave)
+{
+	debug("call %s: bus(%d) cs(%d)\n",
+		__func__, pstSpiSlave->bus, pstSpiSlave->cs);
+}
+
+/**
+ *
+ */
+int spi_xfer(struct spi_slave* pstSpiSlave, unsigned int bitlen,
+	const void* dout, void* din, unsigned long flags)
+{
+	struct stRzSpi *pstRzSpi	= to_rz_spi(pstSpiSlave);
+	const unsigned char* pbTxData	= (const unsigned char*)dout;
+	unsigned char* pbRxData		= (unsigned char*)din;
+	unsigned int len		= (bitlen + 7) / 8;
+	int ret				= 0;
+
+	debug("call %s: bus(%d) cs(%d) bitlen(%d) dout=(0x%08x) din=(0x%08x), flag=(%d)\n",
+		__func__, pstSpiSlave->bus, pstSpiSlave->cs,
+		bitlen, (u32)dout, (u32)din, (u32)flags);
+
+	if (qspi_wait_for_tend(pstRzSpi) < 0) {
+		printf("%s: error waiting for end of last transfer\n", __func__);
+		return -1;
+	}
+
+	if(flags & SPI_XFER_BEGIN){
+		ret = qspi_set_ope_mode(pstRzSpi, SPI_MODE);
+		if(ret){
+			printf("%s: Unknown SPI mode\n", __func__);
+			return 0;
+		}
+		if ((ret = qspi_wait_for_tend(pstRzSpi)) < 0) {
+			printf("%s: error wait for poll (%d)\n", __func__, ret);
+			return 0;
+		}
+	}
+
+	if(pbTxData){
+		if(flags & SPI_XFER_BEGIN){
+			qspi_set_busio(pstRzSpi, *pbTxData);
+			pstRzSpi->this_cmd = *pbTxData;
+			ret = qspi_send_cmd(pstRzSpi, pbTxData, len,
+				(flags & SPI_XFER_END) ? 0 : 1);
+			if(ret < 0){
+				printf("%s: Error Send Command (%x)\n", __func__, ret);
+			}else{
+#ifdef DEBUG
+				int nIndex;
+				debug("send cmd : ");
+				for(nIndex = 0; nIndex < len; nIndex++){
+					debug(" %02x", *(pbTxData + nIndex));
+				}
+				if(flags & SPI_XFER_END) debug(" <END>");
+				debug("\n");
+#endif
+			}
+		}else{
+			ret = qspi_send_data(pstRzSpi, pbTxData, len);
+			if(ret < 0){
+				printf("%s: Error Send Data (%x)\n", __func__, ret);
+			}else{
+#ifdef DEBUG_DETAILED
+				int nIndex;
+				debug("send dat : ");
+				for(nIndex = 0; nIndex < len; nIndex++){
+					debug(" %02x", *(pbTxData + nIndex));
+					if(nIndex > 100) {
+						printf("\n\tStopped after displaying 100 bytes\n");
+						break;
+					}
+
+				}
+				if(flags & SPI_XFER_END) debug(" <END>");
+				debug("\n");
+#endif
+			}
+		}
+	}
+	if(ret == 0 && pbRxData){
+
+		ret = qspi_recv_data(pstRzSpi, pbRxData, len);
+		if(ret < 0){
+			printf("%s: Error Recv Data (%x)\n", __func__, ret);
+		}else{
+#ifdef	DEBUG_DETAILED
+			int nIndex;
+			debug("recv : ");
+			for(nIndex = 0; nIndex < len; nIndex++){
+				debug(" %02x", *(pbRxData + nIndex));
+				if(nIndex > 100) {
+					printf("\n\tStopped after displaying 100 bytes\n");
+					break;
+				}
+			}
+			if(flags & SPI_XFER_END) debug(" <END>");
+			debug("\n");
+#endif
+		}
+	}
+
+	if(flags & SPI_XFER_END){
+		ret = qspi_set_ope_mode(pstRzSpi, READ_MODE);
+		if(ret){
+			printf("%s: Unknown SPI mode\n", __func__);
+		}
+		if ((ret = qspi_wait_for_tend(pstRzSpi)) < 0) {
+			printf("%s: error wait for poll (%d)\n", __func__, ret);
+		}
+	}
+
+	return ret;
+}
+
+/**
+ *
+ */
+static inline int qspi_is_ssl_negated(struct stRzSpi* pstRzSpi)
+{
+	return !(qspi_read32(pstRzSpi, QSPI_CMNSR) & CMNSR_SSLF);
+}
+
+
+/**
+ *
+ */
+static int qspi_set_config_register(struct stRzSpi* pstRzSpi)
+{
+	u32 value;
+
+	debug("call %s:\n", __func__);
+
+	/* Check if SSL still low */
+	if (!qspi_is_ssl_negated(pstRzSpi)){
+		/* Clear the SSL from the last data read operation */
+		qspi_write32(pstRzSpi, qspi_read32(pstRzSpi,QSPI_DRCR) | DRCR_SSLN,
+			QSPI_DRCR);
+
+		/* Disable Read & Write */
+		qspi_write32(pstRzSpi, 0, QSPI_SMCR);	
+	}
+
+	/* NOTES: Set swap (SFDE) so the order of bytes D0 to D7 in the SPI RX/TX FIFO are always in the
+	   same order (LSB=D0, MSB=D7) regardless if the SPI did a byte,word, dwrod fetch */
+	value = 
+		CMNCR_MD|	       		/* spi mode */
+		CMNCR_SFDE|			/* swap */
+		CMNCR_MOIIO3(OUT_HIZ)|
+		CMNCR_MOIIO2(OUT_HIZ)|
+		CMNCR_MOIIO1(OUT_HIZ)|
+		CMNCR_MOIIO0(OUT_HIZ)|
+		CMNCR_IO3FV(OUT_HIZ)|
+		CMNCR_IO2FV(OUT_HIZ)|
+		CMNCR_IO0FV(OUT_HIZ)|
+		//CMNCR_CPHAR|CMNCR_CPHAT|CMNCR_CPOL| /* spi mode3 */
+		CMNCR_CPHAR|
+		CMNCR_BSZ(BSZ_SINGLE);
+
+	/* dual memory? */
+	if (pstRzSpi->slave.cs)
+		value |= CMNCR_BSZ(BSZ_DUAL);	/* s-flash x 2 */
+
+	/* set common */
+	qspi_write32(pstRzSpi, value, QSPI_CMNCR);
+
+	/* flush read-cache */
+	qspi_write32(pstRzSpi, qspi_read32(pstRzSpi, QSPI_DRCR) | DRCR_RCF,
+		QSPI_DRCR);
+
+	/* setup delay */
+	qspi_write32(pstRzSpi,
+		SSLDR_SPNDL(SPBCLK_1_0)|	/* next access delay */
+		SSLDR_SLNDL(SPBCLK_1_0)|	/* SPBSSL negate delay */
+		SSLDR_SCKDL(SPBCLK_1_0),	/* clock delay */
+		QSPI_SSLDR);
+
+	/* sets transfer bit rate */
+	qspi_write32(pstRzSpi, qspi_calc_spbcr(pstRzSpi), QSPI_SPBCR);
+
+	return 0;
+}
+
+/**
+ *
+ */
+static u32 qspi_calc_spbcr(struct stRzSpi* pstRzSpi)
+{
+	u32 n = 1; /* FIX for clk / 2 */
+	u32 N = 0;
+#if 0
+	u32 hz;
+	/*
+	 * bitrate = clk / ( 2 x n x 2 ^ N)
+	 * n=SPBCR_SPBR[7:0](1 ... 255), N=SPBCR_BRDV[1:0]
+	 */
+	hz = QSPI_BASE_CLK / pstRzSpi->u32MaxSpeedHz;
+	if (hz >= (1 << 5))  { N = 3;}
+	else if (!(hz & 1))  { N = 0;}
+	else if (!(hz & 3))  { N = 1;}
+	else if (!(hz & 7))  { N = 2;}
+	else if (!(hz & 15)) { N = 3;}
+	n = hz / (1 << N);
+	n = n > 255 ? 255 : n;
+#endif
+	return SPBCR_SPBR(n)|SPBCR_BRDV(N);
+}
+
+/**
+ *
+ */
+static int qspi_set_ope_mode(struct stRzSpi* pstRzSpi, int mode)
+{
+	int ret;
+	u32 cmncr = qspi_read32(pstRzSpi, QSPI_CMNCR);
+
+	debug("call %s: mode=%d\n", __func__, mode);
+
+	if((mode == SPI_MODE) && (cmncr & CMNCR_MD)){
+		return 0;
+	}
+	if((mode != SPI_MODE) && !(cmncr & CMNCR_MD)){
+		return 0;
+	}
+
+	if(!qspi_is_ssl_negated(pstRzSpi)){
+		/* SSL still low from last transfer */
+		/* Disable Read & Write */
+		qspi_write32(pstRzSpi, 0, QSPI_SMCR);	
+		/* Clear the SSL from the last data read operation */
+		qspi_write32(pstRzSpi, qspi_read32(pstRzSpi,QSPI_DRCR) | DRCR_SSLN,
+			QSPI_DRCR);
+	}
+
+	ret = qspi_wait_for_tend(pstRzSpi);
+	if(ret){
+		printf("%s: hw busy\n", __func__);
+		return ret;
+	}
+
+	if(mode == SPI_MODE){
+		// SPI mode.
+		cmncr |= CMNCR_MD;
+
+		/* cs=0 is single chip, cs=1 is dual chip */
+		if( pstRzSpi->slave.cs )
+			cmncr |= BSZ_DUAL;
+		else
+			cmncr &= ~BSZ_DUAL;
+
+		qspi_write32(pstRzSpi, cmncr, QSPI_CMNCR);
+
+	}else{
+
+		/* End the transfer by putting SSL low */
+		qspi_write32(pstRzSpi, DRCR_SSLE, QSPI_DRCR);
+
+		// EXT-READ mode.
+		cmncr &= ~CMNCR_MD;
+
+		// put back in same mode (1 or 2 chips) as was originally
+		if( pstRzSpi->data_read_dual )
+			cmncr |= BSZ_DUAL;
+		else
+			cmncr &= ~BSZ_DUAL;
+
+		qspi_write32(pstRzSpi, cmncr, QSPI_CMNCR);
+#if 0
+
+//Dont touch anything else...just leave it...
+		qspi_write32(pstRzSpi, DRCR_SSLE, QSPI_DRCR);
+		ret = qspi_wait_for_tend(pstRzSpi);
+		if(ret){
+			printf("%s: hw busy\n", __func__);
+			return ret;
+		}else{
+			u32 u32DRENR, u32DRCMR, u32DROPR;
+
+			u32DRENR = u32DRCMR = u32DROPR = 0;
+			// Command
+#if 1
+			u32DRCMR |= DRCMR_CMD(CMD_4FAST_READ);
+#else
+			u32DRCMR |= DRCMR_CMD(CMD_READ_ARRAY_FAST);
+#endif
+			u32DRENR |= DRENR_CDB(BITW_1BIT);
+			u32DRENR |= DRENR_CDE;
+			// Option
+			u32DRCMR |= DRCMR_OCMD(0);
+			u32DRENR |= DRENR_OCDB(BITW_1BIT);
+			// Address
+			u32DRENR |= DRENR_ADB(BITW_1BIT);
+			u32DRENR |= DRENR_ADE(ADE_31_0);
+			// Option Data
+			u32DROPR |= DROPR_OPD3(0x00);
+			u32DROPR |= DROPR_OPD2(0x00);
+			u32DROPR |= DROPR_OPD1(0x00);
+			u32DROPR |= DROPR_OPD0(0x00);
+			u32DRENR |= DRENR_OPDB(BITW_1BIT);
+			u32DRENR |= DRENR_OPDE(OPDE_3);
+			// Data
+			u32DRENR |= DRENR_DRDB(BITW_1BIT);
+
+			qspi_write32(pstRzSpi, u32DRCMR, QSPI_DRCMR);
+			qspi_write32(pstRzSpi, u32DROPR, QSPI_DROPR);
+			qspi_write32(pstRzSpi, u32DRENR, QSPI_DRENR);
+		}
+#endif
+
+	}
+
+	return 0;
+}
+
+/**
+ *
+ */
+static int qspi_wait_for_tend(struct stRzSpi* pstRzSpi)
+{
+	unsigned long timebase;
+
+	timebase = get_timer(0);
+	do{
+		if(qspi_read32(pstRzSpi, QSPI_CMNSR) & CMNSR_TEND){
+			break;
+		}
+	}while(get_timer(timebase) < WAIT_HZ);
+
+	if (!(qspi_read32(pstRzSpi, QSPI_CMNSR) & CMNSR_TEND)){
+		printf("%s: wait timeout\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ *
+ */
+static void qspi_set_busio(struct stRzSpi* pstRzSpi,u8 cmd)
+{
+	u32 data_bitw;
+	u32 dmy_cycle;
+
+	debug("call %s:\n", __func__);
+
+	switch (cmd) {
+	case CMD_FAST_READ:	/* 0x0b Fast Read (3-byte address) */
+	case CMD_4FAST_READ:	/* 0x0b Fast Read (3-byte address) */
+		dmy_cycle = 8;
+		data_bitw = BITW_1BIT;
+		break;
+	case CMD_QOR:		/* 0x6b Read Quad Out (3-byte address) */
+		dmy_cycle = 8;
+		data_bitw = BITW_4BIT;
+		break;
+	case CMD_QPP:		/* 0x32 Quad Page Program (3-byte address) */
+		dmy_cycle = 0;
+		data_bitw = BITW_4BIT;
+		break;
+	default:
+		data_bitw = BITW_1BIT;
+		dmy_cycle = 0;
+		break;
+	}
+
+	pstRzSpi->u32DataBitw	= data_bitw;
+	pstRzSpi->u32DummyCycle	= dmy_cycle;
+
+	return;
+}
+
+/**
+ *
+ */
+static int qspi_send_cmd(struct stRzSpi* pstRzSpi, const u8* pcnu8CmdBuff,
+	unsigned int unCmdLength, int sslkp)
+{
+	int ret;
+	u32 cmd;
+	u32 addr = 0;
+	u32 smopr = 0;
+	u32 smenr = 0;
+	u32 smcr;
+	u32 smdmcr = 0;
+
+	debug("call %s:\n", __func__);
+
+	/* wait spi transfered */
+	if ((ret = qspi_wait_for_tend(pstRzSpi)) < 0) {
+		printf("%s: prev xmit timeout\n", __func__);
+		return ret;
+	}
+	/* set command */
+	cmd = SMCMR_CMD(*(pcnu8CmdBuff + 0));
+
+	/* set enable command, 1bit stream. */
+	smenr = SMENR_CDE|SMENR_CDB(BITW_1BIT);
+
+	if (unCmdLength == 3) {	/* set option data  */
+		// set option data.
+		smopr |= SMOPR_OPD3(*(pcnu8CmdBuff + 1));
+		smopr |= SMOPR_OPD2(*(pcnu8CmdBuff + 2));
+		// set OPT3 OPT2, 1bit stream.
+		smenr |= SMENR_OPDE(OPDE_3_2)|SMENR_OPDB(BITW_1BIT);
+	}
+	if (unCmdLength == 2) {	/* set option data */
+		// set option data.
+		smopr |= SMOPR_OPD3(*(pcnu8CmdBuff + 1));
+		// OPD3, 1bit stream.
+		smenr |= SMENR_OPDE(OPDE_3)|SMENR_OPDB(BITW_1BIT);
+	}
+	if (unCmdLength >= 5) {	/* set address */
+		// set address param.
+		addr =	((u32)*(pcnu8CmdBuff + 1) << 24) |
+			((u32)*(pcnu8CmdBuff + 2) << 16) |
+			((u32)*(pcnu8CmdBuff + 3) << 8)  |
+			(u32)*(pcnu8CmdBuff + 4);
+		// 32bits address, 1bit stream
+		smenr |= SMENR_ADE(ADE_31_0)|SMENR_ADB(BITW_1BIT);
+		// set dummy param.
+		if (pstRzSpi->u32DummyCycle > 0) {
+			smenr |= SMENR_DME;
+			smdmcr = SMDMCR_DMDB(BITW_1BIT)|SMDMCR_DMCYC(pstRzSpi->u32DummyCycle - 1);
+		}
+	}
+	/* set params */
+	qspi_write32(pstRzSpi, cmd,	QSPI_SMCMR);	// write command.
+	qspi_write32(pstRzSpi, addr,	QSPI_SMADR);	// write address.
+	qspi_write32(pstRzSpi, smopr,	QSPI_SMOPR);	// write option.
+	qspi_write32(pstRzSpi, smenr,	QSPI_SMENR);	// write enable.
+	qspi_write32(pstRzSpi, smdmcr,	QSPI_SMDMCR);	// write dummy cycle.
+
+	/* Set SPI Data Transfer Enable first */
+	smcr = SMCR_SPIWE;
+	if (sslkp)
+		smcr |= SMCR_SSLKP;	/* keep SSL low after transfer */
+	qspi_write32(pstRzSpi, smcr, QSPI_SMCR);
+
+	/* start spi transfer */
+	smcr |= SMCR_SPIE;
+	qspi_write32(pstRzSpi, smcr, QSPI_SMCR);	// write control byte
+
+	return 0;
+}
+
+/**
+ *
+ */
+const u8 SPIDE_for_single[5] = {0x0,
+		0x8,	// 8-bit transfer (1 bytes)
+		0xC,	// 16-bit transfer (2 bytes)
+		0x0,	// 24-bit transfers are invalid!
+		0xF};	// 32-bit transfer (3-4 bytes)
+const u8 SPIDE_for_dual[9] = {0,
+		0x0,	// 8-bit transfers are invalid!
+		0x8,	// 16-bit transfer (1 byte)
+		0x0,	// 24-bit transfers are invalid!
+		0xC,	// 32-bit transfer (4 bytes)
+		0x0,	// 40-bit transfers are invalid!
+		0x0,	// 48-bit transfers are invalid!
+		0x0,	// 56-bit transfers are invalid!
+		0xF};	// 64-bit transfer (8 bytes)
+
+static int qspi_send_data(struct stRzSpi *pstRzSpi,
+	const u8* pcnu8DataBuff, unsigned int unDataLength)
+{
+	int ret;
+	u32 smcr;
+	u32 smenr = 0;
+	u32 smwdr0;
+	u32 smwdr1 = 0;
+	int unit;
+	int sslkp = 1;
+	u8 data[10];
+
+	debug("call %s:\n", __func__);
+
+	/* wait spi transfered */
+	if ((ret = qspi_wait_for_tend(pstRzSpi)) < 0) {
+		printf("%s: prev xmit timeout\n", __func__);
+		return ret;
+	}
+	/* Unless we are reading or writting data, we need to take
+	   into account that there are 2 SPI devices */
+	if( pstRzSpi->slave.cs )
+	{
+		switch (pstRzSpi->this_cmd) {
+			case 0x01: /* Write Status and configuration */
+				/* duplicate our data to both chips */
+				data[0] = pcnu8DataBuff[0];
+				data[1] = pcnu8DataBuff[0];
+				data[2] = pcnu8DataBuff[1];
+				data[3] = pcnu8DataBuff[1];
+				pcnu8DataBuff = data;
+				unDataLength = 4;
+				break;
+		}
+	}
+
+	while (unDataLength > 0) {
+
+		if( pstRzSpi->slave.cs ) {
+			/* Dual memory */
+			if (unDataLength >= 8)
+				unit = 8;
+			else
+				unit = unDataLength;
+
+			if( unit & 1 ) {
+				printf("ERROR: Can't send odd number of bytes in dual memory mode\n");
+				return -1;
+			}
+
+			if( unit == 6 )
+				unit = 4; /* 6 byte transfers not supported */
+
+			smenr |= SPIDE_for_dual[unit];
+		}
+		else {
+			/* Single memory */
+			if (unDataLength >= 4)
+				unit = 4;
+			else
+				unit = unDataLength;
+			if(unit == 3)
+				unit = 2;	/* 3 byte transfers not supported */
+
+			smenr |= SPIDE_for_single[unit];
+		}
+
+		if( !pstRzSpi->slave.cs ) {
+			/* Single memory */
+
+			/* set data */
+			smwdr0 = (u32)*pcnu8DataBuff++;
+			if (unit >= 2)
+			smwdr0 |= (u32)*pcnu8DataBuff++ << 8;
+			if (unit >= 3)
+			smwdr0 |= (u32)*pcnu8DataBuff++ << 16;
+			if (unit >= 4)
+			smwdr0 |= (u32)*pcnu8DataBuff++ << 24;
+		}
+		else
+		{
+			/* Dual memory */
+			if( unit == 8 ) {
+				/* Note that SMWDR1 gets sent out first
+				   when sending 8 bytes */
+				smwdr1 = (u32)*pcnu8DataBuff++;
+				smwdr1 |= (u32)*pcnu8DataBuff++ << 8;
+				smwdr1 |= (u32)*pcnu8DataBuff++ << 16;
+				smwdr1 |= (u32)*pcnu8DataBuff++ << 24;
+			}
+			/* sending 2 bytes */
+			smwdr0 = (u32)*pcnu8DataBuff++;
+			smwdr0 |= (u32)*pcnu8DataBuff++ << 8;
+
+			/* sending 4 bytes */
+			if( unit >= 4) {
+				smwdr0 |= (u32)*pcnu8DataBuff++ << 16;
+				smwdr0 |= (u32)*pcnu8DataBuff++ << 24;
+			}
+		}
+
+#if 0 // is this code really needed????
+		/* mask unwrite area */
+		if (unit == 3) {
+			smwdr0 |= 0xFF000000;
+		} else if (unit == 2) {
+			smwdr0 |= 0xFFFF0000;
+		} else if (unit == 1) {
+			smwdr0 |= 0xFFFFFF00;
+		}
+
+		if( pstRzSpi->stSpiSlave.cs ) {
+			/* Dual memory */
+			if (unit == 7) {
+				smwdr1 |= 0xFF000000;
+			} else if (unit == 6) {
+				smwdr1 |= 0xFFFF0000;
+			} else if (unit == 5) {
+				smwdr1 |= 0xFFFFFF00;
+			}
+		}
+#endif
+		/* Write data to send */
+		if (unit == 2){
+			qspi_write16(pstRzSpi, (u16)smwdr0, QSPI_SMWDR0);
+		}
+		else if (unit == 1){
+			qspi_write8(pstRzSpi, (u8)smwdr0, QSPI_SMWDR0);
+		}
+		else {
+			qspi_write32(pstRzSpi, smwdr0, QSPI_SMWDR0);
+		}
+
+		if( unit == 8 ) {
+			/* Dual memory only */
+			qspi_write32(pstRzSpi, smwdr1, QSPI_SMWDR1);
+		}
+
+		unDataLength -= unit;
+		if (unDataLength <= 0) {
+			sslkp = 0;
+		}
+
+		/* set params */
+		qspi_write32(pstRzSpi, 0, QSPI_SMCMR);
+		qspi_write32(pstRzSpi, 0, QSPI_SMADR);
+		qspi_write32(pstRzSpi, 0, QSPI_SMOPR);
+		qspi_write32(pstRzSpi, smenr, QSPI_SMENR);
+
+		/* start spi transfer */
+		smcr = SMCR_SPIE|SMCR_SPIWE;
+		if (sslkp)
+			smcr |= SMCR_SSLKP;
+		qspi_write32(pstRzSpi, smcr, QSPI_SMCR);
+
+		/* wait spi transfered */
+		if ((ret = qspi_wait_for_tend(pstRzSpi)) < 0) {
+			printf("%s: data send timeout\n", __func__);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+/**
+ *
+ */
+static int qspi_recv_data(struct stRzSpi* pstRzSpi,
+	u8* pu8DataBuff, unsigned int unDataLength)
+{
+	int ret;
+	u32 smcr;
+	u32 smenr = 0;
+	u32 smrdr0;
+	u32 smrdr1 = 0;
+	int unit;
+	int sslkp = 1;
+	u8 combine = 0;
+
+	debug("call %s:\n", __func__);
+
+	/* wait spi transfered */
+	if ((ret = qspi_wait_for_tend(pstRzSpi)) < 0) {
+		printf("%s: prev xmit timeout\n", __func__);
+		return ret;
+	}
+
+	/* Unless we are reading or writting data, we need to take
+	   into account that there are 2 SPI devices */
+	if( pstRzSpi->slave.cs )
+	{
+		switch (pstRzSpi->this_cmd) {
+			case 0x9F: /* Read ID */
+			case 0x05: /* Read Status register */
+			case 0x35: /* Read configuration register */
+				combine = 1;
+				unDataLength *= 2;	// get twice as much data.
+				break;
+		}
+	}
+	while (unDataLength > 0) {
+		if( pstRzSpi->slave.cs ) {
+			/* Dual memory */
+			if (unDataLength >= 8)
+				unit = 8;
+			else
+				unit = unDataLength;
+
+			if( unit & 1 ) {
+				printf("ERROR: Can't read odd number of bytes in dual memory mode\n");
+				return -1;
+			}
+
+			if( unit == 6 )
+				unit = 4; /* 6 byte transfers not supported, do 4 then 2 */
+
+			smenr = SPIDE_for_dual[unit];
+		}
+		else {
+			/* Single memory */
+			if (unDataLength >= 4)
+				unit = 4;
+			else
+				unit = unDataLength;
+			if(unit == 3)
+				unit = 2;	/* 3 byte transfers not supported */
+
+			smenr = SPIDE_for_single[unit];
+		}
+
+		unDataLength -= unit;
+		if (unDataLength <= 0) {
+			sslkp = 0;	/* Last transfer */
+		}
+
+		/* set params */
+		qspi_write32(pstRzSpi, 0, QSPI_SMCMR);
+		qspi_write32(pstRzSpi, 0, QSPI_SMADR);
+		qspi_write32(pstRzSpi, 0, QSPI_SMOPR);
+		qspi_write32(pstRzSpi, smenr, QSPI_SMENR);
+
+		/* start spi transfer */
+		smcr = SMCR_SPIE|SMCR_SPIRE;
+		if (pstRzSpi->u32DataBitw == BITW_1BIT)
+			smcr |= SMCR_SPIWE;
+		if (sslkp)
+			smcr |= SMCR_SSLKP;
+		qspi_write32(pstRzSpi, smcr, QSPI_SMCR);
+
+		/* wait spi transfered */
+		if ((ret = qspi_wait_for_tend(pstRzSpi)) < 0) {
+			printf("%s: data recive timeout\n", __func__);
+			return ret;
+		}
+
+	#if 0
+		if (unit == 2)
+			smrdr0 = qspi_read16(pstRzSpi, QSPI_SMRDR0);
+		else if (unit == 1)
+			smrdr0 = qspi_read8(pstRzSpi, QSPI_SMRDR0);
+		else
+			smrdr0 = qspi_read32(pstRzSpi, QSPI_SMRDR0);
+
+		if( unit == 8 ) {
+			/* Dual Memory */
+			smrdr1 = qspi_read32(pstRzSpi, QSPI_SMRDR1);
+		}
+	#else
+		/* Just read both regsiters. We'll figure out what parts
+		   are valid later */
+		smrdr0 = qspi_read32(pstRzSpi, QSPI_SMRDR0);
+		smrdr1 = qspi_read32(pstRzSpi, QSPI_SMRDR1);
+	#endif
+
+		if( !combine ) {
+			if (unit == 8) {
+				/* Dual Memory */
+				/* SMDR1 has the begining of the RX data (but
+				   only when 8 bytes are being read) */
+				*pu8DataBuff++ = (u8)(smrdr1 & 0xff);
+				*pu8DataBuff++ = (u8)((smrdr1 >> 8) & 0xff);
+				*pu8DataBuff++ = (u8)((smrdr1 >> 16) & 0xff);
+				*pu8DataBuff++ = (u8)((smrdr1 >> 24) & 0xff);
+			}
+
+			*pu8DataBuff++ = (u8)(smrdr0 & 0xff);
+			if (unit >= 2) {
+				*pu8DataBuff++ = (u8)((smrdr0 >> 8) & 0xff);
+			}
+			if (unit >= 4) {
+				*pu8DataBuff++ = (u8)((smrdr0 >> 16) & 0xff);
+				*pu8DataBuff++ = (u8)((smrdr0 >> 24) & 0xff);
+			}
+
+		}
+		else {
+			/* Dual Memory - Combine 2 streams back into 1 */
+			/* OR together the data coming back so the WIP bit can be
+			   checked for erase/write operations */
+			if ( unit == 8 ) {
+				/* SMRDR1 always has the begining of the RX data stream */
+				*pu8DataBuff++ = (u8)(smrdr1 & 0xff) | (u8)((smrdr1 >> 8) & 0xff);
+				*pu8DataBuff++ = (u8)((smrdr1 >> 16) & 0xff) | (u8)((smrdr1 >> 24) & 0xff);
+				*pu8DataBuff++ = (u8)(smrdr0 & 0xff) | (u8)((smrdr0 >> 8) & 0xff);
+				*pu8DataBuff++ = (u8)((smrdr0 >> 16) & 0xff) | (u8)((smrdr0 >> 24) & 0xff);
+			}
+
+			if( unit == 2 ) {
+				*pu8DataBuff++ = (u8)(smrdr0 & 0xff) | (u8)((smrdr0 >> 8) & 0xff);
+			}
+			if (unit == 4) {
+				*pu8DataBuff++ = (u8)(smrdr0 & 0xff) | (u8)((smrdr0 >> 8) & 0xff);
+				*pu8DataBuff++ = (u8)((smrdr0 >> 16) & 0xff) | (u8)((smrdr0 >> 24) & 0xff);
+			}
+		}
+	}
+
+	return 0;
+}
+
diff --git a/drivers/spi/rz_spi.h b/drivers/spi/rz_spi.h
new file mode 100644
index 0000000..b0104be
--- /dev/null
+++ b/drivers/spi/rz_spi.h
@@ -0,0 +1,290 @@
+/*
+ * RZ SPI driver
+ *
+ * Copyright (C) 2011-2014 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __RZ_SPI_H__
+#define __RZ_SPI_H__
+
+#include <spi.h>
+
+struct stRzSpi{
+	struct spi_slave	slave;
+
+	volatile void*		pRegBase;
+	u8			u8BitsPerWord;	// bits_per_word
+	u32			u32MaxSpeedHz;	// max_speed_hz
+	unsigned int		unMode;
+
+	u32			u32DataBitw;	// data_bitw
+	u32			u32DummyCycle;	// dmy_cycle
+
+	u8			data_read_dual;	// single or dual chips in data read mode
+	u8			this_cmd;	// what is the current SPI command
+};
+
+/* QSPI MODE */
+#define READ_MODE		(0)
+#define SPI_MODE		(1)
+
+/* QSPI registers */
+#define	QSPI_CMNCR		(0x0000)
+#define	QSPI_SSLDR		(0x0004)
+#define	QSPI_SPBCR		(0x0008)
+#define	QSPI_DRCR		(0x000c)
+#define	QSPI_DRCMR		(0x0010)
+#define	QSPI_DREAR		(0x0014)
+#define	QSPI_DROPR		(0x0018)
+#define	QSPI_DRENR		(0x001c)
+#define	QSPI_SMCR		(0x0020)
+#define	QSPI_SMCMR		(0x0024)
+#define	QSPI_SMADR		(0x0028)
+#define	QSPI_SMOPR		(0x002c)
+#define	QSPI_SMENR		(0x0030)
+
+#define	QSPI_SMRDR0		(0x0038)
+#define	QSPI_SMRDR1		(0x003c)
+#define	QSPI_SMWDR0		(0x0040)
+#define	QSPI_SMWDR1		(0x0044)
+#define	QSPI_CMNSR		(0x0048)
+
+#define	QSPI_DRDMCR		(0x0058)
+#define	QSPI_DRDRENR		(0x005c)
+#define	QSPI_SMDMCR		(0x0060)
+#define	QSPI_SMDRENR		(0x0064)
+
+/* CMNCR */
+#define	CMNCR_MD		(1u << 31)
+#define	CMNCR_SFDE		(1u << 24)
+
+#define	CMNCR_MOIIO3(x)		(((u32)(x) & 0x3) << 22)
+#define	CMNCR_MOIIO2(x)		(((u32)(x) & 0x3) << 20)
+#define	CMNCR_MOIIO1(x)		(((u32)(x) & 0x3) << 18)
+#define	CMNCR_MOIIO0(x)		(((u32)(x) & 0x3) << 16)
+#define	CMNCR_IO3FV(x)		(((u32)(x) & 0x3) << 14)
+#define	CMNCR_IO2FV(x)		(((u32)(x) & 0x3) << 12)
+#define	CMNCR_IO0FV(x)		(((u32)(x) & 0x3) << 8)
+
+#define	CMNCR_CPHAT		(1u << 6)
+#define	CMNCR_CPHAR		(1u << 5)
+#define	CMNCR_SSLP		(1u << 4)
+#define	CMNCR_CPOL		(1u << 3)
+#define	CMNCR_BSZ(n)		(((u32)(n) & 0x3) << 0)
+
+#define	OUT_0			(0u)
+#define	OUT_1			(1u)
+#define	OUT_REV			(2u)
+#define	OUT_HIZ			(3u)
+
+#define	BSZ_SINGLE		(0)
+#define	BSZ_DUAL		(1)
+
+/* SSLDR */
+#define	SSLDR_SPNDL(x)		(((u32)(x) & 0x7) << 16)
+#define	SSLDR_SLNDL(x)		(((u32)(x) & 0x7) << 8)
+#define	SSLDR_SCKDL(x)		(((u32)(x) & 0x7) << 0)
+
+#define	SPBCLK_1_0		(0)
+#define	SPBCLK_1_5		(0)
+#define	SPBCLK_2_0		(1)
+#define	SPBCLK_2_5		(1)
+#define	SPBCLK_3_0		(2)
+#define	SPBCLK_3_5		(2)
+#define	SPBCLK_4_0		(3)
+#define	SPBCLK_4_5		(3)
+#define	SPBCLK_5_0		(4)
+#define	SPBCLK_5_5		(4)
+#define	SPBCLK_6_0		(5)
+#define	SPBCLK_6_5		(5)
+#define	SPBCLK_7_0		(6)
+#define	SPBCLK_7_5		(6)
+#define	SPBCLK_8_0		(7)
+#define	SPBCLK_8_5		(7)
+
+/* SPBCR */
+#define	SPBCR_SPBR(x)		(((u32)(x) & 0xff) << 8)
+#define	SPBCR_BRDV(x)		(((u32)(x) & 0x3) << 0)
+
+/* DRCR (read mode) */
+#define	DRCR_SSLN		(1u << 24)
+#define	DRCR_RBURST(x)		(((u32)(x) & 0xf) << 16)
+#define	DRCR_RCF		(1u << 9)
+#define	DRCR_RBE		(1u << 8)
+#define	DRCR_SSLE		(1u << 0)
+
+/* DRCMR (read mode) */
+#define	DRCMR_CMD(c)		(((u32)(c) & 0xff) << 16)
+#define	DRCMR_OCMD(c)		(((u32)(c) & 0xff) << 0)
+
+/* DREAR (read mode) */
+#define	DREAR_EAV(v)		(((u32)(v) & 0xff) << 16)
+#define	DREAR_EAC(v)		(((u32)(v) & 0x7) << 0)
+
+/* DROPR (read mode) */
+#define	DROPR_OPD3(o)		(((u32)(o) & 0xff) << 24)
+#define	DROPR_OPD2(o)		(((u32)(o) & 0xff) << 16)
+#define	DROPR_OPD1(o)		(((u32)(o) & 0xff) << 8)
+#define	DROPR_OPD0(o)		(((u32)(o) & 0xff) << 0)
+
+/* DRENR (read mode) */
+#define	DRENR_CDB(b)		(((u32)(b) & 0x3) << 30)
+#define	DRENR_OCDB(b)		(((u32)(b) & 0x3) << 28)
+#define	DRENR_ADB(b)		(((u32)(b) & 0x3) << 24)
+#define	DRENR_OPDB(b)		(((u32)(b) & 0x3) << 20)
+#define	DRENR_DRDB(b)		(((u32)(b) & 0x3) << 16)
+#define	DRENR_DME		(1u << 15)
+#define	DRENR_CDE		(1u << 14)
+#define	DRENR_OCDE		(1u << 12)
+#define	DRENR_ADE(a)		(((u32)(a) & 0xf) << 8)
+#define	DRENR_OPDE(o)		(((u32)(o) & 0xf) << 4)
+
+/* SMCR (spi mode) */
+#define	SMCR_SSLKP		(1u << 8)
+#define	SMCR_SPIRE		(1u << 2)
+#define	SMCR_SPIWE		(1u << 1)
+#define	SMCR_SPIE		(1u << 0)
+
+/* SMCMR (spi mode) */
+#define	SMCMR_CMD(c)		(((u32)(c) & 0xff) << 16)
+#define	SMCMR_OCMD(o)		(((u32)(o) & 0xff) << 0)
+
+/* SMADR (spi mode) */
+
+/* SMOPR (spi mode) */
+#define	SMOPR_OPD3(o)		(((u32)(o) & 0xff) << 24)
+#define	SMOPR_OPD2(o)		(((u32)(o) & 0xff) << 16)
+#define	SMOPR_OPD1(o)		(((u32)(o) & 0xff) << 8)
+#define	SMOPR_OPD0(o)		(((u32)(o) & 0xff) << 0)
+
+/* SMENR (spi mode) */
+#define	SMENR_CDB(b)		(((u32)(b) & 0x3) << 30)
+#define	SMENR_OCDB(b)		(((u32)(b) & 0x3) << 28)
+#define	SMENR_ADB(b)		(((u32)(b) & 0x3) << 24)
+#define	SMENR_OPDB(b)		(((u32)(b) & 0x3) << 20)
+#define	SMENR_SPIDB(b)		(((u32)(b) & 0x3) << 16)
+#define	SMENR_DME		(1u << 15)
+#define	SMENR_CDE		(1u << 14)
+#define	SMENR_OCDE		(1u << 12)
+#define	SMENR_ADE(b)		(((u32)(b) & 0xf) << 8)
+#define	SMENR_OPDE(b)		(((u32)(b) & 0xf) << 4)
+#define	SMENR_SPIDE(b)		(((u32)(b) & 0xf) << 0)
+
+#define	ADE_23_16		(0x4)
+#define	ADE_23_8		(0x6)
+#define	ADE_23_0		(0x7)
+#define	ADE_31_0		(0xf)
+
+#define	BITW_1BIT		(0)
+#define	BITW_2BIT		(1)
+#define	BITW_4BIT		(2)
+
+#define	SPIDE_16BITS_DUAL	(0x8)
+#define	SPIDE_32BITS_DUAL	(0xc)
+#define	SPIDE_64BITS_DUAL	(0xf)
+#define	SPIDE_8BITS	(0x8)
+#define	SPIDE_16BITS	(0xc)
+#define	SPIDE_32BITS	(0xf)
+
+#define	OPDE_3			(0x8)
+#define	OPDE_3_2		(0xc)
+#define	OPDE_3_2_1		(0xe)
+#define	OPDE_3_2_1_0		(0xf)
+
+/* SMRDR0 (spi mode) */
+/* SMRDR1 (spi mode) */
+/* SMWDR0 (spi mode) */
+/* SMWDR1 (spi mode) */
+
+/* CMNSR (spi mode) */
+#define	CMNSR_SSLF		(1u << 1)
+#define	CMNSR_TEND		(1u << 0)
+
+/* DRDMCR (read mode) */
+#define	DRDMCR_DMDB(b)		(((u32)(b) & 0x3) << 16)
+#define	DRDMCR_DMCYC(b)		(((u32)(b) & 0x7) << 0)
+
+/* DRDRENR (read mode) */
+#define	DRDRENR_ADDRE		(1u << 8)
+#define	DRDRENR_OPDRE		(1u << 4)
+#define	DRDRENR_DRDRE		(1u << 0)
+
+/* SMDMCR (spi mode) */
+#define	SMDMCR_DMDB(b)		(((u32)(b) & 0x3) << 16)
+#define	SMDMCR_DMCYC(b)		(((u32)(b) & 0x7) << 0)
+
+/* SMDRENR (spi mode) */
+#define	SMDRENR_ADDRE		(1u << 8)
+#define	SMDRENR_OPDRE		(1u << 4)
+#define	SMDRENR_SPIDRE		(1u << 0)
+
+#define	QSPI_BASE_CLK		(133333333)
+
+/*
+ *  FlashROM Chip Commands
+ */
+
+#define	CMD_READ_ID		(0x9f)	/* (REMS) Read Electronic Manufacturer Signature */
+#define	CMD_PP			(0x02)	/* Page Program (3-byte address) */
+#define	CMD_QPP			(0x32)	/* Quad Page Program (3-byte address) */
+#define	CMD_READ		(0x03)	/* Read (3-byte address) */
+#define	CMD_FAST_READ		(0x0b)	/* Fast Read (3-byte address) */
+#define	CMD_DOR			(0x3b)	/* Read Dual Out (3-byte address) */
+#define	CMD_QOR			(0x6b)	/* Read Quad Out (3-byte address) */
+#define	CMD_SE			(0xd8)	/* Sector Erase */
+
+#define	CMD_4READ		(0x13)	/* Read (4-byte address) */
+#define	CMD_4FAST_READ		(0x0c)	/* Fast Read (4-byte address) */
+#define	CMD_4PP			(0x12)	/* Page Program (4-byte address) */
+#define	CMD_4SE			(0xdc)	/* Sector Erase */
+
+static inline struct stRzSpi* to_rz_spi(struct spi_slave* sl)
+{
+	return container_of(sl, struct stRzSpi, slave);
+}
+
+static inline u32 qspi_read32(struct stRzSpi* stRzSpi, int nOff)
+{
+	return readl((u32)stRzSpi->pRegBase + nOff);
+}
+
+static inline u8 qspi_read8(struct stRzSpi* stRzSpi, int nOff)
+{
+	return readb((u32)stRzSpi->pRegBase + nOff);
+}
+
+static inline u16 qspi_read16(struct stRzSpi* stRzSpi, int nOff)
+{
+	return readw((u32)stRzSpi->pRegBase + nOff);
+}
+
+static inline void qspi_write32(struct stRzSpi* stRzSpi, u32 u32Value, int nOff)
+{
+	writel(u32Value, (u32)stRzSpi->pRegBase + nOff);
+}
+
+static inline void qspi_write8(struct stRzSpi* stRzSpi, u8 u8Value, int nOff)
+{
+	writeb(u8Value, (u32)stRzSpi->pRegBase + nOff);
+}
+
+static inline void qspi_write16(struct stRzSpi* stRzSpi, u16 u16Value, int nOff)
+{
+	writew(u16Value, (u32)stRzSpi->pRegBase + nOff);
+}
+
+#endif
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 6f33456..39c0ff7 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1,6 +1,7 @@
 /*
  * R8A66597 HCD (Host Controller Driver) for u-boot
  *
+ * Copyright (C) 2013-2014 Renesas Solutions Corp.
  * Copyright (C) 2008  Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -68,6 +69,8 @@ static void set_devadd(struct r8a66597 *r8a66597, u8 r8a66597_address,
 	r8a66597_write(r8a66597, val, devadd_reg);
 }
 
+#ifndef CONFIG_CPU_RZA1
+
 static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
 {
 	u16 tmp;
@@ -121,6 +124,47 @@ static void r8a66597_clock_disable(struct r8a66597 *r8a66597)
 #endif
 }
 
+#else
+
+static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
+{
+	u16 tmp;
+	int i = 0;
+
+	do {
+		r8a66597_write(r8a66597, USBE, SYSCFG0);
+		tmp = r8a66597_read(r8a66597, SYSCFG0);
+		if (i++ > 1000) {
+			printf("r8a66597: reg access fail.\n");
+			return -1;
+		}
+	} while ((tmp & USBE) != USBE);
+	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+	r8a66597_mdfy(r8a66597, CONFIG_R8A66597_XTAL, XTAL, SYSCFG0);
+	mdelay(1);
+/*	r8a66597_bset(r8a66597, UPLLE, SYSCFG0);*/
+	tmp = *(volatile u16 *)(0xE8010000);
+	*(volatile u16 *)(0xE8010000) = tmp | UPLLE;
+	mdelay(1);
+	r8a66597_bset(r8a66597, SUSPM, SUSPMODE0);
+	return 0;
+}
+
+static void r8a66597_clock_disable(struct r8a66597 *r8a66597)
+{
+	u16 tmp;
+
+	r8a66597_bclr(r8a66597, SUSPM, SUSPMODE0);
+/*	r8a66597_bclr(r8a66597, UPLLE, SYSCFG0);*/
+	tmp = *(volatile u16 *)(0xE8010000);
+	*(volatile u16 *)(0xE8010000) = tmp & ~UPLLE;
+	mdelay(1);
+	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+	mdelay(1);
+}
+
+#endif
+
 static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
 {
 	u16 val;
@@ -129,7 +173,9 @@ static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
 	r8a66597_bset(r8a66597, val, get_syscfg_reg(port));
 	r8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));
 
+#ifndef CONFIG_CPU_RZA1
 	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, get_dmacfg_reg(port));
+#endif
 }
 
 static void r8a66597_disable_port(struct r8a66597 *r8a66597, int port)
@@ -159,7 +205,9 @@ static int enable_controller(struct r8a66597 *r8a66597)
 	if (ret < 0)
 		return ret;
 
+#ifndef CONFIG_CPU_RZA1
 	r8a66597_bset(r8a66597, CONFIG_R8A66597_LDRV & LDRV, PINCFG);
+#endif
 	r8a66597_bset(r8a66597, USBE, SYSCFG0);
 
 	r8a66597_bset(r8a66597, INTL, SOFCFG);
@@ -277,12 +325,30 @@ static int send_setup_packet(struct r8a66597 *r8a66597, struct usb_device *dev,
 	unsigned long setup_addr = USBREQ;
 	u16 intsts1;
 	int timeout = 3000;
+#ifdef CONFIG_CPU_RZA1
+	u16 dcpctr;
+	int timeout2 = 10000;
+#endif
 	u16 devsel = setup->request == USB_REQ_SET_ADDRESS ? 0 : dev->devnum;
 
 	r8a66597_write(r8a66597, make_devsel(devsel) |
 				 (8 << dev->maxpacketsize), DCPMAXP);
 	r8a66597_write(r8a66597, ~(SIGN | SACK), INTSTS1);
 
+#ifdef CONFIG_CPU_RZA1
+	dcpctr = r8a66597_read(r8a66597, DCPCTR);
+	if((dcpctr & PID)==PID_BUF){
+		timeout2 = 10000;
+		while (!(dcpctr & BSTS)){
+			dcpctr = r8a66597_read(r8a66597, DCPCTR);
+			if(timeout2-- < 0){
+				printf("DCPCTR clear timeout!\n");
+				break;
+			}
+		}
+	}
+#endif
+
 	for (i = 0; i < 4; i++) {
 		r8a66597_write(r8a66597, le16_to_cpu(p[i]), setup_addr);
 		setup_addr += 2;
diff --git a/drivers/usb/host/r8a66597.h b/drivers/usb/host/r8a66597.h
index ca1b671..1926f1a 100644
--- a/drivers/usb/host/r8a66597.h
+++ b/drivers/usb/host/r8a66597.h
@@ -1,6 +1,7 @@
 /*
  * R8A66597 HCD (Host Controller Driver) for u-boot
  *
+ * Copyright (C) 2013 Renesas Solutions Corp.
  * Copyright (C) 2008  Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -99,6 +100,279 @@
 #define DEVADD8		0xE0
 #define DEVADD9		0xE2
 #define DEVADDA		0xE4
+#ifdef CONFIG_CPU_RZA1
+#define SUSPMODE0	0x102
+#endif
+
+#ifdef CONFIG_CPU_RZA1
+
+/* System Configuration Control Register */
+#define	HSE		0x0080	/* b7: Hi-speed enable */
+#define	DCFM		0x0040	/* b6: Controller function select  */
+#define	DRPD		0x0020	/* b5: D+/- pull down control */
+#define	DPRPU		0x0010	/* b4: D+ pull up control */
+#define	XTAL		0x0004	/* b2: Crystal selection */
+#define	  XTAL12	 0x0004	  /* 12MHz */
+#define	  XTAL48	 0x0000	  /* 48MHz */
+#define	UPLLE		0x0002	/* b1: internal PLL control */
+#define	USBE		0x0001	/* b0: USB module operation enable */
+
+/* System Configuration Status Register */
+#define	OVCMON		0xC000	/* b15-14: Over-current monitor */
+#define	SOFEA		0x0020	/* b5: SOF monitor */
+#define	IDMON		0x0004	/* b3: ID-pin monitor */
+#define	LNST		0x0003	/* b1-0: D+, D- line status */
+#define	  SE1		 0x0003	  /* SE1 */
+#define	  FS_KSTS	 0x0002	  /* Full-Speed K State */
+#define	  FS_JSTS	 0x0001	  /* Full-Speed J State */
+#define	  LS_JSTS	 0x0002	  /* Low-Speed J State */
+#define	  LS_KSTS	 0x0001	  /* Low-Speed K State */
+#define	  SE0		 0x0000	  /* SE0 */
+
+/* Device State Control Register */
+#define	EXTLP0		0x0400	/* b10: External port */
+#define	VBOUT		0x0200	/* b9: VBUS output */
+#define	WKUP		0x0100	/* b8: Remote wakeup */
+#define	RWUPE		0x0080	/* b7: Remote wakeup sense */
+#define	USBRST		0x0040	/* b6: USB reset enable */
+#define	RESUME		0x0020	/* b5: Resume enable */
+#define	UACT		0x0010	/* b4: USB bus enable */
+#define	RHST		0x0007	/* b1-0: Reset handshake status */
+#define	  HSPROC	 0x0004	  /* HS handshake is processing */
+#define	  HSMODE	 0x0003	  /* Hi-Speed mode */
+#define	  FSMODE	 0x0002	  /* Full-Speed mode */
+#define	  LSMODE	 0x0001	  /* Low-Speed mode */
+#define	  UNDECID	 0x0000	  /* Undecided */
+
+/* Test Mode Register */
+#define	UTST			0x000F	/* b3-0: Test select */
+#define	  H_TST_PACKET		 0x000C	  /* HOST TEST Packet */
+#define	  H_TST_SE0_NAK		 0x000B	  /* HOST TEST SE0 NAK */
+#define	  H_TST_K		 0x000A	  /* HOST TEST K */
+#define	  H_TST_J		 0x0009	  /* HOST TEST J */
+#define	  H_TST_NORMAL		 0x0000	  /* HOST Normal Mode */
+#define	  P_TST_PACKET		 0x0004	  /* PERI TEST Packet */
+#define	  P_TST_SE0_NAK		 0x0003	  /* PERI TEST SE0 NAK */
+#define	  P_TST_K		 0x0002	  /* PERI TEST K */
+#define	  P_TST_J		 0x0001	  /* PERI TEST J */
+#define	  P_TST_NORMAL		 0x0000	  /* PERI Normal Mode */
+
+/* DMAx Pin Configuration Register */
+#define	DENDE			0x0010	/* b4: Tend enable */
+
+/* CFIFO/DxFIFO Port Select Register */
+#define	RCNT		0x8000	/* b15: Read count mode */
+#define	REW		0x4000	/* b14: Buffer rewind */
+#define	  MBW_8		 0x0000	  /*  8bit */
+#define	  MBW_16	 0x0400	  /* 16bit */
+#define	  MBW_32	 0x0800   /* 32bit */
+#define	  MBW		MBW_32
+#define	  BIGEND		0x0100	/* b8: Big endian mode */
+#define	  BYTE_LITTLE	 0x0000		/* little dendian */
+#define	  BYTE_BIG	 0x0100		/* big endifan */
+#define	ISEL		0x0020	/* b5: DCP FIFO port direction select */
+#define	CURPIPE		0x000F	/* b2-0: PIPE select */
+
+/* CFIFO/DxFIFO Port Control Register */
+#define	BVAL		0x8000	/* b15: Buffer valid flag */
+#define	BCLR		0x4000	/* b14: Buffer clear */
+#define	FRDY		0x2000	/* b13: FIFO ready */
+#define	DTLN		0x0FFF	/* b11-0: FIFO received data length */
+
+/* Interrupt Enable Register 0 */
+#define	VBSE	0x8000	/* b15: VBUS interrupt */
+#define	RSME	0x4000	/* b14: Resume interrupt */
+#define	SOFE	0x2000	/* b13: Frame update interrupt */
+#define	DVSE	0x1000	/* b12: Device state transition interrupt */
+#define	CTRE	0x0800	/* b11: Control transfer stage transition interrupt */
+#define	BEMPE	0x0400	/* b10: Buffer empty interrupt */
+#define	NRDYE	0x0200	/* b9: Buffer not ready interrupt */
+#define	BRDYE	0x0100	/* b8: Buffer ready interrupt */
+
+/* Interrupt Enable Register 1 */
+#define	OVRCRE		0x8000	/* b15: Over-current interrupt */
+#define	BCHGE		0x4000	/* b14: USB us chenge interrupt */
+#define	DTCHE		0x1000	/* b12: Detach sense interrupt */
+#define	ATTCHE		0x0800	/* b11: Attach sense interrupt */
+#define	EOFERRE		0x0040	/* b6: EOF error interrupt */
+#define	SIGNE		0x0020	/* b5: SETUP IGNORE interrupt */
+#define	SACKE		0x0010	/* b4: SETUP ACK interrupt */
+
+/* BRDY Interrupt Enable/Status Register */
+#define	BRDY9		0x0200	/* b9: PIPE9 */
+#define	BRDY8		0x0100	/* b8: PIPE8 */
+#define	BRDY7		0x0080	/* b7: PIPE7 */
+#define	BRDY6		0x0040	/* b6: PIPE6 */
+#define	BRDY5		0x0020	/* b5: PIPE5 */
+#define	BRDY4		0x0010	/* b4: PIPE4 */
+#define	BRDY3		0x0008	/* b3: PIPE3 */
+#define	BRDY2		0x0004	/* b2: PIPE2 */
+#define	BRDY1		0x0002	/* b1: PIPE1 */
+#define	BRDY0		0x0001	/* b1: PIPE0 */
+
+/* NRDY Interrupt Enable/Status Register */
+#define	NRDY9		0x0200	/* b9: PIPE9 */
+#define	NRDY8		0x0100	/* b8: PIPE8 */
+#define	NRDY7		0x0080	/* b7: PIPE7 */
+#define	NRDY6		0x0040	/* b6: PIPE6 */
+#define	NRDY5		0x0020	/* b5: PIPE5 */
+#define	NRDY4		0x0010	/* b4: PIPE4 */
+#define	NRDY3		0x0008	/* b3: PIPE3 */
+#define	NRDY2		0x0004	/* b2: PIPE2 */
+#define	NRDY1		0x0002	/* b1: PIPE1 */
+#define	NRDY0		0x0001	/* b1: PIPE0 */
+
+/* BEMP Interrupt Enable/Status Register */
+#define	BEMP9		0x0200	/* b9: PIPE9 */
+#define	BEMP8		0x0100	/* b8: PIPE8 */
+#define	BEMP7		0x0080	/* b7: PIPE7 */
+#define	BEMP6		0x0040	/* b6: PIPE6 */
+#define	BEMP5		0x0020	/* b5: PIPE5 */
+#define	BEMP4		0x0010	/* b4: PIPE4 */
+#define	BEMP3		0x0008	/* b3: PIPE3 */
+#define	BEMP2		0x0004	/* b2: PIPE2 */
+#define	BEMP1		0x0002	/* b1: PIPE1 */
+#define	BEMP0		0x0001	/* b0: PIPE0 */
+
+/* SOF Pin Configuration Register */
+#define	TRNENSEL	0x0100	/* b8: Select transaction enable period */
+#define	BRDYM		0x0040	/* b6: BRDY clear timing */
+#define	INTL		0x0020	/* b5: Interrupt sense select */
+#define	EDGESTS		0x0010	/* b4:  */
+#define	SOFMODE		0x000C	/* b3-2: SOF pin select */
+#define	  SOF_125US	 0x0008	  /* SOF OUT 125us Frame Signal */
+#define	  SOF_1MS	 0x0004	  /* SOF OUT 1ms Frame Signal */
+#define	  SOF_DISABLE	 0x0000	  /* SOF OUT Disable */
+
+/* Interrupt Status Register 0 */
+#define	VBINT	0x8000	/* b15: VBUS interrupt */
+#define	RESM	0x4000	/* b14: Resume interrupt */
+#define	SOFR	0x2000	/* b13: SOF frame update interrupt */
+#define	DVST	0x1000	/* b12: Device state transition interrupt */
+#define	CTRT	0x0800	/* b11: Control transfer stage transition interrupt */
+#define	BEMP	0x0400	/* b10: Buffer empty interrupt */
+#define	NRDY	0x0200	/* b9: Buffer not ready interrupt */
+#define	BRDY	0x0100	/* b8: Buffer ready interrupt */
+#define	VBSTS	0x0080	/* b7: VBUS input port */
+#define	DVSQ	0x0070	/* b6-4: Device state */
+#define	  DS_SPD_CNFG	 0x0070	  /* Suspend Configured */
+#define	  DS_SPD_ADDR	 0x0060	  /* Suspend Address */
+#define	  DS_SPD_DFLT	 0x0050	  /* Suspend Default */
+#define	  DS_SPD_POWR	 0x0040	  /* Suspend Powered */
+#define	  DS_SUSP	 0x0040	  /* Suspend */
+#define	  DS_CNFG	 0x0030	  /* Configured */
+#define	  DS_ADDS	 0x0020	  /* Address */
+#define	  DS_DFLT	 0x0010	  /* Default */
+#define	  DS_POWR	 0x0000	  /* Powered */
+#define	DVSQS		0x0030	/* b5-4: Device state */
+#define	VALID		0x0008	/* b3: Setup packet detected flag */
+#define	CTSQ		0x0007	/* b2-0: Control transfer stage */
+#define	  CS_SQER	 0x0006	  /* Sequence error */
+#define	  CS_WRND	 0x0005	  /* Control write nodata status stage */
+#define	  CS_WRSS	 0x0004	  /* Control write status stage */
+#define	  CS_WRDS	 0x0003	  /* Control write data stage */
+#define	  CS_RDSS	 0x0002	  /* Control read status stage */
+#define	  CS_RDDS	 0x0001	  /* Control read data stage */
+#define	  CS_IDST	 0x0000	  /* Idle or setup stage */
+
+/* Interrupt Status Register 1 */
+#define	OVRCR		0x8000	/* b15: Over-current interrupt */
+#define	BCHG		0x4000	/* b14: USB bus chenge interrupt */
+#define	DTCH		0x1000	/* b12: Detach sense interrupt */
+#define	ATTCH		0x0800	/* b11: Attach sense interrupt */
+#define	EOFERR		0x0040	/* b6: EOF-error interrupt */
+#define	SIGN		0x0020	/* b5: Setup ignore interrupt */
+#define	SACK		0x0010	/* b4: Setup acknowledge interrupt */
+
+/* Frame Number Register */
+#define	OVRN		0x8000	/* b15: Overrun error */
+#define	CRCE		0x4000	/* b14: Received data error */
+#define	FRNM		0x07FF	/* b10-0: Frame number */
+
+/* Micro Frame Number Register */
+#define	UFRNM		0x0007	/* b2-0: Micro frame number */
+
+/* Default Control Pipe Maxpacket Size Register */
+/* Pipe Maxpacket Size Register */
+#define	DEVSEL	0xF000	/* b15-14: Device address select */
+#define	MAXP	0x007F	/* b6-0: Maxpacket size of default control pipe */
+
+/* Default Control Pipe Control Register */
+#define	BSTS		0x8000	/* b15: Buffer status */
+#define	SUREQ		0x4000	/* b14: Send USB request  */
+#define	CSCLR		0x2000	/* b13: complete-split status clear */
+#define	CSSTS		0x1000	/* b12: complete-split status */
+#define	SUREQCLR	0x0800	/* b11: stop setup request */
+#define	SQCLR		0x0100	/* b8: Sequence toggle bit clear */
+#define	SQSET		0x0080	/* b7: Sequence toggle bit set */
+#define	SQMON		0x0040	/* b6: Sequence toggle bit monitor */
+#define	PBUSY		0x0020	/* b5: pipe busy */
+#define	PINGE		0x0010	/* b4: ping enable */
+#define	CCPL		0x0004	/* b2: Enable control transfer complete */
+#define	PID		0x0003	/* b1-0: Response PID */
+#define	  PID_STALL11	 0x0003	  /* STALL */
+#define	  PID_STALL	 0x0002	  /* STALL */
+#define	  PID_BUF	 0x0001	  /* BUF */
+#define	  PID_NAK	 0x0000	  /* NAK */
+
+/* Pipe Window Select Register */
+#define	PIPENM		0x0007	/* b2-0: Pipe select */
+
+/* Pipe Configuration Register */
+#define	R8A66597_TYP	0xC000	/* b15-14: Transfer type */
+#define	  R8A66597_ISO	 0xC000		  /* Isochronous */
+#define	  R8A66597_INT	 0x8000		  /* Interrupt */
+#define	  R8A66597_BULK	 0x4000		  /* Bulk */
+#define	R8A66597_BFRE	0x0400	/* b10: Buffer ready interrupt mode select */
+#define	R8A66597_DBLB	0x0200	/* b9: Double buffer mode select */
+#define	R8A66597_CNTMD	0x0100	/* b8: Continuous transfer mode select */
+#define	R8A66597_SHTNAK	0x0080	/* b7: Transfer end NAK */
+#define	R8A66597_DIR	0x0010	/* b4: Transfer direction select */
+#define	R8A66597_EPNUM	0x000F	/* b3-0: Eendpoint number select */
+
+/* Pipe Buffer Configuration Register */
+#define	BUFSIZE		0x7C00	/* b14-10: Pipe buffer size */
+#define	BUFNMB		0x007F	/* b6-0: Pipe buffer number */
+#define	PIPE0BUF	256
+#define	PIPExBUF	64
+
+/* Pipe Maxpacket Size Register */
+#define	MXPS		0x07FF	/* b10-0: Maxpacket size */
+
+/* Pipe Cycle Configuration Register */
+#define	IFIS	0x1000	/* b12: Isochronous in-buffer flush mode select */
+#define	IITV	0x0007	/* b2-0: Isochronous interval */
+
+/* Pipex Control Register */
+#define	BSTS	0x8000	/* b15: Buffer status */
+#define	INBUFM	0x4000	/* b14: IN buffer monitor (Only for PIPE1 to 5) */
+#define	CSCLR	0x2000	/* b13: complete-split status clear */
+#define	CSSTS	0x1000	/* b12: complete-split status */
+#define	ATREPM	0x0400	/* b10: Auto repeat mode */
+#define	ACLRM	0x0200	/* b9: Out buffer auto clear mode */
+#define	SQCLR	0x0100	/* b8: Sequence toggle bit clear */
+#define	SQSET	0x0080	/* b7: Sequence toggle bit set */
+#define	SQMON	0x0040	/* b6: Sequence toggle bit monitor */
+#define	PBUSY	0x0020	/* b5: pipe busy */
+#define	PID	0x0003	/* b1-0: Response PID */
+
+/* PIPExTRE */
+#define	TRENB		0x0200	/* b9: Transaction counter enable */
+#define	TRCLR		0x0100	/* b8: Transaction counter clear */
+
+/* PIPExTRN */
+#define	TRNCNT		0xFFFF	/* b15-0: Transaction counter */
+
+/* DEVADDx */
+#define	UPPHUB		0x7800
+#define	HUBPORT		0x0700
+#define	USBSPD		0x00C0
+#define	RTPORT		0x0001
+
+/* Suspend Mode Register */
+#define SUSPM		0x4000 /* b14: Suspend */
+
+#else
 
 /* System Configuration Control Register */
 #define	XTAL		0xC000	/* b15-14: Crystal selection */
@@ -391,6 +665,8 @@
 #define	USBSPD		0x00C0
 #define	RTPORT		0x0001
 
+#endif /* CONFIG_CPU_RZA1 */
+
 #define R8A66597_MAX_NUM_PIPE		10
 #define R8A66597_BUF_BSIZE		8
 #define R8A66597_MAX_DEVICE		10
@@ -431,7 +707,7 @@ static inline void r8a66597_read_fifo(struct r8a66597 *r8a66597,
 				      int len)
 {
 	int i;
-#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) || defined(CONFIG_CPU_RZA1)
 	unsigned long fifoaddr = r8a66597->reg + offset;
 	unsigned long count;
 	unsigned long *p = buf;
@@ -465,7 +741,7 @@ static inline void r8a66597_write_fifo(struct r8a66597 *r8a66597,
 {
 	int i;
 	unsigned long fifoaddr = r8a66597->reg + offset;
-#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) || defined(CONFIG_CPU_RZA1)
 	unsigned long count;
 	unsigned char *pb;
 	unsigned long *p = buf;
diff --git a/include/configs/rskrza1.h b/include/configs/rskrza1.h
new file mode 100644
index 0000000..74abc0c
--- /dev/null
+++ b/include/configs/rskrza1.h
@@ -0,0 +1,447 @@
+/*
+ * Configuation settings for the Renesas RSKRZA1 board
+ *
+ * Copyright (C) 2013-2014 Renesas Solutions Corp.
+ * Copyright (C) 2012 Renesas Electronics Europe Ltd.
+ * Copyright (C) 2012 Phil Edworthy
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __RSKRZA1_H
+#define __RSKRZA1_H
+
+#define CONFIG_ARMV7		1	/* This is an ARM V7 CPU core */
+#define CONFIG_CPU_RZA1	1
+#define CONFIG_BOARD_LATE_INIT	1
+#define CONFIG_MACH_TYPE MACH_TYPE_RSKRZA1
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_SYS_GENERIC_BOARD
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_USB
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_EXT4
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_DATE
+#define CONFIG_DOS_PARTITION
+#define CONFIG_MAC_PARTITION
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_SNTP
+#define CONFIG_BOOTP_NTPSERVER
+#define CONFIG_BOOTP_TIMEOFFSET
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_CMDLINE_TAG
+
+#ifndef _CONFIG_CMD_DEFAULT_H
+# include <config_cmd_default.h>
+#endif
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BOOTARGS		"console=ttySC2,115200"
+#define CONFIG_IPADDR		192.168.0.55
+#define CONFIG_SERVERIP		192.168.0.1
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_SYS_BAUDRATE_TABLE	{ CONFIG_BAUDRATE }
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory	*/
+#define CONFIG_SYS_PROMPT	"=> "	/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE	256	/* Boot Argument Buffer Size */
+#define CONFIG_SYS_PBSIZE	256	/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2      "> "
+
+#define CONFIG_SYS_ARM_CACHE_WRITETHROUGH
+
+/* Serial */
+#define CONFIG_SCIF_CONSOLE
+#define CONFIG_CONS_SCIF2
+#define SCIF2_BASE			0xE8008000
+#define CONFIG_SH_SCIF_CLK_FREQ CONFIG_SYS_CLK_FREQ
+
+/* Memory */
+/* u-boot relocated to top 256KB of ram */
+#define CONFIG_NR_DRAM_BANKS		1
+#if !defined(CONFIG_BOOT_MODE0)
+#define CONFIG_SYS_TEXT_BASE		0x18000000
+#else
+#define CONFIG_SYS_TEXT_BASE		0x00000000
+#endif
+#define USE_INTERNAL_RAM 1
+#ifdef USE_INTERNAL_RAM
+ #define CONFIG_SYS_SDRAM_BASE		0x20000000
+ #define CONFIG_SYS_SDRAM_SIZE		(10 * 1024 * 1024)
+ #define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE - 1*1024*1024)
+#else
+ #define CONFIG_SYS_SDRAM_BASE		0x08000000
+ #define CONFIG_SYS_SDRAM_SIZE		(32 * 1024 * 1024)
+ #define CONFIG_SYS_INIT_SP_ADDR         (0x09F00000)
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x2000000)
+#define CONFIG_SYS_MALLOC_LEN		(512 * 1024)
+#define CONFIG_SYS_MONITOR_LEN		(128 * 1024)
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 4*1024*1024)
+#define	CONFIG_LOADADDR			CONFIG_SYS_SDRAM_BASE
+
+/* NOR Flash */
+#define CONFIG_SYS_FLASH_BASE		0x00000000
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_MAX_FLASH_SECT	512
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE }
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+
+#if !defined(CONFIG_BOOT_MODE0)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OFFSET	0x80000
+#define CONFIG_ENV_SECT_SIZE	0x40000		/* smallest erase sector size */
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OFFSET	(512 * 1024)
+#define CONFIG_ENV_SECT_SIZE	(256 * 1024)
+#endif
+
+#define CONFIG_ENV_SIZE		CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
+#define CONFIG_ENV_OVERWRITE	1
+
+#define __io
+
+/* Spi-Flash configuration */
+#define CONFIG_RZ_SPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_RZA1_BASE_QSPI0		0x3FEFA000
+
+/* I2C configuration */
+#define CONFIG_SH_RIIC
+#define CONFIG_HARD_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_SYS_MAX_I2C_BUS		4
+#define CONFIG_SYS_I2C_SPEED		100000 /* 100 kHz */
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS	4	/* 16-Byte Write Mode */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	10	/* 10ms of delay */
+#define CONFIG_SYS_I2C_MODULE		3
+#define CONFIG_SH_I2C_BASE0		0xFCFEE000
+#define CONFIG_SH_I2C_BASE1		0xFCFEE400
+#define CONFIG_SH_I2C_BASE2		0xFCFEE800
+#define CONFIG_SH_I2C_BASE3		0xFCFEEc00
+
+/* RTC configuration */
+#define CONFIG_RTC_RZA1
+#define CONFIG_RTC_RZA1_BASE_ADDR	0xFCFF1000
+
+/* Board Clock */
+#define CONFIG_SYS_CLK_FREQ	66666666 /* P1 clock. */
+#define CONFIG_SYS_HZ		1000
+
+/* Network interface */
+#define CONFIG_SH_ETHER
+#define CONFIG_SH_ETHER_USE_PORT	0
+#define CONFIG_SH_ETHER_PHY_ADDR	0
+#define CONFIG_SH_ETHER_PHY_MODE PHY_INTERFACE_MODE_MII
+#define CONFIG_SH_ETHER_EEPROM_ADDR	2 /* MAC address offset in EEPROM */
+#define CONFIG_PHYLIB
+#define CONFIG_BITBANGMII
+#define CONFIG_BITBANGMII_MULTI
+
+/* USB host controller */
+#define CONFIG_USB_R8A66597_HCD
+#define CONFIG_R8A66597_BASE_ADDR	0xE8207000
+#define CONFIG_R8A66597_XTAL		0x0000	/* 48MHz */
+#define CONFIG_R8A66597_ENDIAN		0x0000	/* little */
+
+/*
+ * Lowlevel configuration
+ */
+/* Disable WDT */
+#define WTCSR_D		0xA518
+#define WTCNT_D		0x5A00
+
+/* Set clocks based on 13.3333MHz xtal */
+#define FRQCR_D		0x1035	/* CPU= 300-400 MHz */
+
+/* Enable all peripherals */
+#define STBCR3_D	0x00000000
+#define STBCR4_D	0x00000000
+#define STBCR5_D	0x00000000
+#define STBCR6_D	0x00000000
+#define STBCR7_D	0x00000024
+#define STBCR8_D	0x00000005
+#define STBCR9_D	0x00000000
+#define STBCR10_D	0x00000000
+#define STBCR11_D	0x000000c0
+#define STBCR12_D	0x000000f0
+
+/* Port Control register */
+/* Port1 Control register Reset */
+#define PIBC1_D		0x0000
+#define PBDC1_D		0x0000
+#define PM1_D		0xffff
+#define PMC1_D		0x0000
+#define PIPC1_D		0x0000
+
+/* Port1 Control register Set */
+#define PBDC1_S		0x00c0
+#define PFC1_S		0x4000	/* SCL3, SDA3, ET_COL, P15 */
+#define PFCE1_S		0x4000
+#define PFCAE1_S	0x0000
+#define PIPC1_S		0x40c0
+#define PMC1_S		0x40c0
+#define P1_S		0x0000
+#define PM1_S		0xffff
+#define PIBC1_S		0xbf3f
+
+/* Port2 Control register Reset */
+#define PIBC2_D		0x0000
+#define PBDC2_D		0x0000
+#define PM2_D		0xffff
+#define PMC2_D		0x0000
+#define PIPC2_D		0x0000
+
+/* Port2 Control register Set */
+#define PBDC2_S		0xf000
+#define PFC2_S		0xffff	/* ET_xxx */
+#define PFCE2_S		0xf000	/* SPBIO01_0, SPBIO11_0, SPBIO21_0, SPBIO31_0 */
+#define PFCAE2_S	0x0000
+#define PIPC2_S		0xffff
+#define PMC2_S		0xffff
+#define P2_S		0x0000
+#define PM2_S		0xffff
+#define PIBC2_S		0x0000
+
+/* Port3 Control register Reset */
+#define PIBC3_D		0x0000
+#define PBDC3_D		0x0000
+#define PM3_D		0xffff
+#define PMC3_D		0x0000
+#define PIPC3_D		0x0000
+
+/* Port3 Control register Set */
+#define PBDC3_S		0x0008
+#define PFC3_S		0x007d	/* TxD2, RxD2 */
+#define PFCE3_S		0x0004	/* ET_MDIO, ET_RXCCLK, ET_RXER ET_RXDV */
+#define PFCAE3_S	0x0001
+#define PIPC3_S		0x007d
+#define PMC3_S		0x007d
+#define P3_S		0x0000
+#define PM3_S		0xffff
+#define PIBC3_S		0x0000
+
+/* Port4 Control register Reset */
+#define PIBC4_D		0x0000
+#define PBDC4_D		0x0000
+#define PM4_D		0xffff
+#define PMC4_D		0x0000
+#define PIPC4_D		0x0000
+
+/* Port4 Control register Set */
+#define PBDC4_S		0x0000
+#define PFC4_S		0x0000
+#define PFCE4_S		0x0000
+#define PFCAE4_S	0x0000
+#define PIPC4_S		0x0000
+#define PMC4_S		0x0000
+#define P4_S		0x0000
+#define PM4_S		0xffff
+#define PIBC4_S		0x0000
+
+/* Port5 Control register Reset */
+#define PIBC5_D		0x0000
+#define PBDC5_D		0x0000
+#define PM5_D		0xffff
+#define PMC5_D		0x0000
+#define PIPC5_D		0x0000
+
+/* Port5 Control register Set */
+#define PBDC5_S		0x0000
+#define PFC5_S		0x0300	/* CS2, ET_MDC */
+#define PFCE5_S		0x0000
+#define PFCAE5_S	0x0100
+#define PIPC5_S		0x0300
+#define PMC5_S		0x0300
+#define P5_S		0x0000
+#define PM5_S		0xffff
+#define PIBC5_S		0x0000
+
+/* Port6 Control register Reset */
+#if !defined(CONFIG_BOOT_MODE0)
+#define PIBC6_D		0x0000
+#define PBDC6_D		0x0000
+#define PM6_D		0xffff
+#define PMC6_D		0x0000
+#define PIPC6_D		0x0000
+#else
+#define PIBC6_D		0x0000
+#define PBDC6_D		0xffff
+#define PM6_D		0xffff
+#define PMC6_D		0xffff
+#define PIPC6_D		0xffff
+#endif
+
+/* Port6 Control register Set */
+#define PBDC6_S		0xffff
+#define PFC6_S		0x0000	/* D1 - D15 */
+#define PFCE6_S		0x0000
+#define PFCAE6_S	0x0000
+#define PIPC6_S		0xffff
+#define PMC6_S		0xffff
+#define P6_S		0x0000
+#define PM6_S		0xffff
+#define PIBC6_S		0x0000
+
+/* Port7 Control register Reset */
+#if !defined(CONFIG_BOOT_MODE0)
+#define PIBC7_D		0x0000
+#define PBDC7_D		0x0000
+#define PM7_D		0xffff
+#define PMC7_D		0x0000
+#define PIPC7_D		0x0000
+#else
+#define PIBC7_D		0x0000
+#define PBDC7_D		0xff01
+#define PM7_D		0xffff
+#define PMC7_D		0xff01
+#define PIPC7_D		0xff01
+#endif
+
+/* Port7 Control register Set */
+#if !defined(CONFIG_BOOT_MODE0)
+#define PBDC7_S		0x0000
+#else
+#define PBDC7_S		0xfffd
+#endif
+#define PFC7_S		0x0000	/* WE0/DQMLL, RD/WR, RD, CS0 */
+#define PFCE7_S		0x0000	/* CKE, CAS, RAS, WE1/DQMLL, A7-A1 */
+#define PFCAE7_S	0x0000
+#define PIPC7_S		0xfffd
+#define PMC7_S		0xfffd
+#define P7_S		0x0000
+#define PM7_S		0xffff
+#define PIBC7_S		0x0000
+
+/* Port8 Control register Reset */
+#if !defined(CONFIG_BOOT_MODE0)
+#define PIBC8_D		0x0000
+#define PBDC8_D		0x0000
+#define PM8_D		0xffff
+#define PMC8_D		0x0000
+#define PIPC8_D		0x0000
+#else
+#define PIBC8_D		0x0000
+#define PBDC8_D		0x1fff
+#define PM8_D		0xffff
+#define PMC8_D		0x1fff
+#define PIPC8_D		0x1fff
+#endif
+
+/* Port8 Control register Set */
+#if !defined(CONFIG_BOOT_MODE0)
+#define PBDC8_S		0x0000
+#else
+#define PBDC8_S		0xffff
+#endif
+#define PFC8_S		0x0000	/* A23-A8 */
+#define PFCE8_S		0x0000	/* A23-A8 NOR, A15-A8 SDRAM */
+#define PFCAE8_S	0x0000
+#define PIPC8_S		0xffff
+#define PMC8_S		0xffff
+#define P8_S		0x0000
+#define PM8_S		0xffff
+#define PIBC8_S		0x0000
+
+/* Port9 Control register Reset */
+#if !defined(CONFIG_BOOT_MODE0)
+#define PIBC9_D		0x0000
+#define PBDC9_D		0x0000
+#define PM9_D		0xffff
+#define PMC9_D		0x00ff
+#define PIPC9_D		0x00ff
+#else
+#define PIBC9_D		0x0000
+#define PBDC9_D		0x0000
+#define PM9_D		0xffff
+#define PMC9_D		0x0003
+#define PIPC9_D		0x0003
+#endif
+
+/* Port9 Control register Set */
+#define PBDC9_S		0x00f0
+#define PFC9_S		0x00fc	/* A25,A24 NOR, P9_2-P9_7(SPBxxx) SPI Flash */
+#define PFCE9_S		0x0000	/* SPBIO00_0, SPBIO10_0, SPBIO20_0, SPBIO20_0 */
+#define PFCAE9_S	0x0000
+#define PIPC9_S		0x00ff
+#define PMC9_S		0x00ff
+#define P9_S		0x0000
+#define PM9_S		0xffff
+#define PIBC9_S		0x0000
+
+/* Port10 Control register Reset */
+#define PIBC10_D	0x0000
+#define PBDC10_D	0x0000
+#define PM10_D		0xffff
+#define PMC10_D		0x0000
+#define PIPC10_D	0x0000
+
+/* Port10 Control register Set */
+#define PBDC10_S	0x0000
+#define PFC10_S		0x0000
+#define PFCE10_S	0x0000
+#define PFCAE10_S	0x0000
+#define PIPC10_S	0x0000
+#define PMC10_S		0x0000
+#define P10_S		0x0000
+#define PM10_S		0xffff
+#define PIBC10_S	0x0000
+
+/* Port11 Control register Reset */
+#define PIBC11_D	0x0000
+#define PBDC11_D	0x0000
+#define PM11_D		0xffff
+#define PMC11_D		0x0000
+#define PIPC11_D	0x0000
+
+/* Port11 Control register Set */
+#define PBDC11_S	0x0000
+#define PFC11_S		0x0000
+#define PFCE11_S	0x0000
+#define PFCAE11_S	0x0000
+#define PIPC11_S	0x0000
+#define PMC11_S		0x0000
+#define P11_S		0x0000
+#define PM11_S		0xffff
+#define PIBC11_S	0x0000
+
+/* Configure NOR Flash (CS0, CS1) */
+#define CS0WCR_D	0x00000b40
+#define CS0BCR_D	0x10000C00
+#define CS1WCR_D	0x00000b40
+#define CS1BCR_D	0x10000C00
+
+/* Configure SDRAM (CS2, CS3) */
+#define CS2BCR_D	0x00004C00
+#define CS2WCR_D	0x00000480
+#define CS3BCR_D	0x00004C00
+#define CS3WCR_D	0x00004492
+#define SDCR_D		0x00110811
+#define RTCOR_D		0xA55A0080
+#define RTCSR_D		0xA55A0008
+
+#endif	/* __RSKRZA1_H */
diff --git a/include/spi_flash.h b/include/spi_flash.h
index 5913b39..b9aa58a 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -39,6 +39,7 @@ struct spi_slave;
  * @spi:		SPI slave
  * @name:		Name of SPI flash
  * @dual_flash:	Indicates dual flash memories - dual stacked, parallel
+ * @four_byte:		Indicates support for Spansion 4 byte addressing
  * @shift:		Flash shift useful in dual parallel
  * @size:		Total flash size
  * @page_size:		Write (page) size
@@ -71,6 +72,7 @@ struct spi_flash {
 	const char *name;
 	u8 dual_flash;
 	u8 shift;
+	u8 four_byte;
 
 	u32 size;
 	u32 page_size;
