diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 1594945..e95f1f7 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -673,7 +673,7 @@ config ARCH_MSM_NODT
 config ARCH_SHMOBILE_LEGACY
 	bool "Renesas ARM SoCs (non-multiplatform)"
 	select ARCH_SHMOBILE
-	select ARM_PATCH_PHYS_VIRT
+	select ARM_PATCH_PHYS_VIRT if !XIP_KERNEL
 	select CLKDEV_LOOKUP
 	select GENERIC_CLOCKEVENTS
 	select HAVE_ARM_SCU if SMP
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 0320303..1b390ba 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -247,6 +247,7 @@ dtb-$(CONFIG_ARCH_S3C64XX) += s3c6410-mini6410.dtb \
 dtb-$(CONFIG_ARCH_SHMOBILE_LEGACY) += emev2-kzm9d.dtb \
 	r7s72100-genmai.dtb \
 	r7s72100-genmai-reference.dtb \
+	r7s72100-rskrza1.dtb \
 	r8a7740-armadillo800eva.dtb \
 	r8a7778-bockw.dtb \
 	r8a7778-bockw-reference.dtb \
diff --git a/arch/arm/boot/dts/r7s72100-rskrza1.dts b/arch/arm/boot/dts/r7s72100-rskrza1.dts
new file mode 100644
index 0000000..7a249c3
--- /dev/null
+++ b/arch/arm/boot/dts/r7s72100-rskrza1.dts
@@ -0,0 +1,34 @@
+/*
+ * Device Tree Source for the RSKRZA1 board
+ *
+ * Copyright (C) 2014 Renesas America
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/dts-v1/;
+#include "r7s72100.dtsi"
+
+/ {
+	model = "RSKRZA1";
+	compatible = "renesas,rskrza1", "renesas,r7s72100";
+
+	chosen {
+		/* Add lots of white space so we have room to overwirte in u-boot */ 
+		bootargs = "console=ttySC2,115200 ignore_loglevel rw root=/dev/nfs ip=dhcp\
+                                                                                       ";
+
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x08000000 0x08000000>;
+	};
+
+	lbsc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
diff --git a/arch/arm/configs/rskrza1_defconfig b/arch/arm/configs/rskrza1_defconfig
new file mode 100644
index 0000000..dc705e0
--- /dev/null
+++ b/arch/arm/configs/rskrza1_defconfig
@@ -0,0 +1,138 @@
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_DEFAULT_NOOP=y
+CONFIG_ARCH_SHMOBILE_LEGACY=y
+CONFIG_ARCH_R7S72100=y
+CONFIG_MACH_RSKRZA1=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_775420=y
+CONFIG_AEABI=y
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_KEXEC=y
+CONFIG_AUTO_ZRELADDR=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_PM_RUNTIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_ROM=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_M25P80=y
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+CONFIG_SH_ETH=y
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_WLAN is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_FT5X06=y
+CONFIG_TOUCHSCREEN_FT5X06_SINGLE_TOUCH=y
+CONFIG_LEGACY_PTY_COUNT=4
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_NR_UARTS=10
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_RIIC_RZA1=y
+CONFIG_SPI=y
+CONFIG_SPI_RSPI=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_RCAR_THERMAL=y
+CONFIG_FB=y
+CONFIG_FB_VDC5=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+# CONFIG_SND_USB is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SCUX_RSKRZA1=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_R8A66597_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_R8A66597=y
+CONFIG_USB_ETH=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHI=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SH=y
+# CONFIG_SH_DMAE_BASE is not set
+CONFIG_RZA1_DMAE=y
+CONFIG_UIO=y
+CONFIG_UIO_PDRV_GENIRQ=y
+CONFIG_IIO=y
+CONFIG_SH_ADC=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_FS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRC16=y
diff --git a/arch/arm/configs/rskrza1_xip_defconfig b/arch/arm/configs/rskrza1_xip_defconfig
new file mode 100644
index 0000000..b9c7a01
--- /dev/null
+++ b/arch/arm/configs/rskrza1_xip_defconfig
@@ -0,0 +1,105 @@
+CONFIG_PHYS_OFFSET=0x20000000
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_DEFAULT_NOOP=y
+CONFIG_ARCH_SHMOBILE_LEGACY=y
+CONFIG_ARCH_R7S72100=y
+CONFIG_MACH_RSKRZA1=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_775420=y
+CONFIG_AEABI=y
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_XIP_KERNEL=y
+CONFIG_XIP_PHYS_ADDR=0x18200000
+CONFIG_KEXEC=y
+CONFIG_AUTO_ZRELADDR=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_PM_RUNTIME=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_ROM=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_M25P80=y
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_FT5X06=y
+CONFIG_TOUCHSCREEN_FT5X06_SINGLE_TOUCH=y
+CONFIG_LEGACY_PTY_COUNT=4
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_NR_UARTS=10
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_RIIC_RZA1=y
+CONFIG_SPI=y
+CONFIG_SPI_RSPI=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_FB=y
+CONFIG_FB_VDC5=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+# CONFIG_SND_USB is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SCUX_RSKRZA1=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_R8A66597_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHI=y
+CONFIG_MMC_SH_MMCIF=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SH=y
+# CONFIG_SH_DMAE_BASE is not set
+CONFIG_RZA1_DMAE=y
+CONFIG_IIO=y
+CONFIG_SH_ADC=y
+CONFIG_EXT2_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_FS=y
+CONFIG_KEYS=y
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRC16=y
diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index 05fa505..8b01a6a 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -27,6 +27,8 @@ config ARCH_EMEV2
 
 config ARCH_R7S72100
 	bool "RZ/A1H (R7S72100)"
+	select SYS_SUPPORTS_SH_MTU2
+	select SYS_SUPPORTS_SH_OSTM
 
 config ARCH_R8A7790
 	bool "R-Car H2 (R8A77900)"
@@ -42,6 +44,10 @@ config MACH_GENMAI
 	bool "Genmai board"
 	depends on ARCH_R7S72100
 
+config MACH_RSKRZA1
+	bool "RZ/A1 RSK board"
+	depends on ARCH_R7S72100
+
 config MACH_KOELSCH
 	bool "Koelsch board"
 	depends on ARCH_R8A7791
@@ -148,6 +154,7 @@ config ARCH_R7S72100
 	select ARM_GIC
 	select CPU_V7
 	select SH_CLK_CPG
+	select SYS_SUPPORTS_SH_MTU2
 
 comment "Renesas ARM SoCs Board Type"
 
@@ -237,6 +244,11 @@ config MACH_GENMAI_REFERENCE
 
 	   This is intended to aid developers
 
+config MACH_RSKRZA1
+	bool "RZ/A1 RSK board"
+	depends on ARCH_R7S72100
+	select USE_OF
+
 config MACH_MARZEN
 	bool "MARZEN board"
 	depends on ARCH_R8A7779
@@ -321,24 +333,6 @@ config SHMOBILE_TIMER_HZ
 	  want to select a HZ value such as 128 that can evenly divide RCLK.
 	  A HZ value that does not divide evenly may cause timer drift.
 
-config SH_TIMER_CMT
-	bool "CMT timer driver"
-	default y
-	help
-	  This enables build of the CMT timer driver.
-
-config SH_TIMER_TMU
-	bool "TMU timer driver"
-	default y
-	help
-	  This enables build of the TMU timer driver.
-
-config EM_TIMER_STI
-	bool "STI timer driver"
-	default y
-	help
-	  This enables build of the STI timer driver.
-
 endmenu
 
 endif
diff --git a/arch/arm/mach-shmobile/Makefile b/arch/arm/mach-shmobile/Makefile
index fe7d4ff..fd64dfe 100644
--- a/arch/arm/mach-shmobile/Makefile
+++ b/arch/arm/mach-shmobile/Makefile
@@ -68,6 +68,7 @@ obj-$(CONFIG_MACH_BOCKW)	+= board-bockw.o
 obj-$(CONFIG_MACH_BOCKW_REFERENCE)	+= board-bockw-reference.o
 obj-$(CONFIG_MACH_GENMAI)	+= board-genmai.o
 obj-$(CONFIG_MACH_GENMAI_REFERENCE)	+= board-genmai-reference.o
+obj-$(CONFIG_MACH_RSKRZA1)	+= board-rskrza1.o pfc-rza1.o
 obj-$(CONFIG_MACH_MARZEN)	+= board-marzen.o
 obj-$(CONFIG_MACH_MARZEN_REFERENCE)	+= board-marzen-reference.o
 obj-$(CONFIG_MACH_LAGER)	+= board-lager.o
diff --git a/arch/arm/mach-shmobile/Makefile.boot b/arch/arm/mach-shmobile/Makefile.boot
index 99455ec..e991c56 100644
--- a/arch/arm/mach-shmobile/Makefile.boot
+++ b/arch/arm/mach-shmobile/Makefile.boot
@@ -8,6 +8,7 @@ loadaddr-$(CONFIG_MACH_BOCKW) += 0x60008000
 loadaddr-$(CONFIG_MACH_BOCKW_REFERENCE) += 0x60008000
 loadaddr-$(CONFIG_MACH_GENMAI) += 0x08008000
 loadaddr-$(CONFIG_MACH_GENMAI_REFERENCE) += 0x08008000
+loadaddr-$(CONFIG_MACH_RSKRZA1) += 0x08008000
 loadaddr-$(CONFIG_MACH_KOELSCH) += 0x40008000
 loadaddr-$(CONFIG_MACH_KZM9G) += 0x41008000
 loadaddr-$(CONFIG_MACH_KZM9G_REFERENCE) += 0x41008000
diff --git a/arch/arm/mach-shmobile/board-genmai.c b/arch/arm/mach-shmobile/board-genmai.c
index 3e92e3c..6c328d6 100644
--- a/arch/arm/mach-shmobile/board-genmai.c
+++ b/arch/arm/mach-shmobile/board-genmai.c
@@ -1,8 +1,9 @@
 /*
  * Genmai board support
  *
- * Copyright (C) 2013  Renesas Solutions Corp.
+ * Copyright (C) 2013-2014  Renesas Solutions Corp.
  * Copyright (C) 2013  Magnus Damm
+ * Copyright (C) 2014  Cogent Embedded, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,15 +21,87 @@
 
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
+#include <linux/sh_eth.h>
+#include <linux/spi/rspi.h>
+#include <linux/spi/spi.h>
 #include <mach/common.h>
+#include <mach/irqs.h>
 #include <mach/r7s72100.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 
+/* Ether */
+static const struct sh_eth_plat_data ether_pdata __initconst = {
+	.phy			= 0x00, /* PD60610 */
+	.edmac_endian		= EDMAC_LITTLE_ENDIAN,
+	.phy_interface		= PHY_INTERFACE_MODE_MII,
+	.no_ether_link		= 1
+};
+
+static const struct resource ether_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8203000, 0x800),
+	DEFINE_RES_MEM(0xe8204800, 0x200),
+	DEFINE_RES_IRQ(gic_iid(359)),
+};
+
+static const struct platform_device_info ether_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "r7s72100-ether",
+	.id		= -1,
+	.res		= ether_resources,
+	.num_res	= ARRAY_SIZE(ether_resources),
+	.data		= &ether_pdata,
+	.size_data	= sizeof(ether_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* RSPI */
+#define RSPI_RESOURCE(idx, baseaddr, irq)				\
+static const struct resource rspi##idx##_resources[] __initconst = {	\
+	DEFINE_RES_MEM(baseaddr, 0x24),					\
+	DEFINE_RES_IRQ_NAMED(irq, "error"),				\
+	DEFINE_RES_IRQ_NAMED(irq + 1, "rx"),				\
+	DEFINE_RES_IRQ_NAMED(irq + 2, "tx"),				\
+}
+
+RSPI_RESOURCE(0, 0xe800c800, gic_iid(270));
+RSPI_RESOURCE(1, 0xe800d000, gic_iid(273));
+RSPI_RESOURCE(2, 0xe800d800, gic_iid(276));
+RSPI_RESOURCE(3, 0xe800e000, gic_iid(279));
+RSPI_RESOURCE(4, 0xe800e800, gic_iid(282));
+
+static const struct rspi_plat_data rspi_pdata __initconst = {
+	.num_chipselect	= 1,
+};
+
+#define r7s72100_register_rspi(idx)					   \
+	platform_device_register_resndata(&platform_bus, "rspi-rz", idx,   \
+					rspi##idx##_resources,		   \
+					ARRAY_SIZE(rspi##idx##_resources), \
+					&rspi_pdata, sizeof(rspi_pdata))
+
+static const struct spi_board_info spi_info[] __initconst = {
+	{
+		.modalias               = "wm8978",
+		.max_speed_hz           = 5000000,
+		.bus_num                = 4,
+		.chip_select            = 0,
+	},
+};
+
 static void __init genmai_add_standard_devices(void)
 {
 	r7s72100_clock_init();
 	r7s72100_add_dt_devices();
+
+	platform_device_register_full(&ether_info);
+
+	r7s72100_register_rspi(0);
+	r7s72100_register_rspi(1);
+	r7s72100_register_rspi(2);
+	r7s72100_register_rspi(3);
+	r7s72100_register_rspi(4);
+	spi_register_board_info(spi_info, ARRAY_SIZE(spi_info));
 }
 
 static const char * const genmai_boards_compat_dt[] __initconst = {
diff --git a/arch/arm/mach-shmobile/board-rskrza1.c b/arch/arm/mach-shmobile/board-rskrza1.c
new file mode 100644
index 0000000..9807c6b
--- /dev/null
+++ b/arch/arm/mach-shmobile/board-rskrza1.c
@@ -0,0 +1,1386 @@
+/*
+ * RSKRZA1 board support
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ * Copyright (C) 2013  Magnus Damm
+ * Copyright (C) 2014  Chris Brandt
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+#include <linux/sh_eth.h>
+#include <asm/mach/map.h>
+#include <mach/common.h>
+#include <mach/irqs.h>
+#include <mach/r7s72100.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <linux/spi/rspi.h>
+#include <linux/spi/sh_spibsc.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c.h>
+#include <linux/i2c-riic.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sh_mmcif.h>
+#include <linux/mmc/sh_mobile_sdhi.h>
+#include <linux/mfd/tmio.h>
+#include <linux/pwm.h>
+#include <linux/pwm_backlight.h>
+#include <linux/platform_data/at24.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_data/sh_adc.h>
+#include <linux/usb/r8a66597.h>
+#include <linux/platform_data/dma-rza1.h>
+#include <linux/input/edt-ft5x06.h>
+#include <linux/uio_driver.h>
+#include <clocksource/sh_ostm.h>
+#include <video/vdc5fb.h>
+#include <sound/sh_scux.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+
+static int usbgs = -1;
+static int __init early_usbgs(char *str)
+{
+	usbgs = 0;
+	get_option(&str, &usbgs);
+	return 0;
+}
+early_param("usbgs", early_usbgs);
+
+static struct map_desc rza1_io_desc[] __initdata = {
+	/* create a 1:1 entity map for 0xe8xxxxxx
+	 * used by INTC.
+	 */
+	{
+		.virtual	= 0xe8000000,
+		.pfn		= __phys_to_pfn(0xe8000000),
+		.length		= SZ_256M,
+		.type		= MT_DEVICE_NONSHARED
+	},
+	/* create a 1:1 entity map for 0xfcfexxxx
+	 * used by MSTP, CPG.
+	 */
+	{
+		.virtual	= 0xfcfe0000,
+		.pfn		= __phys_to_pfn(0xfcfe0000),
+		.length		= SZ_64K,
+		.type		= MT_DEVICE_NONSHARED
+	},
+#ifdef CONFIG_CACHE_L2X0
+	/* create a 1:1 entity map for 0x3ffffxxx
+	 * used by L2CC (PL310).
+	 */
+	{
+		.virtual	= 0xfffee000,
+		.pfn		= __phys_to_pfn(0x3ffff000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE_NONSHARED
+	},
+#endif
+	{
+		.virtual	= 0xffefa000,
+		.pfn		= __phys_to_pfn(0x3fefa000),
+		.length		= SZ_64K,
+		.type		= MT_DEVICE_NONSHARED
+	},
+};
+
+void __init rza1_map_io(void)
+{
+	iotable_init(rza1_io_desc, ARRAY_SIZE(rza1_io_desc));
+}
+
+
+/* DMA */
+#define CHCFG(reqd_v, loen_v, hien_v, lvl_v, am_v, sds_v, dds_v, tm_v)\
+	{								\
+		.reqd	=	reqd_v,					\
+		.loen	=	loen_v,					\
+		.hien	=	hien_v,					\
+		.lvl	=	lvl_v,					\
+		.am	=	am_v,					\
+		.sds	=	sds_v,					\
+		.dds	=	dds_v,					\
+		.tm	=	tm_v,					\
+	}
+#define DMARS(rid_v, mid_v)	\
+	{								\
+		.rid	= rid_v,					\
+		.mid	= mid_v,					\
+	}
+
+static const struct rza1_dma_slave_config rza1_dma_slaves[] = {
+	{
+		.slave_id	= RZA1DMA_SLAVE_SDHI0_TX,
+		.addr		= 0xe804e030,
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x1, 0x30),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_SDHI0_RX,
+		.addr		= 0xe804e030,
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x2, 0x30),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_SDHI1_TX,
+		.addr		= 0xe804e830,
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x1, 0x31),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_SDHI1_RX,
+		.addr		= 0xe804e830,
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x2, 0x31),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_MMCIF_TX,
+		.addr		= 0xe804c834,
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x1, 0x32),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_MMCIF_RX,
+		.addr		= 0xe804c834,
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x2, 0x32),
+	},
+	{
+		.slave_id	= RZA1DMA_SLAVE_PCM_MEM_SSI0,
+		.addr		= 0xe820b018,		/* SSIFTDR_0 */
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x1, 0x38),
+	}, {
+		.slave_id	= RZA1DMA_SLAVE_PCM_MEM_SRC1,
+		.addr		= 0xe820970c,		/* DMATD1_CIM */
+		.chcfg		= CHCFG(0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0),
+		.dmars		= DMARS(0x1, 0x41),
+	}, {
+		.slave_id	= RZA1DMA_SLAVE_PCM_SSI0_MEM,
+		.addr		= 0xe820b01c,		/* SSIFRDR_0 */
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x0),
+		.dmars		= DMARS(0x2, 0x38),
+	}, {
+		.slave_id	= RZA1DMA_SLAVE_PCM_SRC0_MEM,
+		.addr		= 0xe8209718,		/* DMATU0_CIM */
+		.chcfg		= CHCFG(0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0),
+		.dmars		= DMARS(0x2, 0x40),
+	},
+};
+
+static const struct rza1_dma_pdata dma_pdata __initconst = {
+	.slave		= rza1_dma_slaves,
+	.slave_num	= ARRAY_SIZE(rza1_dma_slaves),
+	.channel_num	= 16,
+};
+
+static const struct resource rza1_dma_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8200000, 0x1000),
+	DEFINE_RES_MEM(0xfcfe1000, 0x1000),
+	DEFINE_RES_NAMED(gic_iid(41), 16, NULL, IORESOURCE_IRQ),
+	DEFINE_RES_IRQ(gic_iid(57)),	/* DMAERR */
+};
+
+static const struct platform_device_info dma_info  __initconst = {
+	.name		= "rza1-dma",
+	.id		= -1,
+	.res		= rza1_dma_resources,
+	.num_res	= ARRAY_SIZE(rza1_dma_resources),
+	.data		= &dma_pdata,
+	.size_data	= sizeof(dma_pdata),
+};
+
+/* Video */
+#define	P1CLK			((13330000 * 30) / 6)
+#define	PIXCLOCK(hz, div)	\
+	(u32)(1000000000000 / ((double)(hz) / (double)(div)))
+
+struct pfc_pinmux_assign {
+	int port;	/* enum */
+	int mode;	/* enum */
+	int opts;
+};
+
+static struct pfc_pinmux_assign lcd0_common[] = {
+	{ P11_15, ALT5, },	/* LCD0_CLK */
+	{ P11_7,  ALT5, },	/* LCD0_DATA0 */
+	{ P11_6,  ALT5, },	/* LCD0_DATA1 */
+	{ P11_5,  ALT5, },	/* LCD0_DATA2 */
+	{ P11_4,  ALT5, },	/* LCD0_DATA3 */
+	{ P11_3,  ALT5, },	/* LCD0_DATA4 */
+	{ P11_2,  ALT5, },	/* LCD0_DATA5 */
+	{ P11_1,  ALT5, },	/* LCD0_DATA6 */
+	{ P11_0,  ALT5, },	/* LCD0_DATA7 */
+	{ P10_15, ALT5, },	/* LCD0_DATA8 */
+	{ P10_14, ALT5, },	/* LCD0_DATA9 */
+	{ P10_13, ALT5, },	/* LCD0_DATA10 */
+	{ P10_12, ALT5, },	/* LCD0_DATA11 */
+	{ P10_11, ALT5, },	/* LCD0_DATA12 */
+	{ P10_10, ALT5, },	/* LCD0_DATA13 */
+	{ P10_9,  ALT5, },	/* LCD0_DATA14 */
+	{ P10_8,  ALT5, },	/* LCD0_DATA15 */
+	{ P10_7,  ALT5, },	/* LCD0_DATA16 */
+	{ P10_6,  ALT5, },	/* LCD0_DATA17 */
+	{ P10_5,  ALT5, },	/* LCD0_DATA18 */
+	{ P10_4,  ALT5, },	/* LCD0_DATA19 */
+	{ P10_3,  ALT5, },	/* LCD0_DATA20 */
+	{ P10_2,  ALT5, },	/* LCD0_DATA21 */
+	{ P10_1,  ALT5, },	/* LCD0_DATA22 */
+	{ P10_0,  ALT5, },	/* LCD0_DATA23 */
+};
+
+static struct pfc_pinmux_assign lcd0_tcon[] = {
+	{ P11_14, ALT5, },	/* LCD0_TCON0 */
+	{ P11_13, ALT5, },	/* LCD0_TCON1 */
+	{ P11_12, ALT5, },	/* LCD0_TCON2 */
+	{ P11_11, ALT5, },	/* LCD0_TCON3 */
+	{ P11_10, ALT5, },	/* LCD0_TCON4 */
+	{ P11_9,  ALT5, },	/* LCD0_TCON5 */
+	{ P11_8,  ALT5, },	/* LCD0_TCON6 */
+};
+
+static void vdc5fb_pinmux(struct pfc_pinmux_assign *pf, size_t num)
+{
+	size_t n;
+
+	for (n = 0; n < num; pf++, n++)
+		r7s72100_pfc_pin_assign(pf->port, pf->mode, DIIO_PBDC_DIS);
+}
+
+static void vdc5fb_pinmux_tcon(struct pfc_pinmux_assign *pf, size_t num,
+	struct vdc5fb_pdata *pdata)
+{
+	size_t n;
+
+	for (n = 0; n < num; pf++, n++)
+		if (pdata->tcon_sel[n] != TCON_SEL_UNUSED)
+			r7s72100_pfc_pin_assign(pf->port, pf->mode, DIIO_PBDC_DIS);
+}
+
+#define VDC5_BPP 32 /* 16bpp or 32bpp */
+#define VDC5_FBSIZE (800*480*VDC5_BPP/8)
+#define VDC5_FB_ADDR (0x20A00000 - VDC5_FBSIZE)	/* Place at end of internal RAM */
+
+static const struct resource vdc5fb_resources[VDC5FB_NUM_RES] __initconst = {
+	[0] = DEFINE_RES_MEM_NAMED(0xfcff6000, 0x00002000, "vdc5fb.0: reg"),
+	[1] = DEFINE_RES_MEM_NAMED(VDC5_FB_ADDR, VDC5_FBSIZE, "vdc5fb.0: fb"),
+	[2] = DEFINE_RES_NAMED(75, 23, "vdc5fb.0: irq", IORESOURCE_IRQ),
+};
+
+static int vdc5fb_pinmux_gwp0700cnwv04(struct platform_device *pdev)
+{
+	struct vdc5fb_pdata *pdata
+	    = (struct vdc5fb_pdata *)pdev->dev.platform_data;
+
+	vdc5fb_pinmux(lcd0_common, ARRAY_SIZE(lcd0_common));
+	vdc5fb_pinmux_tcon(lcd0_tcon, ARRAY_SIZE(lcd0_tcon), pdata);
+
+	return 0;
+}
+
+static struct fb_videomode videomode_gwp0700cnwv04 = {
+	.name		= "gwp0700cnwv04",
+	.refresh	= 60,
+	.xres		= 800,
+	.yres		= 480,
+	.pixclock	= PIXCLOCK(P1CLK, 2),
+	.left_margin	= 210,
+	.right_margin	= 46,
+	.upper_margin	= 22,
+	.lower_margin	= 23,
+	.hsync_len	= 40,
+	.vsync_len	= 20,
+	.sync		= 0,
+	.vmode		= 0,
+	.flag		= 0,
+};
+
+static const struct vdc5fb_pdata vdc5fb_gwp0700cnwv04_pdata = {
+	.name			= "gwp0700cnwv04",
+	.videomode		= &videomode_gwp0700cnwv04,
+	.panel_icksel		= ICKSEL_P1CLK,
+	.bpp			= VDC5_BPP,
+	.panel_width		= 154,	/* mm, unused */
+	.panel_height		= 86,	/* mm, unused */
+	.flm_max		= 1,
+	.out_format		= OUT_FORMAT_RGB888,
+	.use_lvds		= 0,
+	.tcon_sel		= {
+		[LCD_TCON0]	= TCON_SEL_UNUSED,	/* MODE */
+		[LCD_TCON1]	= TCON_SEL_UNUSED,	/* DITH */
+		[LCD_TCON2]	= TCON_SEL_DE,		/* RGB_EN */
+		[LCD_TCON3]	= TCON_SEL_STH,		/* RGB_HSYNC */
+		[LCD_TCON4]	= TCON_SEL_STVA,	/* RGB_VSYNC */
+		[LCD_TCON5]	= TCON_SEL_UNUSED,	/* LR_INV */
+		[LCD_TCON6]	= TCON_SEL_UNUSED,	/* UD_INV */
+	},
+	.pinmux			= vdc5fb_pinmux_gwp0700cnwv04,
+};
+
+static const struct platform_device_info vdc5fb_info __initconst = {
+	.name		= "vdc5fb",
+	.id		= 0,
+	.res		= vdc5fb_resources,
+	.num_res	= ARRAY_SIZE(vdc5fb_resources),
+	.data		= &vdc5fb_gwp0700cnwv04_pdata,
+	.size_data	= sizeof(vdc5fb_gwp0700cnwv04_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),	/* only needed if not hardcoding fb */
+};
+
+/* JCU */
+static const struct uio_info jcu_platform_pdata __initconst = {
+	.name = "JCU",
+	.version = "0",
+	.irq = 126, /* Not used */
+};
+
+static const struct resource jcu_resources[] __initconst = {
+	DEFINE_RES_MEM_NAMED(0xe8017000, 0x1000, "jcu:reg"), /* for JCU of RZ */
+	DEFINE_RES_MEM_NAMED(0xfcfe0000, 0x2000, "jcu:rstreg clkreg"), /* Use STBCR6 & SWRSTCR2 */
+	DEFINE_RES_MEM_NAMED(0x20200000, 0x100000, "jcu:iram"), /* (Non cacheable 1MB) */
+};
+
+static const struct platform_device_info jcu_info __initconst = {
+	.name		= "uio_pdrv_genirq",
+	.id		= 0,
+	.data		= &jcu_platform_pdata,
+	.size_data	= sizeof(jcu_platform_pdata),
+	.res		= jcu_resources,
+	.num_res	= ARRAY_SIZE(jcu_resources),
+};
+
+/* Ether */
+static const struct sh_eth_plat_data ether_pdata __initconst = {
+	.phy			= 0x00, /* PD60610 */
+	.edmac_endian		= EDMAC_LITTLE_ENDIAN,
+	.phy_interface		= PHY_INTERFACE_MODE_MII,
+	.no_ether_link		= 1
+};
+
+static const struct resource ether_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8203000, 0x800),
+	DEFINE_RES_MEM(0xe8204800, 0x200),
+	DEFINE_RES_IRQ(gic_iid(359)),
+};
+
+static const struct platform_device_info ether_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "r7s72100-ether",
+	.id		= -1,
+	.res		= ether_resources,
+	.num_res	= ARRAY_SIZE(ether_resources),
+	.data		= &ether_pdata,
+	.size_data	= sizeof(ether_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* I2C0*/
+static const struct resource riic0_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfcfee000, 0x400),
+	DEFINE_RES_IRQ(gic_iid(189)),
+	DEFINE_RES_NAMED(gic_iid(190),1,NULL,IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
+	DEFINE_RES_NAMED(gic_iid(191),1,NULL,IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
+	DEFINE_RES_IRQ(gic_iid(192)),
+	DEFINE_RES_IRQ(gic_iid(193)),
+	DEFINE_RES_IRQ(gic_iid(194)),
+	DEFINE_RES_IRQ(gic_iid(195)),
+	DEFINE_RES_IRQ(gic_iid(196)),
+};
+
+static const struct riic_platform_data riic0_pdata __initconst = {
+	.bus_rate = 100,
+};
+
+static const struct platform_device_info riic0_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "i2c-riic",
+	.id		= 0,
+	.res		= riic0_resources,
+	.num_res	= ARRAY_SIZE(riic0_resources),
+	.data		= &riic0_pdata,
+	.size_data	= sizeof(riic0_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* I2C1*/
+static const struct resource riic1_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfcfee400, 0x400),
+	DEFINE_RES_IRQ(gic_iid(197)),
+	DEFINE_RES_NAMED(gic_iid(198),1,NULL,IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
+	DEFINE_RES_NAMED(gic_iid(199),1,NULL,IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
+	DEFINE_RES_IRQ(gic_iid(200)),
+	DEFINE_RES_IRQ(gic_iid(201)),
+	DEFINE_RES_IRQ(gic_iid(202)),
+	DEFINE_RES_IRQ(gic_iid(203)),
+	DEFINE_RES_IRQ(gic_iid(204)),
+};
+
+static const struct riic_platform_data riic1_pdata __initconst = {
+	.bus_rate = 100,
+};
+
+static const struct platform_device_info riic1_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "i2c-riic",
+	.id		= 1,
+	.res		= riic1_resources,
+	.num_res	= ARRAY_SIZE(riic1_resources),
+	.data		= &riic1_pdata,
+	.size_data	= sizeof(riic1_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+static const struct resource riic2_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfcfee800, 0x400),
+	DEFINE_RES_IRQ(gic_iid(205)),
+	DEFINE_RES_NAMED(gic_iid(206),1,NULL,IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
+	DEFINE_RES_NAMED(gic_iid(207),1,NULL,IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
+	DEFINE_RES_IRQ(gic_iid(208)),
+	DEFINE_RES_IRQ(gic_iid(209)),
+	DEFINE_RES_IRQ(gic_iid(210)),
+	DEFINE_RES_IRQ(gic_iid(211)),
+	DEFINE_RES_IRQ(gic_iid(212)),
+};
+
+static const struct riic_platform_data riic2_pdata __initconst = {
+	.bus_rate = 100,
+};
+
+static const struct platform_device_info riic2_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "i2c-riic",
+	.id		= 2,
+	.res		= riic2_resources,
+	.num_res	= ARRAY_SIZE(riic2_resources),
+	.data		= &riic2_pdata,
+	.size_data	= sizeof(riic2_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+static const struct resource riic3_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfcfeec00, 0x400),
+	DEFINE_RES_IRQ(gic_iid(213)),
+	DEFINE_RES_NAMED(gic_iid(214),1,NULL,IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
+	DEFINE_RES_NAMED(gic_iid(215),1,NULL,IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
+	DEFINE_RES_IRQ(gic_iid(216)),
+	DEFINE_RES_IRQ(gic_iid(217)),
+	DEFINE_RES_IRQ(gic_iid(218)),
+	DEFINE_RES_IRQ(gic_iid(219)),
+	DEFINE_RES_IRQ(gic_iid(220)),
+};
+
+static const struct riic_platform_data riic3_pdata __initconst = {
+	.bus_rate = 100,
+};
+
+static const struct platform_device_info riic3_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "i2c-riic",
+	.id		= 3,
+	.res		= riic3_resources,
+	.num_res	= ARRAY_SIZE(riic3_resources),
+	.data		= &riic3_pdata,
+	.size_data	= sizeof(riic3_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+static struct edt_ft5x06_platform_data ft5216_pdata __initdata = {
+	.irq_pin	= -1,
+	.reset_pin	= -1,
+
+	/* startup defaults for operational parameters */
+//	bool use_parameters;
+//	u8 gain;
+//	u8 threshold;
+//	u8 offset;
+//	u8 report_rate;
+};
+
+
+static const struct i2c_board_info i2c0_devices[] __initconst = {
+	{
+		I2C_BOARD_INFO("ft5x06-ts", 0x38),
+		.platform_data = &ft5216_pdata,
+		.irq		= 33,
+	},
+};
+
+/* Init TC_IRQ1 as input */
+static void __init gpio_irq_init(void) {
+	/* Set for low edge trigger */
+	void __iomem *irc1 = IOMEM(0xfcfef802);
+	__raw_writew((__raw_readw(irc1) & ~(0x3 << 2)), irc1);
+	r7s72100_pfc_pin_assign(P4_9, ALT8, DIIO_PBDC_DIS);  /* IRQ1 */
+}
+
+static struct at24_platform_data eeprom_pdata = {
+	.byte_len = 2048,
+	.page_size = 16,
+};
+
+static const struct i2c_board_info i2c3_devices[] __initconst = {
+	{
+		I2C_BOARD_INFO("max9856", 0x10),
+	},
+	{
+		I2C_BOARD_INFO("at24", 0x50),
+		.platform_data = &eeprom_pdata,
+	},
+};
+
+/* OSTM */
+static struct rza1_ostm_pdata ostm_pdata = {
+	.clksrc.name = "ostm.0",
+	.clksrc.rating = 300,
+	.clkevt.name = "ostm.1",
+	.clkevt.rating = 300,
+};
+
+static const struct resource ostm_resources[] __initconst = {
+	[0] = DEFINE_RES_MEM_NAMED(0xfcfec000, 0x030, "ostm.0"),
+	[1] = DEFINE_RES_MEM_NAMED(0xfcfec400, 0x030, "ostm.1"),
+	[2] = DEFINE_RES_IRQ_NAMED(134, "ostm.0"),
+	[3] = DEFINE_RES_IRQ_NAMED(135, "ostm.1"),
+};
+
+static const struct platform_device_info ostm_info __initconst = {
+	.name		= "ostm",
+	.id		= 0,
+	.data 		= &ostm_pdata,
+	.size_data	= sizeof(ostm_pdata),
+	.res		= ostm_resources,
+	.num_res	= ARRAY_SIZE(ostm_resources),
+};
+
+/* RTC */
+static const struct resource rtc_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfcff1000, 0x2e),
+	DEFINE_RES_IRQ(gic_iid(309)),	/* Period IRQ */
+	DEFINE_RES_IRQ(gic_iid(310)),	/* Carry IRQ */
+	DEFINE_RES_IRQ(gic_iid(308)),	/* Alarm IRQ */
+};
+
+static const struct platform_device_info rtc_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "sh-rtc",
+	.id		= -1,
+	.res		= rtc_resources,
+	.num_res	= ARRAY_SIZE(rtc_resources),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* NOR Flash */
+static struct mtd_partition nor_flash_partitions[] __initdata = {
+	{
+		.name		= "nor_u-boot",
+		.offset		= 0x00000000,
+		.size		= SZ_512K,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	{
+		.name		= "nor_u-boot_env",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_256K,
+	},
+	{
+		.name		= "nor_dtb",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_256K,
+	},
+	{
+		.name		= "nor_kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_4M,
+	},
+	{
+		.name		= "nor_data",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+static const struct physmap_flash_data nor_flash_data __initconst = {
+	.width		= 2,
+	.parts		= nor_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
+};
+
+static const struct resource nor_flash_resources[] __initconst = {
+	DEFINE_RES_MEM(0x00000000, SZ_64M),
+};
+
+static const struct platform_device_info nor_flash_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "physmap-flash",
+	.id		= 1,
+	.res		= nor_flash_resources,
+	.num_res	= ARRAY_SIZE(nor_flash_resources),
+	.data		= &nor_flash_data,
+	.size_data	= sizeof(nor_flash_data),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* SPI NOR Flash */
+/* Single Flash only */
+static struct mtd_partition spibsc0_flash_partitions[] = {
+	{
+		.name		= "spibsc0_loader",
+		.offset		= 0x00000000,
+		.size		= 0x00080000,
+		/* .mask_flags	= MTD_WRITEABLE, */
+	},
+	{
+		.name		= "spibsc0_bootenv",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00040000,
+	},
+	{
+		.name		= "spibsc0_kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00400000,
+	},
+	{
+		.name		= "spibsc0_rootfs",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct mtd_partition spibsc1_flash_partitions[] = {
+	{
+		.name		= "spibsc1_data",
+		.offset		= 0x00000000,
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct flash_platform_data spibsc0_flash_pdata = {
+	.name	= "m25p80",
+	.parts	= spibsc0_flash_partitions,
+	.nr_parts = ARRAY_SIZE(spibsc0_flash_partitions),
+	.type = "s25fl512s",
+};
+
+static struct flash_platform_data spibsc1_flash_pdata = {
+	.name	= "m25p80",
+	.parts	= spibsc1_flash_partitions,
+	.nr_parts = ARRAY_SIZE(spibsc1_flash_partitions),
+	.type = "s25fl512s",
+};
+
+/* QSPI Flash (Memory Map Mode, read only) */
+/* Dual Flash */
+static struct mtd_partition qspi_flash_partitions[] __initdata = {
+	{
+		.name		= "qspi_rootfs",
+		.offset		= 0x00800000,
+		.size		= 64 * SZ_1M - 0x00800000,
+	},
+};
+
+static const struct physmap_flash_data qspi_flash_data __initconst = {
+	.width		= 4,
+	.probe_type	= "map_rom",
+	.parts		= qspi_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(qspi_flash_partitions),
+};
+
+static const struct resource qspi_flash_resources[] __initconst = {
+	DEFINE_RES_MEM(0x18000000, SZ_64M),
+};
+
+static const struct platform_device_info qspi_flash_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "physmap-flash",
+	.id		= 0,
+	.res		= qspi_flash_resources,
+	.num_res	= ARRAY_SIZE(qspi_flash_resources),
+	.data		= &qspi_flash_data,
+	.size_data	= sizeof(qspi_flash_data),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* PWM Pin (Pin TIOC4A only) */
+/* RSKRZA1 does not have TIOC4A attached to anything */
+#if 0
+static const struct resource pwm_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfcff0200, 0x4c),	/* mtu2_3,4 */
+	DEFINE_RES_MEM(0xfcff0280, 0x6),	/* mtu2 share regs */
+};
+
+static const struct platform_device_info pwm0_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "rza1-pwm",
+	.id		= 0,
+	.res		= pwm_resources,
+	.num_res	= ARRAY_SIZE(pwm_resources),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* Backlight */
+static struct platform_pwm_backlight_data pwm_backlight_pdata = {
+	.max_brightness = 255,
+	.dft_brightness = 255,
+	.pwm_period_ns = 33333, /* 30kHz */
+	.enable_gpio = -1,
+};
+
+static struct pwm_lookup pwm_lookup[] = {
+	PWM_LOOKUP("rza1-pwm.0", 0, "pwm-backlight.0", NULL),
+};
+
+static const struct platform_device_info pwm_backlight_info __initconst = {
+	.name		= "pwm-backlight",
+	.data		= &pwm_backlight_pdata,
+	.size_data	= sizeof(pwm_backlight_pdata),
+};
+#endif
+
+/* RSPI */
+#define RSPI_RESOURCE(idx, baseaddr, irq)				\
+static const struct resource rspi##idx##_resources[] __initconst = {	\
+	DEFINE_RES_MEM(baseaddr, 0x24),					\
+	DEFINE_RES_IRQ_NAMED(irq, "error"),				\
+	DEFINE_RES_IRQ_NAMED(irq + 1, "rx"),				\
+	DEFINE_RES_IRQ_NAMED(irq + 2, "tx"),				\
+}
+
+RSPI_RESOURCE(0, 0xe800c800, gic_iid(270));
+RSPI_RESOURCE(1, 0xe800d000, gic_iid(273));
+RSPI_RESOURCE(2, 0xe800d800, gic_iid(276));
+RSPI_RESOURCE(3, 0xe800e000, gic_iid(279));
+RSPI_RESOURCE(4, 0xe800e800, gic_iid(282));
+
+static const struct rspi_plat_data rspi_pdata __initconst = {
+	.num_chipselect	= 1,
+};
+
+#define r7s72100_register_rspi(idx)					   \
+	platform_device_register_resndata(&platform_bus, "rspi-rz", idx,   \
+					rspi##idx##_resources,		   \
+					ARRAY_SIZE(rspi##idx##_resources), \
+					&rspi_pdata, sizeof(rspi_pdata))
+
+
+static struct spi_board_info rskrza1_spi_devices[] __initdata = {
+#if (defined CONFIG_SPI_RSPI) && !(defined CONFIG_SH_ETH)
+	{
+		/* spidev */
+		.modalias		= "spidev",
+		.max_speed_hz           = 5000000,
+		.bus_num                = 4,
+		.chip_select            = 0,
+		.mode			= SPI_MODE_3,
+	},
+#endif
+	{
+		/* SPI Flash0 */
+		.modalias = "m25p80",
+		.bus_num = 5,
+		.chip_select = 0,
+		.platform_data = &spibsc0_flash_pdata,
+	},
+	{
+		/* SPI Flash1 */
+		.modalias = "m25p80",
+		.bus_num = 6,
+		.chip_select = 0,
+		.platform_data = &spibsc1_flash_pdata,
+	},
+};
+
+/* spibsc0 */
+static const struct sh_spibsc_info spibsc0_pdata = {
+	.bus_num	= 5,
+};
+
+static const struct resource spibsc0_resources[] __initconst = {
+	DEFINE_RES_MEM(0x3fefa000, 0x100),
+};
+
+static const struct platform_device_info spibsc0_info __initconst = {
+	.name		= "spibsc",
+	.id		= 0,
+	.data 		= &spibsc0_pdata,
+	.size_data	= sizeof(spibsc0_pdata),
+	.num_res	= ARRAY_SIZE(spibsc0_resources),
+	.res		= spibsc0_resources,
+};
+
+/* spibsc1 */
+static const struct sh_spibsc_info spibsc1_pdata = {
+	.bus_num	= 6,
+};
+
+static const struct resource spibsc1_resources[] __initconst = {
+	DEFINE_RES_MEM(0x3fefb000, 0x100),
+};
+
+static const struct platform_device_info spibsc1_info __initconst = {
+	.name		= "spibsc",
+	.id		= 1,
+	.data 		= &spibsc1_pdata,
+	.size_data	= sizeof(spibsc1_pdata),
+	.num_res	= ARRAY_SIZE(spibsc1_resources),
+	.res		= spibsc1_resources,
+};
+
+/* ADC */
+static const struct resource adc0_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8005800, 0x100),
+	DEFINE_RES_MEM(0xfcff0280, 0x6),
+	DEFINE_RES_MEM(0xfcff0380, 0x21),
+	DEFINE_RES_IRQ(gic_iid(170)),
+	DEFINE_RES_IRQ(gic_iid(171)),
+	DEFINE_RES_IRQ(gic_iid(146)),
+};
+
+static const struct sh_adc_data adc0_pdata __initconst = {
+	.num_channels = 8,
+	.mtu2_ch = 1,
+};
+
+static const struct platform_device_info adc0_info __initconst = {
+	.name	= "sh_adc",
+	.id	= 0,
+	.data		= &adc0_pdata,
+	.size_data	= sizeof(adc0_pdata),
+	.res		= adc0_resources,
+	.num_res	= ARRAY_SIZE(adc0_resources),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* MMCIF */
+static const struct resource sh_mmcif_resources[] __initconst = {
+	DEFINE_RES_MEM_NAMED(0xe804c800, 0x100, "MMCIF"),
+	DEFINE_RES_IRQ(gic_iid(300)),
+	DEFINE_RES_IRQ(gic_iid(301)),
+};
+
+static const struct sh_mmcif_plat_data sh_mmcif_pdata __initconst = {
+	.sup_pclk	= 0,
+	.ccs_unsupported = true,
+	.ocr		= MMC_VDD_32_33,
+	.caps		= MMC_CAP_4_BIT_DATA |
+			  MMC_CAP_8_BIT_DATA |
+			  MMC_CAP_NONREMOVABLE,
+};
+
+static const struct platform_device_info mmc_info __initconst = {
+	.name		= "sh_mmcif",
+	.id		= -1,
+	.res		= sh_mmcif_resources,
+	.num_res	= ARRAY_SIZE(sh_mmcif_resources),
+	.data		= &sh_mmcif_pdata,
+	.size_data	= sizeof(sh_mmcif_pdata),
+};
+
+/* SDHI0 */
+static struct sh_mobile_sdhi_info sdhi0_pdata = {
+	.dma_slave_tx	= RZA1DMA_SLAVE_SDHI0_TX,
+	.dma_slave_rx	= RZA1DMA_SLAVE_SDHI0_RX,
+	.tmio_caps	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ,
+	.tmio_ocr_mask	= MMC_VDD_32_33,
+	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT,
+};
+
+static const struct resource sdhi0_resources[] __initconst = {
+	DEFINE_RES_MEM_NAMED(0xe804e000, 0x100, "SDHI0"),
+	DEFINE_RES_IRQ_NAMED(gic_iid(302), SH_MOBILE_SDHI_IRQ_CARD_DETECT),
+	DEFINE_RES_IRQ_NAMED(gic_iid(303), SH_MOBILE_SDHI_IRQ_SDCARD),
+	DEFINE_RES_IRQ_NAMED(gic_iid(304), SH_MOBILE_SDHI_IRQ_SDIO),
+};
+
+static const struct platform_device_info sdhi0_info __initconst = {
+	.name		= "sh_mobile_sdhi",
+	.id		= 0,
+	.res		= sdhi0_resources,
+	.num_res	= ARRAY_SIZE(sdhi0_resources),
+	.data		= &sdhi0_pdata,
+	.size_data	= sizeof(sdhi0_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* SDHI1 */
+static struct sh_mobile_sdhi_info sdhi1_pdata = {
+	.dma_slave_tx	= RZA1DMA_SLAVE_SDHI1_TX,
+	.dma_slave_rx	= RZA1DMA_SLAVE_SDHI1_RX,
+	.tmio_caps	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ,
+	.tmio_ocr_mask	= MMC_VDD_32_33,
+	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT,
+};
+
+static const struct resource sdhi1_resources[] __initconst = {
+	DEFINE_RES_MEM_NAMED(0xe804e800, 0x100, "SDHI1"),
+	DEFINE_RES_IRQ_NAMED(gic_iid(305), SH_MOBILE_SDHI_IRQ_CARD_DETECT),
+	DEFINE_RES_IRQ_NAMED(gic_iid(306), SH_MOBILE_SDHI_IRQ_SDCARD),
+	DEFINE_RES_IRQ_NAMED(gic_iid(307), SH_MOBILE_SDHI_IRQ_SDIO),
+};
+
+static const struct platform_device_info sdhi1_info __initconst = {
+	.name		= "sh_mobile_sdhi",
+	.id		= 1,
+	.res		= sdhi1_resources,
+	.num_res	= ARRAY_SIZE(sdhi1_resources),
+	.data		= &sdhi1_pdata,
+	.size_data	= sizeof(sdhi1_pdata),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+/* USB Host */
+static const struct r8a66597_platdata r8a66597_pdata __initconst = {
+	.endian = 0,
+	.on_chip = 1,
+	.xtal = R8A66597_PLATDATA_XTAL_48MHZ,
+};
+
+static const struct resource r8a66597_usb_host0_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8010000, 0x1a0),
+	DEFINE_RES_IRQ(gic_iid(73)),
+};
+
+static const struct platform_device_info r8a66597_usb_host0_info __initconst= {
+	.name		= "r8a66597_hcd",
+	.id		= 0,
+	.data		= &r8a66597_pdata,
+	.size_data	= sizeof(r8a66597_pdata),
+	.res		= r8a66597_usb_host0_resources,
+	.num_res	= ARRAY_SIZE(r8a66597_usb_host0_resources),
+};
+
+static const struct resource r8a66597_usb_host1_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8207000, 0x1a0),
+	DEFINE_RES_IRQ(gic_iid(74)),
+};
+
+static const struct platform_device_info r8a66597_usb_host1_info __initconst = {
+	.name		= "r8a66597_hcd",
+	.id		= 1,
+	.data		= &r8a66597_pdata,
+	.size_data	= sizeof(r8a66597_pdata),
+	.res		= r8a66597_usb_host1_resources,
+	.num_res	= ARRAY_SIZE(r8a66597_usb_host1_resources),
+};
+
+/* USB Gadget */
+static const struct r8a66597_platdata r8a66597_usb_gadget0_pdata __initconst = {
+	.endian = 0,
+	.on_chip = 1,
+	.xtal = R8A66597_PLATDATA_XTAL_48MHZ,
+};
+
+static const struct resource r8a66597_usb_gadget0_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8010000, 0x1a0),
+	DEFINE_RES_IRQ(gic_iid(73)),
+};
+
+static const struct platform_device_info r8a66597_usb_gadget0_info __initconst = {
+	.name		= "r8a66597_udc",
+	.id		= 0,
+	.data		= &r8a66597_usb_gadget0_pdata,
+	.size_data	= sizeof(r8a66597_usb_gadget0_pdata),
+	.res		= r8a66597_usb_gadget0_resources,
+	.num_res	= ARRAY_SIZE(r8a66597_usb_gadget0_resources),
+};
+
+static const struct r8a66597_platdata r8a66597_usb_gadget1_pdata __initconst = {
+	.endian = 0,
+	.on_chip = 1,
+	.xtal = R8A66597_PLATDATA_XTAL_48MHZ,
+};
+
+static const struct resource r8a66597_usb_gadget1_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe8207000, 0x1a0),
+	DEFINE_RES_IRQ(gic_iid(74)),
+};
+
+static const struct platform_device_info r8a66597_usb_gadget1_info __initconst = {
+	.name		= "r8a66597_udc",
+	.id		= 1,
+	.data		= &r8a66597_usb_gadget1_pdata,
+	.size_data	= sizeof(r8a66597_usb_gadget1_pdata),
+	.res		= r8a66597_usb_gadget1_resources,
+	.num_res	= ARRAY_SIZE(r8a66597_usb_gadget1_resources),
+};
+
+/* Write to I2C device */
+/* stolen from board-sx1.c */
+int rza1_i2c_write_byte(u8 ch, u8 devaddr, u8 regoffset, u8 value)
+{
+	struct i2c_adapter *adap;
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	adap = i2c_get_adapter(ch);
+	if (!adap)
+		return -ENODEV;
+	msg->addr = devaddr;	/* I2C address of chip */
+	msg->flags = 0;
+	msg->len = 2;
+	msg->buf = data;
+	data[0] = regoffset;	/* register num */
+	data[1] = value;		/* register data */
+	err = i2c_transfer(adap, msg, 1);
+	i2c_put_adapter(adap);
+	if (err >= 0)
+		return 0;
+	return err;
+}
+
+/* Read from I2C device */
+/* stolen from board-sx1.c */
+int rza1_i2c_read_byte(u8 ch, u8 devaddr, u8 regoffset, u8 *value)
+{
+	struct i2c_adapter *adap;
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	adap = i2c_get_adapter(ch);
+	if (!adap)
+		return -ENODEV;
+
+	msg->addr = devaddr;	/* I2C address of chip */
+	msg->flags = 0;
+	msg->len = 1;
+	msg->buf = data;
+	data[0] = regoffset;	/* register num */
+	err = i2c_transfer(adap, msg, 1);
+
+	msg->addr = devaddr;	/* I2C address */
+	msg->flags = I2C_M_RD;
+	msg->len = 1;
+	msg->buf = data;
+	err = i2c_transfer(adap, msg, 1);
+	*value = data[0];
+	i2c_put_adapter(adap);
+
+	if (err >= 0)
+		return 0;
+	return err;
+}
+
+/* Audio */
+static const struct platform_device_info alsa_soc_info = {
+	.name		= "rskrza1_alsa_soc_platform",
+	.id		= 0,
+};
+
+static const struct resource scux_resources[] __initconst = {
+	[0] = DEFINE_RES_MEM_NAMED(0xe8208000, 0x00001778, "scux"),
+	[1] = DEFINE_RES_MEM_NAMED(0xe820b000, 0x00002830, "ssif0"),
+};
+
+static struct scu_config ssi_ch_value[] = {
+	{RP_MEM_SSI0,		SSI0},
+	{RP_MEM_SRC1_SSI0,	SSI0},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI0},
+	{RC_SSI0_MEM,		SSI0},
+	{RC_SSI0_SRC0_MEM,	SSI0},
+};
+
+static struct scu_config src_ch_value[] = {
+	{RP_MEM_SSI0,		-1},
+	{RP_MEM_SRC1_SSI0,	SRC1},
+	{RP_MEM_SRC1_DVC1_SSI0,	SRC1},
+	{RC_SSI0_MEM,		-1},
+	{RC_SSI0_SRC0_MEM,	SRC0},
+};
+
+static struct scu_config dvc_ch_value[] = {
+	{RP_MEM_SSI0,		-1},
+	{RP_MEM_SRC1_SSI0,	-1},
+	{RP_MEM_SRC1_DVC1_SSI0,	DVC1},
+	{RC_SSI0_MEM,		-1},
+	{RC_SSI0_SRC0_MEM,	-1},
+};
+
+static struct scu_config audma_slave_value[] = {
+	{RP_MEM_SSI0,		RZA1DMA_SLAVE_PCM_MEM_SSI0},
+	{RP_MEM_SRC1_SSI0,	RZA1DMA_SLAVE_PCM_MEM_SRC1},
+	{RP_MEM_SRC1_DVC1_SSI0,	RZA1DMA_SLAVE_PCM_MEM_SRC1},
+	{RC_SSI0_MEM,		RZA1DMA_SLAVE_PCM_SSI0_MEM},
+	{RC_SSI0_SRC0_MEM,	RZA1DMA_SLAVE_PCM_SRC0_MEM},
+};
+
+static struct scu_config ssi_depend_value[] = {
+	{RP_MEM_SSI0,		SSI_INDEPENDANT},
+	{RP_MEM_SRC1_SSI0,	SSI_DEPENDANT},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI_DEPENDANT},
+	{RC_SSI0_MEM,		SSI_INDEPENDANT},
+	{RC_SSI0_SRC0_MEM,	SSI_DEPENDANT},
+};
+
+static struct scu_config ssi_mode_value[] = {
+	{RP_MEM_SSI0,		SSI_MASTER},
+	{RP_MEM_SRC1_SSI0,	SSI_MASTER},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI_MASTER},
+	{RC_SSI0_MEM,		SSI_SLAVE},
+	{RC_SSI0_SRC0_MEM,	SSI_SLAVE},
+};
+
+static struct scu_config src_mode_value[] = {
+	{RP_MEM_SSI0,		SRC_CR_ASYNC},
+	{RP_MEM_SRC1_SSI0,	SRC_CR_ASYNC},
+	{RP_MEM_SRC1_DVC1_SSI0,	SRC_CR_ASYNC},
+	{RC_SSI0_MEM,		SRC_CR_ASYNC},
+	{RC_SSI0_SRC0_MEM,	SRC_CR_ASYNC},
+};
+
+static const struct scu_platform_data scu_pdata __initconst = {
+	.ssi_master		= SSI0,
+	.ssi_slave		= SSI0,
+	.ssi_ch			= ssi_ch_value,
+	.ssi_ch_num		= ARRAY_SIZE(ssi_ch_value),
+	.src_ch			= src_ch_value,
+	.src_ch_num		= ARRAY_SIZE(src_ch_value),
+	.dvc_ch			= dvc_ch_value,
+	.dvc_ch_num		= ARRAY_SIZE(dvc_ch_value),
+	.dma_slave_maxnum	= RZA1DMA_SLAVE_PCM_MAX,
+	.audma_slave		= audma_slave_value,
+	.audma_slave_num	= ARRAY_SIZE(audma_slave_value),
+	.ssi_depend		= ssi_depend_value,
+	.ssi_depend_num		= ARRAY_SIZE(ssi_depend_value),
+	.ssi_mode		= ssi_mode_value,
+	.ssi_mode_num		= ARRAY_SIZE(ssi_mode_value),
+	.src_mode		= src_mode_value,
+	.src_mode_num		= ARRAY_SIZE(src_mode_value),
+};
+
+static const struct platform_device_info scux_info __initconst = {
+	.name		= "scux-pcm-audio",
+	.id		= 0,
+	.data		= &scu_pdata,
+	.size_data	= sizeof(scu_pdata),
+	.num_res	= ARRAY_SIZE(scux_resources),
+	.res		= scux_resources,
+};
+
+
+static void __init rskrza1_add_standard_devices(void)
+{
+#ifdef CONFIG_CACHE_L2X0
+	/* Early BRESP enable, 16K*8way(defualt) */
+	/* NOTES: BRESP can be set for IP version after r2p0 */
+	/*        As of linux-3.16, cache-l2x0.c handles this automatically */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,16,0)
+	l2x0_init(IOMEM(0xfffee000), 0x40000000, 0xffffffff);	/* Early BRESP enable */
+#else
+	l2x0_init(IOMEM(0xfffee000), 0x00000000, 0xffffffff);	/* Leave as defaults */
+#endif
+#endif
+	r7s72100_clock_init();
+	r7s72100_pinmux_setup();
+	r7s72100_add_dt_devices();
+
+	r7s72100_pfc_pin_assign(P1_15, ALT1, DIIO_PBDC_EN);	/* AD7 */
+	r7s72100_pfc_pin_assign(P1_0, ALT1, DIIO_PBDC_EN);	/* I2C SCL0 */
+	r7s72100_pfc_pin_assign(P1_1, ALT1, DIIO_PBDC_EN);	/* I2C SDA0 */
+
+	r7s72100_pfc_pin_assign(P4_4, ALT5, DIIO_PBDC_EN);	/* SSISCK0 */
+	r7s72100_pfc_pin_assign(P4_5, ALT5, DIIO_PBDC_EN);	/* SSIWS0 */
+	r7s72100_pfc_pin_assign(P4_6, ALT5, DIIO_PBDC_EN);	/* SSIRxD0 */
+	r7s72100_pfc_pin_assign(P4_7, ALT5, SWIO_OUT_PBDCEN);	/* SSITxD0 */
+
+#ifndef CONFIG_MMC_SDHI
+	r7s72100_pfc_pin_assign(P3_8, ALT8, DIIO_PBDC_DIS);	/* MMC CD */
+	r7s72100_pfc_pin_assign(P3_10, ALT8, DIIO_PBDC_DIS);	/* MMC DAT1 */
+	r7s72100_pfc_pin_assign(P3_11, ALT8, DIIO_PBDC_DIS);	/* MMC DAT0 */
+	r7s72100_pfc_pin_assign(P3_12, ALT8, DIIO_PBDC_DIS);	/* MMC CLK */
+	r7s72100_pfc_pin_assign(P3_13, ALT8, DIIO_PBDC_DIS);	/* MMC CMD */
+	r7s72100_pfc_pin_assign(P3_14, ALT8, DIIO_PBDC_DIS);	/* MMC DAT3*/
+	r7s72100_pfc_pin_assign(P3_15, ALT8, DIIO_PBDC_DIS);	/* MMC DAT2 */
+	r7s72100_pfc_pin_assign(P4_0, ALT8, DIIO_PBDC_DIS);	/* MMC DAT4 */
+	r7s72100_pfc_pin_assign(P4_1, ALT8, DIIO_PBDC_DIS);	/* MMC DAT5 */
+	r7s72100_pfc_pin_assign(P4_2, ALT8, DIIO_PBDC_DIS);	/* MMC DAT6*/
+	r7s72100_pfc_pin_assign(P4_3, ALT8, DIIO_PBDC_DIS);	/* MMC DAT7 */
+#else
+	r7s72100_pfc_pin_assign(P3_8, ALT7, DIIO_PBDC_DIS);	/* SDHI1 CD */
+	r7s72100_pfc_pin_assign(P3_9, ALT7, DIIO_PBDC_DIS);	/* SDHI1 WP */
+	r7s72100_pfc_pin_assign(P3_10, ALT7, DIIO_PBDC_EN);	/* SDHI1 DAT1 */
+	r7s72100_pfc_pin_assign(P3_11, ALT7, DIIO_PBDC_EN);	/* SDHI1 DAT0 */
+	r7s72100_pfc_pin_assign(P3_12, ALT7, DIIO_PBDC_DIS);	/* SDHI1 CLK */
+	r7s72100_pfc_pin_assign(P3_13, ALT7, DIIO_PBDC_EN);	/* SDHI1 CMD */
+	r7s72100_pfc_pin_assign(P3_14, ALT7, DIIO_PBDC_EN);	/* SDHI1 DAT3*/
+	r7s72100_pfc_pin_assign(P3_15, ALT7, DIIO_PBDC_EN);	/* SDHI1 DAT2 */
+#endif
+	gpio_irq_init();
+
+	i2c_register_board_info(0, i2c0_devices, ARRAY_SIZE(i2c0_devices));
+	i2c_register_board_info(3, i2c3_devices, ARRAY_SIZE(i2c3_devices));
+
+#ifndef CONFIG_XIP_KERNEL	/* TODO: Uses too much internal RAM */
+	platform_device_register_full(&jcu_info);
+#endif
+	platform_device_register_full(&ostm_info);
+	platform_device_register_full(&dma_info);
+	platform_device_register_full(&alsa_soc_info);
+	platform_device_register_full(&scux_info);
+	platform_device_register_full(&ether_info);
+	platform_device_register_full(&riic0_info);
+	platform_device_register_full(&riic1_info);
+	platform_device_register_full(&riic2_info);
+	platform_device_register_full(&riic3_info);
+	platform_device_register_full(&rtc_info);
+
+#if !defined(CONFIG_XIP_KERNEL) && defined(CONFIG_SPI_SH_SPIBSC)
+	/* Need to disable both spibsc channels if using memory mapped QSPI */
+	platform_device_register_full(&spibsc0_info);
+	platform_device_register_full(&spibsc1_info);
+#else
+	platform_device_register_full(&qspi_flash_info);
+#endif
+
+	platform_device_register_full(&nor_flash_info);
+#if 0 /* For refernce only */
+	platform_device_register_full(&pwm0_info);
+	platform_device_register_full(&pwm_backlight_info);
+	pwm_add_table(pwm_lookup, ARRAY_SIZE(pwm_lookup));
+#endif
+	platform_device_register_full(&adc0_info);
+	platform_device_register_full(&sdhi0_info);
+
+#ifndef CONFIG_MMC_SDHI
+	platform_device_register_full(&mmc_info);
+#else
+	platform_device_register_full(&sdhi1_info);
+#endif
+
+	platform_device_register_full(&vdc5fb_info);
+
+	if (usbgs == 0) {
+		platform_device_register_full(&r8a66597_usb_gadget0_info);
+		platform_device_register_full(&r8a66597_usb_host1_info);
+	} else if (usbgs == 1) {
+		platform_device_register_full(&r8a66597_usb_host0_info);
+		platform_device_register_full(&r8a66597_usb_gadget1_info);
+	} else {
+		platform_device_register_full(&r8a66597_usb_host0_info);
+		platform_device_register_full(&r8a66597_usb_host1_info);
+	}
+
+	r7s72100_register_rspi(0);
+	r7s72100_register_rspi(1);
+	r7s72100_register_rspi(2);
+	r7s72100_register_rspi(3);
+	r7s72100_register_rspi(4);
+
+	/* Register SPI device information */
+	spi_register_board_info(rskrza1_spi_devices,
+				ARRAY_SIZE(rskrza1_spi_devices));
+
+}
+
+static int heartbeat(void * data)
+{
+	u8 index = 0;
+	u8 value;
+	int ret;
+	static const u8 pattern[8] = {7,6,5,3,7,3,5,6};
+
+	while(1) {
+
+		/* Register address 1 is the Output Contorl register */
+		ret = rza1_i2c_read_byte(3, 0x20, 0x01, &value);
+		value &= ~0x7;
+		value |= pattern[index++];
+		index &= 0x7;
+
+		if( !ret )
+			rza1_i2c_write_byte(3, 0x20, 0x01, value);
+
+		msleep_interruptible(250);
+	}
+
+	return 0;
+}
+
+static void __init rskrza1_init_late(void)
+{
+#if 0
+	/* Turn on LED2 connected to the Port Expander */
+	{
+		u8 value;
+		int ret;
+		/* Register address 1 is the Output Contorl register */
+		ret = rza1_i2c_read_byte(3, 0x20, 0x01, &value);
+		value &= ~0x02;		/* bit 1 = L */
+		if( !ret )
+			rza1_i2c_write_byte(3, 0x20, 0x01, value);
+		printk("%s: LED2 is now on.\n",__func__);
+	}
+#endif
+
+	/* Make SCIF4 availible. */
+	/* Done here because we have to wait till i2c driver is ready */
+#if (defined CONFIG_SPI_RSPI) && !(defined CONFIG_SH_ETH)
+	{
+		int i;
+		u8 value;
+
+		/* Set P2_0-P2_11 and p3_3-p3_6 to input pins */
+		for (i=0;i<=11;i++)
+			r7s72100_pfc_pin_assign(P2_0+i, PMODE, DIR_IN);
+		for (i=3;i<=6;i++)
+			r7s72100_pfc_pin_assign(P3_0+i, PMODE, DIR_IN);
+
+		/* Set PX1_EN1 to 0 to disable Ethernet */
+		/* PX1_EN1 is controled through Port Expanders on I2C3 */
+		/* Register address 1 is the Output Control register */
+		i = rza1_i2c_read_byte(3, 0x21, 0x01, &value);
+		value &= ~0x02;		/* bit 1 = L */
+		if ( !i )
+			i = rza1_i2c_write_byte(3, 0x21, 0x01, value);
+		if ( !i ) {
+			/* Enable SPI4 pins */
+			/* RSKRZA1 Board SPI4 is on CN15 (but that means you can use Ethernet) */
+			r7s72100_pfc_pin_assign(P2_8, ALT8, DIIO_PBDC_EN);	/* RSPCK4 */
+			r7s72100_pfc_pin_assign(P2_9, ALT8, DIIO_PBDC_EN);	/* SSL40 */
+			r7s72100_pfc_pin_assign(P2_10, ALT8, DIIO_PBDC_EN);	/* MOSI4 */
+			r7s72100_pfc_pin_assign(P2_11, ALT8, DIIO_PBDC_EN);	/* MISO4 */
+		}
+		if( !i )
+			printk("%s: RSPI4 enabled on CN15\n",__func__);
+		else
+			printk("%s: ERROR: Failed to set pins for RSPI4 usage\n",__func__);
+	}
+#endif
+
+	/* Start heardbeat kernel thread */
+	kthread_run(heartbeat, NULL,"heartbeat");
+}
+
+
+static const char * const rskrza1_boards_compat_dt[] __initconst = {
+	"renesas,rskrza1",
+	NULL,
+};
+
+DT_MACHINE_START(RSKRZA1_DT, "rskrza1")
+	.init_early	= r7s72100_init_early,
+	.init_machine	= rskrza1_add_standard_devices,
+	.init_late	= rskrza1_init_late,
+	.dt_compat	= rskrza1_boards_compat_dt,
+	.map_io		= rza1_map_io,
+MACHINE_END
diff --git a/arch/arm/mach-shmobile/clock-r7s72100.c b/arch/arm/mach-shmobile/clock-r7s72100.c
index e6ab0cd..7b8459a 100644
--- a/arch/arm/mach-shmobile/clock-r7s72100.c
+++ b/arch/arm/mach-shmobile/clock-r7s72100.c
@@ -22,12 +22,20 @@
 #include <mach/common.h>
 #include <mach/r7s72100.h>
 
-/* registers */
+/* Frequency Control Registers */
 #define FRQCR		0xfcfe0010
 #define FRQCR2		0xfcfe0014
+/* Standby Control Registers */
 #define STBCR3		0xfcfe0420
 #define STBCR4		0xfcfe0424
+#define STBCR5		0xfcfe0428
+#define STBCR6		0xfcfe042c
+#define STBCR7		0xfcfe0430
+#define STBCR8		0xfcfe0434
 #define STBCR9		0xfcfe0438
+#define STBCR10		0xfcfe043c
+#define STBCR11		0xfcfe0440
+#define STBCR12		0xfcfe0444
 
 #define PLL_RATE 30
 
@@ -39,6 +47,7 @@ static struct clk_mapping cpg_mapping = {
 /* Fixed 32 KHz root clock for RTC */
 static struct clk r_clk = {
 	.rate           = 32768,
+	.mapping	= &cpg_mapping,
 };
 
 /*
@@ -67,7 +76,7 @@ static struct clk pll_clk = {
 
 static unsigned long bus_recalc(struct clk *clk)
 {
-	return clk->parent->rate * 2 / 3;
+	return clk->parent->rate / 3;
 }
 
 static struct sh_clk_ops bus_clk_ops = {
@@ -145,15 +154,61 @@ struct clk div4_clks[DIV4_NR] = {
 					| CLK_ENABLE_ON_INIT),
 };
 
-enum {	MSTP97, MSTP96, MSTP95, MSTP94,
+enum {
+	MSTP123, MSTP122, MSTP121, MSTP120,
+	MSTP115,
+	MSTP107, MSTP106, MSTP105, MSTP104, MSTP103,
+	MSTP97, MSTP96, MSTP95, MSTP94,
+	MSTP92, MSTP93,
+	MSTP91, MSTP90,
+	MSTP84, MSTP81, MSTP74,
+	MSTP71, MSTP70,
+	MSTP67, MSTP60,
+	MSTP51, MSTP50,
 	MSTP47, MSTP46, MSTP45, MSTP44, MSTP43, MSTP42, MSTP41, MSTP40,
-	MSTP33,	MSTP_NR };
+	MSTP33,	MSTP_NR
+};
 
 static struct clk mstp_clks[MSTP_NR] = {
+	[MSTP123] = SH_CLK_MSTP8(&peripheral1_clk, STBCR12, 3, 0), /* SDHI00 */
+	[MSTP122] = SH_CLK_MSTP8(&peripheral1_clk, STBCR12, 2,
+			CLK_ENABLE_ON_INIT),			   /* SDHI01 */
+	[MSTP121] = SH_CLK_MSTP8(&peripheral1_clk, STBCR12, 1, 0), /* SDHI10 */
+	[MSTP120] = SH_CLK_MSTP8(&peripheral1_clk, STBCR12, 0,
+			CLK_ENABLE_ON_INIT),			   /* SDHI11 */
+	[MSTP115] = SH_CLK_MSTP8(&peripheral0_clk, STBCR11, 5,
+			CLK_ENABLE_ON_INIT),			   /* SSIF0 */
+	[MSTP107] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 7, 0), /* RSPI0 */
+	[MSTP106] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 6, 0), /* RSPI1 */
+	[MSTP105] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 5, 0), /* RSPI2 */
+	[MSTP104] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 4, 0), /* RSPI3 */
+	[MSTP103] = SH_CLK_MSTP8(&peripheral1_clk, STBCR10, 3, 0), /* RSPI4 */
 	[MSTP97] = SH_CLK_MSTP8(&peripheral0_clk, STBCR9, 7, 0), /* RIIC0 */
 	[MSTP96] = SH_CLK_MSTP8(&peripheral0_clk, STBCR9, 6, 0), /* RIIC1 */
 	[MSTP95] = SH_CLK_MSTP8(&peripheral0_clk, STBCR9, 5, 0), /* RIIC2 */
 	[MSTP94] = SH_CLK_MSTP8(&peripheral0_clk, STBCR9, 4, 0), /* RIIC3 */
+#if 1 /* Keep SPIBSC0 and SPIBSC1 clocks always on */
+	/* Because this IP block can also be used without a driver, we don't
+	   want to register the clock souce because it might be shut off
+	   if the system thinks no driver is using it */
+	[MSTP93] = SH_CLK_MSTP8(&bus_clk, STBCR12, 7, 0), /* UNUSED REGISTER BIT */
+	[MSTP92] = SH_CLK_MSTP8(&bus_clk, STBCR12, 7, 0), /* UNUSED REGISTER BIT */
+#else
+	[MSTP93] = SH_CLK_MSTP8(&bus_clk, STBCR9, 3, 0), /* SPIBSC0 */
+	[MSTP92] = SH_CLK_MSTP8(&bus_clk, STBCR9, 2, 0), /* SPIBSC1 */
+#endif
+	[MSTP91] = SH_CLK_MSTP8(&peripheral1_clk, STBCR9, 1, 0), /* VDC5FB0 */
+	[MSTP90] = SH_CLK_MSTP8(&peripheral1_clk, STBCR9, 0, 0), /* VDC5FB1 */
+	[MSTP84] = SH_CLK_MSTP8(&peripheral1_clk, STBCR8, 4, 0),   /* MMC */
+	[MSTP81] = SH_CLK_MSTP8(&peripheral0_clk, STBCR8, 1,
+			CLK_ENABLE_ON_INIT),			   /* SCUX */
+	[MSTP74] = SH_CLK_MSTP8(&peripheral1_clk, STBCR7, 4, 0), /* Ether */
+	[MSTP71] = SH_CLK_MSTP8(&peripheral1_clk, STBCR7, 1, 0), /* USB0 */
+	[MSTP70] = SH_CLK_MSTP8(&peripheral1_clk, STBCR7, 0, 0), /* USB1 */
+	[MSTP67] = SH_CLK_MSTP8(&peripheral1_clk, STBCR6, 7, 0), /* ADC */
+	[MSTP60] = SH_CLK_MSTP8(&r_clk, STBCR6, 0, 0), /* RTC */
+	[MSTP51] = SH_CLK_MSTP8(&peripheral0_clk, STBCR5, 1, 0),   /* OSTM0 */
+	[MSTP50] = SH_CLK_MSTP8(&peripheral0_clk, STBCR5, 0, 0),   /* OSTM1 */
 	[MSTP47] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 7, 0), /* SCIF0 */
 	[MSTP46] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 6, 0), /* SCIF1 */
 	[MSTP45] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 5, 0), /* SCIF2 */
@@ -176,7 +231,35 @@ static struct clk_lookup lookups[] = {
 	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
 
 	/* MSTP clocks */
+	CLKDEV_DEV_ID("sh_mmcif", &mstp_clks[MSTP84]),
+	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[MSTP123]),
+	CLKDEV_DEV_ID("sh_mobile_sdhi.1", &mstp_clks[MSTP121]),
+	CLKDEV_CON_ID("ssif0", &mstp_clks[MSTP115]),
+	CLKDEV_DEV_ID("rspi-rz.0", &mstp_clks[MSTP107]),
+	CLKDEV_DEV_ID("rspi-rz.1", &mstp_clks[MSTP106]),
+	CLKDEV_DEV_ID("rspi-rz.2", &mstp_clks[MSTP105]),
+	CLKDEV_DEV_ID("rspi-rz.3", &mstp_clks[MSTP104]),
+	CLKDEV_DEV_ID("rspi-rz.4", &mstp_clks[MSTP103]),
+	CLKDEV_DEV_ID("spibsc.0", &mstp_clks[MSTP93]),
+	CLKDEV_DEV_ID("spibsc.1", &mstp_clks[MSTP92]),
+	CLKDEV_DEV_ID("i2c-riic.0", &mstp_clks[MSTP97]),
+	CLKDEV_DEV_ID("i2c-riic.1", &mstp_clks[MSTP96]),
+	CLKDEV_DEV_ID("i2c-riic.2", &mstp_clks[MSTP95]),
+	CLKDEV_DEV_ID("i2c-riic.3", &mstp_clks[MSTP94]),
+	CLKDEV_DEV_ID("vdc5fb.0", &mstp_clks[MSTP91]),
+	CLKDEV_DEV_ID("vdc5fb.1", &mstp_clks[MSTP90]),
+	CLKDEV_DEV_ID("r7s72100-ether", &mstp_clks[MSTP74]),
+	CLKDEV_DEV_ID("r8a66597_hcd.0", &mstp_clks[MSTP71]),
+	CLKDEV_DEV_ID("r8a66597_hcd.1", &mstp_clks[MSTP70]),
+	CLKDEV_DEV_ID("sh_adc.0", &mstp_clks[MSTP67]),
+	CLKDEV_CON_ID("rtc0", &mstp_clks[MSTP60]),
+	CLKDEV_DEV_ID("ostm.0", &mstp_clks[MSTP51]),
+	CLKDEV_DEV_ID("ostm.1", &mstp_clks[MSTP50]),
 	CLKDEV_CON_ID("mtu2_fck", &mstp_clks[MSTP33]),
+	CLKDEV_DEV_ID("rza1-pwm.0", &mstp_clks[MSTP33]),
+	CLKDEV_CON_ID("scux", &mstp_clks[MSTP81]),
+	CLKDEV_CON_ID("usb0", &mstp_clks[MSTP71]),
+	CLKDEV_CON_ID("usb1", &mstp_clks[MSTP70]),
 
 	/* ICK */
 	CLKDEV_ICK_ID("sci_fck", "sh-sci.0", &mstp_clks[MSTP47]),
diff --git a/arch/arm/mach-shmobile/include/mach/r7s72100.h b/arch/arm/mach-shmobile/include/mach/r7s72100.h
index 5f34b20..47387dc 100644
--- a/arch/arm/mach-shmobile/include/mach/r7s72100.h
+++ b/arch/arm/mach-shmobile/include/mach/r7s72100.h
@@ -1,8 +1,54 @@
 #ifndef __ASM_R7S72100_H__
 #define __ASM_R7S72100_H__
 
+enum pfc_pin_number {
+	P0_0, P0_1, P0_2, P0_3, P0_4, P0_5,
+	P1_0, P1_1, P1_2, P1_3, P1_4, P1_5, P1_6, P1_7, P1_8,
+	P1_9, P1_10, P1_11, P1_12, P1_13, P1_14, P1_15,
+	P2_0, P2_1, P2_2, P2_3, P2_4, P2_5, P2_6, P2_7, P2_8,
+	P2_9, P2_10, P2_11, P2_12, P2_13, P2_14, P2_15,
+	P3_0, P3_1, P3_2, P3_3, P3_4, P3_5, P3_6, P3_7, P3_8,
+	P3_9, P3_10, P3_11, P3_12, P3_13, P3_14, P3_15,
+	P4_0, P4_1, P4_2, P4_3, P4_4, P4_5, P4_6, P4_7, P4_8,
+	P4_9, P4_10, P4_11, P4_12, P4_13, P4_14, P4_15,
+	P5_0, P5_1, P5_2, P5_3, P5_4, P5_5, P5_6, P5_7, P5_8,
+	P5_9, P5_10,
+	P6_0, P6_1, P6_2, P6_3, P6_4, P6_5, P6_6, P6_7, P6_8,
+	P6_9, P6_10, P6_11, P6_12, P6_13, P6_14, P6_15,
+	P7_0, P7_1, P7_2, P7_3, P7_4, P7_5, P7_6, P7_7, P7_8,
+	P7_9, P7_10, P7_11, P7_12, P7_13, P7_14, P7_15,
+	P8_0, P8_1, P8_2, P8_3, P8_4, P8_5, P8_6, P8_7, P8_8,
+	P8_9, P8_10, P8_11, P8_12, P8_13, P8_14, P8_15,
+	P9_0, P9_1, P9_2, P9_3, P9_4, P9_5, P9_6, P9_7,
+	P10_0, P10_1, P10_2, P10_3, P10_4, P10_5, P10_6, P10_7, P10_8,
+	P10_9, P10_10, P10_11, P10_12, P10_13, P10_14, P10_15,
+	P11_0, P11_1, P11_2, P11_3, P11_4, P11_5, P11_6, P11_7, P11_8,
+	P11_9, P11_10, P11_11, P11_12, P11_13, P11_14, P11_15,
+	GPIO_NR,
+};
+
+enum pfc_mode {
+	PMODE = 0,
+	ALT1, ALT2, ALT3, ALT4, ALT5, ALT6, ALT7, ALT8,
+	PINMUX_STATE_NUM,
+};
+
+enum pfc_direction {
+	DIIO_PBDC_DIS = 0,	/* Direct I/O Mode & PBDC Disable */
+	DIIO_PBDC_EN,		/* Direct I/O Mode & PBDC Enable */
+	SWIO_OUT_PBDCDIS,	/* Software I/O Mode & Output direction PBDC Disable */
+	SWIO_OUT_PBDCEN,	/* Software I/O Mode & Output direction PBDC Enable */
+	PORT_OUT_HIGH,		/* Port Mode & Output direction & High Level Output Pn = 1 */
+	PORT_OUT_LOW,		/* Port Mode & Output direction & Low Level Output Pn = 0 */
+	DIR_OUT,
+	DIR_IN,			/* Port Mode or Software I/O Mode is Direction IN */
+};
+
 void r7s72100_add_dt_devices(void);
 void r7s72100_clock_init(void);
 void r7s72100_init_early(void);
+int r7s72100_pinmux_setup(void);
+int r7s72100_pfc_pin_assign(enum pfc_pin_number pinnum, enum pfc_mode mode,
+			       enum pfc_direction dir);
 
 #endif /* __ASM_R7S72100_H__ */
diff --git a/arch/arm/mach-shmobile/include/mach/rtc.h b/arch/arm/mach-shmobile/include/mach/rtc.h
new file mode 100644
index 0000000..2e1664c
--- /dev/null
+++ b/arch/arm/mach-shmobile/include/mach/rtc.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _ASM_RTC_H
+#define _ASM_RTC_H
+
+void time_init(void);
+extern void (*board_time_init)(void);
+extern void (*rtc_sh_get_time)(struct timespec *);
+extern int (*rtc_sh_set_time)(const time_t);
+
+/* some dummy definitions */
+#define RTC_BATT_BAD 0x100	/* battery bad */
+#define RTC_SQWE 0x08		/* enable square-wave output */
+#define RTC_DM_BINARY 0x04	/* all time/date values are BCD if clear */
+#define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
+#define RTC_DST_EN 0x01	        /* auto switch DST - works f. USA only */
+
+struct rtc_time;
+unsigned int get_rtc_time(struct rtc_time *);
+int set_rtc_time(struct rtc_time *);
+
+#define RTC_CAP_4_DIGIT_YEAR	(1 << 0)
+
+struct sh_rtc_platform_info {
+	unsigned long capabilities;
+};
+
+#define rtc_reg_size            sizeof(u16)
+
+#define RTC_BIT_INVERTED        0x40    /* bug on SH7750, SH7750S */
+#define RTC_DEF_CAPABILITIES    RTC_CAP_4_DIGIT_YEAR
+
+#endif /* _ASM_RTC_H */
diff --git a/arch/arm/mach-shmobile/pfc-rza1.c b/arch/arm/mach-shmobile/pfc-rza1.c
new file mode 100644
index 0000000..98dc195
--- /dev/null
+++ b/arch/arm/mach-shmobile/pfc-rza1.c
@@ -0,0 +1,313 @@
+/*
+ * Copyright (C) 2013-2014  Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <asm/io.h>
+#include <linux/export.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <mach/r7s72100.h>
+
+#define GPIO_CHIP_NAME "RZA1_INTERNAL_PFC"
+
+#define RZA1_BASE	IOMEM(0xfcfe3000)
+#define PORT_OFFSET	0x4
+#define PORT(p)		(0x0000 + (p) * PORT_OFFSET)
+#define PPR(p)		(0x0200 + (p) * PORT_OFFSET)
+#define PM(p)		(0x0300 + (p) * PORT_OFFSET)
+#define PMC(p)		(0x0400 + (p) * PORT_OFFSET)
+#define PFC(p)		(0x0500 + (p) * PORT_OFFSET)
+#define PFCE(p)		(0x0600 + (p) * PORT_OFFSET)
+#define PFCAE(p)	(0x0a00 + (p) * PORT_OFFSET)
+#define PIBC(p)		(0x4000 + (p) * PORT_OFFSET)
+#define PBDC(p)		(0x4100 + (p) * PORT_OFFSET)
+#define PIPC(p)		(0x4200 + (p) * PORT_OFFSET)
+
+static struct mutex	mutex;
+
+enum {
+	REG_PFC = 0,
+	REG_PFCE,
+	REG_PFCAE,
+	REG_NUM,
+};
+
+static bool mode_regset[][REG_NUM] = {
+	/* PFC,	PFCE,	PFCAE */
+	{false,	false,	false	}, /* port mode */
+	{false,	false,	false	}, /* alt true */
+	{true,	false,	false	}, /* alt 2 */
+	{false,	true,	false	}, /* alt 3 */
+	{true,	true,	false	}, /* alt 4 */
+	{false,	false,	true	}, /* alt 5 */
+	{true,	false,	true	}, /* alt 6 */
+	{false,	true,	true	}, /* alt 7 */
+	{true,	true,	true	}, /* alt 8 */
+};
+
+static unsigned int regs_addr[][REG_NUM] = {
+	{PFC(0), PFCE(0), PFCAE(0)},
+	{PFC(1), PFCE(1), PFCAE(1)},
+	{PFC(2), PFCE(2), PFCAE(2)},
+	{PFC(3), PFCE(3), PFCAE(3)},
+	{PFC(4), PFCE(4), PFCAE(4)},
+	{PFC(5), PFCE(5), PFCAE(5)},
+	{PFC(6), PFCE(6), PFCAE(6)},
+	{PFC(7), PFCE(7), PFCAE(7)},
+	{PFC(8), PFCE(8), PFCAE(8)},
+	{PFC(9), PFCE(9), PFCAE(9)},
+	{PFC(10), PFCE(10), PFCAE(10)},
+	{PFC(11), PFCE(11), PFCAE(11)},
+};
+
+static unsigned int port_nbit[] = {
+	6, 16, 16, 16, 16, 11, 16, 16, 16, 8, 16, 16,
+};
+
+
+static inline int _bit_modify(void __iomem *addr, int bit, bool data)
+{
+	__raw_writel((__raw_readl(addr) & ~(0x1 << bit)) | (data << bit), addr);
+	return 0;
+}
+
+static inline int bit_modify(unsigned int addr, int bit, bool data)
+{
+	return _bit_modify(RZA1_BASE + addr, bit, data);
+}
+
+static int set_direction(unsigned int port, int bit, enum pfc_direction dir)
+{
+	if ((port == 0) && (dir != DIR_IN))	/* p0 is input only */
+		return -1;
+
+	if (dir == DIR_IN) {
+		bit_modify(PM(port), bit, true);
+		bit_modify(PIBC(port), bit, true);
+	} else {
+		bit_modify(PM(port), bit, false);
+		bit_modify(PIBC(port), bit, false);
+	}
+
+	return 0;
+}
+
+static int get_port_bitshift(int *offset)
+{
+	unsigned int i;
+	for (i = 0; *offset >= port_nbit[i]; *offset -= port_nbit[i++])
+		if (i > ARRAY_SIZE(port_nbit))
+			return -1;
+	return i;
+}
+
+static int chip_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	int port;
+	unsigned int d;
+
+	port = get_port_bitshift(&offset);
+
+
+	d = __raw_readl(RZA1_BASE + PPR(port));
+
+	return (d &= (0x1 << offset)) ? 1 : 0;
+}
+
+static void chip_gpio_set(struct gpio_chip *chip, unsigned offset, int val)
+{
+	int port;
+
+	port = get_port_bitshift(&offset);
+	if (port <= 0)	/* p0 is input only */
+		return;
+
+	bit_modify(PORT(port), offset, val);
+	return;
+}
+
+static int chip_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	int port;
+
+	port = get_port_bitshift(&offset);
+
+	mutex_lock(&mutex);
+	set_direction(port, offset, DIR_IN);
+	mutex_unlock(&mutex);
+
+	return 0;
+}
+
+static int chip_direction_output(struct gpio_chip *chip, unsigned offset,
+				int val)
+{
+	int port;
+
+	port = get_port_bitshift(&offset);
+	if (port <= 0)	/* case : p0 is input only && negative value*/
+		return -1;
+
+	mutex_lock(&mutex);
+	bit_modify(PORT(port), offset, val);
+	set_direction(port, offset, DIR_OUT);
+	mutex_unlock(&mutex);
+
+	return 0;
+}
+
+static const char * const gpio_names[] = {
+	"P0_0", "P0_1", "P0_2", "P0_3", "P0_4", "P0_5",
+	"P1_0", "P1_1", "P1_2", "P1_3", "P1_4", "P1_5", "P1_6", "P1_7", "P1_8",
+	"P1_9", "P1_10", "P1_11", "P1_12", "P1_13", "P1_14", "P1_15",
+	"P2_0", "P2_1", "P2_2", "P2_3", "P2_4", "P2_5", "P2_6", "P2_7", "P2_8",
+	"P2_9", "P2_10", "P2_11", "P2_12", "P2_13", "P2_14", "P2_15",
+	"P3_0", "P3_1", "P3_2", "P3_3", "P3_4", "P3_5", "P3_6", "P3_7", "P3_8",
+	"P3_9", "P3_10", "P3_11", "P3_12", "P3_13", "P3_14", "P3_15",
+	"P4_0", "P4_1", "P4_2", "P4_3", "P4_4", "P4_5", "P4_6", "P4_7", "P4_8",
+	"P4_9", "P4_10", "P4_11", "P4_12", "P4_13", "P4_14", "P4_15",
+	"P5_0", "P5_1", "P5_2", "P5_3", "P5_4", "P5_5", "P5_6", "P5_7", "P5_8",
+	"P5_9", "P5_10",
+	"P6_0", "P6_1", "P6_2", "P6_3", "P6_4", "P6_5", "P6_6", "P6_7", "P6_8",
+	"P6_9", "P6_10", "P6_11", "P6_12", "P6_13", "P6_14", "P6_15",
+	"P7_0", "P7_1", "P7_2", "P7_3", "P7_4", "P7_5", "P7_6", "P7_7", "P7_8",
+	"P7_9", "P7_10", "P7_11", "P7_12", "P7_13", "P7_14", "P7_15",
+	"P8_0", "P8_1", "P8_2", "P8_3", "P8_4", "P8_5", "P8_6", "P8_7", "P8_8",
+	"P8_9", "P8_10", "P8_11", "P8_12", "P8_13", "P8_14", "P8_15",
+	"P9_0", "P9_1", "P9_2", "P9_3", "P9_4", "P9_5", "P9_6", "P9_7",
+	"P10_0", "P10_1", "P10_2", "P10_3", "P10_4", "P10_5", "P10_6", "P10_7",
+	"P10_8", "P10_9", "P10_10", "P10_11", "P10_12", "P10_13", "P10_14",
+	"P10_15",
+	"P11_0", "P11_1", "P11_2", "P11_3", "P11_4", "P11_5", "P11_6", "P11_7",
+	"P11_8", "P11_9", "P11_10", "P11_11", "P11_12", "P11_13", "P11_14",
+	"P11_15",
+};
+
+static struct gpio_chip chip = {
+	.label = GPIO_CHIP_NAME,
+	.names = gpio_names,
+	.base = 0,
+	.ngpio = GPIO_NR,
+
+	.get = chip_gpio_get,
+	.set = chip_gpio_set,
+
+	.direction_input = chip_direction_input,
+	.direction_output = chip_direction_output,
+};
+
+int r7s72100_pinmux_setup(void)
+{
+	int retval;
+	mutex_init(&mutex);
+	retval = gpiochip_add(&chip);
+	return retval;
+}
+
+static int set_mode(unsigned int port, int bit, int mode)
+{
+	unsigned int reg;
+
+	for (reg = REG_PFC; reg < REG_NUM; reg++)
+		bit_modify(regs_addr[port][reg], bit, mode_regset[mode][reg]);
+
+	return 0;
+}
+
+/*
+ * @pinnum: a pin number.
+ * @mode:   port mode or alternative N mode.
+ * @dir:    Kind of I/O mode and data direction and PBDC and Output Level.
+ *          PIPC enable SoC IP to control a direction.
+ */
+int r7s72100_pfc_pin_assign(enum pfc_pin_number pinnum, enum pfc_mode mode,
+			enum pfc_direction dir)
+{
+	int port, bit = (int)pinnum;
+
+	port = get_port_bitshift(&bit);
+
+	/* Error is less than 0 port */
+	if (port < 0)
+		return -1;
+
+	/* Port 0 there is only PMC and PIBC control register */
+	if (port == 0) {
+		/* Port initialization */
+		bit_modify(PIBC(port), bit, false);	/* Input buffer block */
+		bit_modify(PMC(port), bit, false);	/* Port mode */
+
+		/* Port Mode */
+		if (mode == PMODE) {
+			if (dir == DIR_IN) {
+				/* PIBC Setting : Input buffer allowed */
+				bit_modify(PIBC(port), bit, true);
+			} else {
+				return -1;	/* P0 Portmode is input only */
+			}
+		/* Alternative Mode */
+		} else {
+			if ((bit == P0_4) || (bit == P0_5)) {
+				/* PMC Setting : Alternative mode */
+				bit_modify(PMC(port), bit, true);
+			} else {
+				return -1;	/* P0 Altmode P0_4,P0_5 only */
+			}
+		}
+		return 0;
+	}
+
+	/* Port initialization */
+	bit_modify(PIBC(port), bit, false);	/* Inputbuffer block */
+	bit_modify(PBDC(port), bit, false);	/* Bidirection disabled */
+	bit_modify(PM(port), bit, true);	/* Input mode(output disabled)*/
+	bit_modify(PMC(port), bit, false);	/* Port mode */
+	bit_modify(PIPC(port), bit, false);	/* software I/Ocontrol. */
+
+	/* PBDC Setting */
+	if ((dir == DIIO_PBDC_EN) || (dir == SWIO_OUT_PBDCEN))
+		bit_modify(PBDC(port), bit, true);	/* Bidirection enable */
+
+	/* Port Mode */
+	if (mode == PMODE) {
+		if (dir == DIR_IN) {
+			bit_modify(PIBC(port), bit, true); /*Inputbuffer allow*/
+		} else if (dir == PORT_OUT_LOW) {
+			bit_modify(PORT(port), bit, false); /*Output low level*/
+			bit_modify(PM(port), bit, false);  /* Output mode */
+		} else if (dir == PORT_OUT_HIGH) {
+			bit_modify(PORT(port), bit, true); /*Output high level*/
+			bit_modify(PM(port), bit, false);  /* Output mode */
+		} else {
+			return -1;
+		}
+	/* direct I/O control & software I/Ocontrol */
+	} else {
+		/* PFC,PFCE,PFCAE Setting */
+		set_mode(port, bit, mode); /* Alternative Function Select */
+
+		/* PIPC Setting */
+		if ((dir == DIIO_PBDC_DIS) || (dir == DIIO_PBDC_EN))
+			bit_modify(PIPC(port), bit, true); /* direct I/O cont */
+		/* PMC Setting */
+		bit_modify(PMC(port), bit, true);	/* Alternative Mode */
+
+		/* PM Setting : Output mode (output enabled)*/
+		if ((dir == SWIO_OUT_PBDCDIS) || (dir == SWIO_OUT_PBDCEN))
+			bit_modify(PM(port), bit, false);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(r7s72100_pfc_pin_assign);
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index a623cb3..e3475bf 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -39,6 +39,8 @@
 #include "mm.h"
 #include "tcm.h"
 
+extern char _edata_loc[];
+
 /*
  * empty_zero_page is a special page that is used for
  * zero-initialized data and COW.
@@ -1191,7 +1193,7 @@ static inline void prepare_page_table(void)
 
 #ifdef CONFIG_XIP_KERNEL
 	/* The XIP kernel is mapped in the module area -- skip over it */
-	addr = ((unsigned long)_etext + PMD_SIZE - 1) & PMD_MASK;
+	addr = ((unsigned long)_edata_loc + PMD_SIZE - 1) & PMD_MASK;
 #endif
 	for ( ; addr < PAGE_OFFSET; addr += PMD_SIZE)
 		pmd_clear(pmd_off_k(addr));
@@ -1270,7 +1272,7 @@ static void __init devicemaps_init(const struct machine_desc *mdesc)
 #ifdef CONFIG_XIP_KERNEL
 	map.pfn = __phys_to_pfn(CONFIG_XIP_PHYS_ADDR & SECTION_MASK);
 	map.virtual = MODULES_VADDR;
-	map.length = ((unsigned long)_etext - map.virtual + ~SECTION_MASK) & SECTION_MASK;
+	map.length = ((unsigned long)_edata_loc - map.virtual + ~SECTION_MASK) & SECTION_MASK;
 	map.type = MT_ROM;
 	create_mapping(&map);
 #endif
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index 74f6033..4c7b271 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -262,7 +262,11 @@ __v7_pj4b_setup:
 #endif /* CONFIG_CPU_PJ4B */
 
 __v7_setup:
+#ifndef CONFIG_XIP_KERNEL
 	adr	r12, __v7_setup_stack		@ the local stack
+#else
+	ldr	r12, =PLAT_PHYS_OFFSET		@ the local stack
+#endif
 	stmia	r12, {r0-r5, r7, r9, r11, lr}
 	bl      v7_flush_dcache_louis
 	ldmia	r12, {r0-r5, r7, r9, r11, lr}
diff --git a/drivers/clk/shmobile/Makefile b/drivers/clk/shmobile/Makefile
index 9ecef14..5404cb9 100644
--- a/drivers/clk/shmobile/Makefile
+++ b/drivers/clk/shmobile/Makefile
@@ -1,4 +1,5 @@
 obj-$(CONFIG_ARCH_EMEV2)		+= clk-emev2.o
+obj-$(CONFIG_ARCH_R7S72100)		+= clk-rz.o
 obj-$(CONFIG_ARCH_R8A7790)		+= clk-rcar-gen2.o
 obj-$(CONFIG_ARCH_R8A7791)		+= clk-rcar-gen2.o
 obj-$(CONFIG_ARCH_SHMOBILE_MULTI)	+= clk-div6.o
diff --git a/drivers/clk/shmobile/clk-div6.c b/drivers/clk/shmobile/clk-div6.c
index aac4756..f065f69 100644
--- a/drivers/clk/shmobile/clk-div6.c
+++ b/drivers/clk/shmobile/clk-div6.c
@@ -23,7 +23,7 @@
 #define CPG_DIV6_DIV_MASK	0x3f
 
 /**
- * struct div6_clock - MSTP gating clock
+ * struct div6_clock - CPG 6 bit divider clock
  * @hw: handle between common and hardware-specific interfaces
  * @reg: IO-remapped register
  * @div: divisor value (1-64)
diff --git a/drivers/clk/shmobile/clk-rz.c b/drivers/clk/shmobile/clk-rz.c
new file mode 100644
index 0000000..7e68e86
--- /dev/null
+++ b/drivers/clk/shmobile/clk-rz.c
@@ -0,0 +1,103 @@
+/*
+ * rz Core CPG Clocks
+ *
+ * Copyright (C) 2013 Ideas On Board SPRL
+ * Copyright (C) 2014 Wolfram Sang, Sang Engineering <wsa@sang-engineering.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+
+struct rz_cpg {
+	struct clk_onecell_data data;
+	void __iomem *reg;
+};
+
+#define CPG_FRQCR	0x10
+#define CPG_FRQCR2	0x14
+
+/* -----------------------------------------------------------------------------
+ * Initialization
+ */
+
+static struct clk * __init
+rz_cpg_register_clock(struct device_node *np, struct rz_cpg *cpg, const char *name)
+{
+	u32 val;
+	unsigned mult;
+	static const unsigned frqcr_tab[4] = { 3, 2, 0, 1 };
+
+	if (strcmp(name, "pll") == 0) {
+		/* FIXME: cpg_mode should be read from GPIO. But no GPIO support yet */
+		unsigned cpg_mode = 0; /* hardcoded to EXTAL for now */
+		const char *parent_name = of_clk_get_parent_name(np, cpg_mode);
+
+		mult = cpg_mode ? (32 / 4) : 30;
+
+		return clk_register_fixed_factor(NULL, name, parent_name, 0, mult, 1);
+	}
+
+	/* If mapping regs failed, skip non-pll clocks. System will boot anyhow */
+	if (!cpg->reg)
+		return ERR_PTR(-ENXIO);
+
+	/* FIXME:"i" and "g" are variable clocks with non-integer dividers (e.g. 2/3)
+	 * and the constraint that always g <= i. To get the rz platform started,
+	 * let them run at fixed current speed and implement the details later.
+	 */
+	if (strcmp(name, "i") == 0)
+		val = (clk_readl(cpg->reg + CPG_FRQCR) >> 8) & 3;
+	else if (strcmp(name, "g") == 0)
+		val = clk_readl(cpg->reg + CPG_FRQCR2) & 3;
+	else
+		return ERR_PTR(-EINVAL);
+
+	mult = frqcr_tab[val];
+	return clk_register_fixed_factor(NULL, name, "pll", 0, mult, 3);
+}
+
+static void __init rz_cpg_clocks_init(struct device_node *np)
+{
+	struct rz_cpg *cpg;
+	struct clk **clks;
+	unsigned i;
+	int num_clks;
+
+	num_clks = of_property_count_strings(np, "clock-output-names");
+	if (WARN(num_clks <= 0, "can't count CPG clocks\n"))
+		return;
+
+	cpg = kzalloc(sizeof(*cpg), GFP_KERNEL);
+	clks = kzalloc(num_clks * sizeof(*clks), GFP_KERNEL);
+	BUG_ON(!cpg || !clks);
+
+	cpg->data.clks = clks;
+	cpg->data.clk_num = num_clks;
+
+	cpg->reg = of_iomap(np, 0);
+
+	for (i = 0; i < num_clks; ++i) {
+		const char *name;
+		struct clk *clk;
+
+		of_property_read_string_index(np, "clock-output-names", i, &name);
+
+		clk = rz_cpg_register_clock(np, cpg, name);
+		if (IS_ERR(clk))
+			pr_err("%s: failed to register %s %s clock (%ld)\n",
+			       __func__, np->name, name, PTR_ERR(clk));
+		else
+			cpg->data.clks[i] = clk;
+	}
+
+	of_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);
+}
+CLK_OF_DECLARE(rz_cpg_clks, "renesas,rz-cpg-clocks", rz_cpg_clocks_init);
diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index cd6950f..abdbeec 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -140,3 +140,64 @@ config VF_PIT_TIMER
 	bool
 	help
 	  Support for Period Interrupt Timer on Freescale Vybrid Family SoCs.
+
+config SYS_SUPPORTS_SH_CMT
+        bool
+
+config SYS_SUPPORTS_SH_MTU2
+        bool
+
+config SYS_SUPPORTS_SH_OSTM
+        bool
+
+config SYS_SUPPORTS_SH_TMU
+        bool
+
+config SYS_SUPPORTS_EM_STI
+        bool
+
+config SH_TIMER_CMT
+	bool "Renesas CMT timer driver" if COMPILE_TEST
+	depends on GENERIC_CLOCKEVENTS
+	default SYS_SUPPORTS_SH_CMT
+	help
+	  This enables build of a clocksource and clockevent driver for
+	  the Compare Match Timer (CMT) hardware available in 16/32/48-bit
+	  variants on a wide range of Mobile and Automotive SoCs from Renesas.
+
+config SH_TIMER_MTU2
+	bool "Renesas MTU2 timer driver" if COMPILE_TEST
+	depends on GENERIC_CLOCKEVENTS
+	default SYS_SUPPORTS_SH_MTU2
+	help
+	  This enables build of a clockevent driver for the Multi-Function
+	  Timer Pulse Unit 2 (TMU2) hardware available on SoCs from Renesas.
+	  This hardware comes with 16 bit-timer registers.
+
+config CLKSRC_SH_OSTM
+	bool "Renesas OSTM timer driver"
+	depends on GENERIC_CLOCKEVENTS
+	select CLKSRC_MMIO
+	help
+	  This enables build of the OSTM timer driver.
+
+config SH_TIMER_TMU
+	bool "Renesas TMU timer driver" if COMPILE_TEST
+	depends on GENERIC_CLOCKEVENTS
+	default SYS_SUPPORTS_SH_TMU
+	help
+	  This enables build of a clocksource and clockevent driver for
+	  the 32-bit Timer Unit (TMU) hardware available on a wide range
+	  SoCs from Renesas.
+
+config EM_TIMER_STI
+	bool "Renesas STI timer driver" if COMPILE_TEST
+	depends on GENERIC_CLOCKEVENTS
+	default SYS_SUPPORTS_EM_STI
+	help
+	  This enables build of a clocksource and clockevent driver for
+	  the 48-bit System Timer (STI) hardware available on a SoCs
+	  such as EMEV2 from former NEC Electronics.
+
+config CLKSRC_QCOM
+	bool
diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
index c7ca50a..46276d6 100644
--- a/drivers/clocksource/Makefile
+++ b/drivers/clocksource/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_SCx200HR_TIMER)	+= scx200_hrt.o
 obj-$(CONFIG_CS5535_CLOCK_EVENT_SRC)	+= cs5535-clockevt.o
 obj-$(CONFIG_SH_TIMER_CMT)	+= sh_cmt.o
 obj-$(CONFIG_SH_TIMER_MTU2)	+= sh_mtu2.o
+obj-$(CONFIG_CLKSRC_SH_OSTM)	+= sh_ostm.o
 obj-$(CONFIG_SH_TIMER_TMU)	+= sh_tmu.o
 obj-$(CONFIG_EM_TIMER_STI)	+= em_sti.o
 obj-$(CONFIG_CLKBLD_I8253)	+= i8253.o
diff --git a/drivers/clocksource/sh_ostm.c b/drivers/clocksource/sh_ostm.c
new file mode 100644
index 0000000..a526baf
--- /dev/null
+++ b/drivers/clocksource/sh_ostm.c
@@ -0,0 +1,432 @@
+/*
+ * RZ/A1 Timer Driver - OSTM
+ *
+ * Copyright (C) 2014 Renesas Solutions Corp.
+ *
+ * Based on drivers/clocksource/sh_mtu2.c
+ *  Copyright (C) 2009 Magnus Damm
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched_clock.h>
+#include <clocksource/sh_ostm.h>
+
+/*
+ * [TODO] This driver doesn't support Power Management.
+ */
+
+struct rza1_ostm_clksrc {
+	int irq;			/* unused */
+	struct clk *clk;
+	unsigned long rate;
+	void __iomem *base;
+};
+
+struct rza1_ostm_clkevt {
+	int irq;
+	struct clk *clk;
+	unsigned long rate;
+	void __iomem *base;
+	int mode;
+	unsigned long ticks_per_jiffy;
+	struct irqaction irqaction;
+	struct clock_event_device evt;
+};
+
+struct rza1_ostm_priv {
+	struct platform_device *pdev;
+	struct rza1_ostm_clksrc clksrc;
+	struct rza1_ostm_clkevt clkevt;
+};
+
+static struct rza1_ostm_priv *rza1_ostm_priv;
+static void __iomem *system_clock;
+
+/* OSTM REGISTERS */
+#define	OSTM_CMP		0x000	/* RW,32 */
+#define	OSTM_CNT		0x004	/* R,32 */
+#define	OSTM_TE			0x010	/* R,8 */
+#define	OSTM_TS			0x014	/* W,8 */
+#define	OSTM_TT			0x018	/* W,8 */
+#define	OSTM_CTL		0x020	/* RW,8 */
+
+#define	TE			0x01
+#define	TS			0x01
+#define	TT			0x01
+#define	CTL_PERIODIC		0x00
+#define	CTL_ONESHOT		0x02
+#define	CTL_FREERUN		0x02
+
+/*********************************************************************/
+/*
+ * Setup clock-source device (which is ostm.0)
+ * as free-running mode.
+ */
+static int __init rza1_ostm_init_clksrc(struct rza1_ostm_priv *priv)
+{
+	struct rza1_ostm_pdata *pdata;
+	struct rza1_ostm_clksrc *cs;
+	struct resource *res;
+	int ret = -ENXIO;
+
+	pdata = priv->pdev->dev.platform_data;
+	cs = &priv->clksrc;
+
+	res = platform_get_resource(priv->pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&priv->pdev->dev, "failed to get I/O memory\n");
+		goto err;
+	}
+	cs->base = ioremap_nocache(res->start, resource_size(res));
+	if (!cs->base) {
+		dev_err(&priv->pdev->dev, "failed to remap I/O memory\n");
+		goto err;
+	}
+
+	cs->irq = platform_get_irq(priv->pdev, 0);
+	if (cs->irq < 0) {
+		dev_err(&priv->pdev->dev, "failed to get irq\n");
+		goto err_iounmap;
+	}
+
+	cs->clk = clk_get_sys(pdata->clksrc.name, NULL);
+	if (!cs->clk) {
+		dev_err(&priv->pdev->dev, "failed to get clock\n");
+		goto err_iounmap;
+	}
+	cs->rate = clk_get_rate(cs->clk);
+	ret = clk_enable(cs->clk);
+	if (ret) {
+		dev_err(&priv->pdev->dev, "failed to enable clock\n");
+		goto err_iounmap;
+	}
+
+	if (ioread8(cs->base + OSTM_TE) & TE) {
+		iowrite8(TT, cs->base + OSTM_TT);
+		while (ioread8(cs->base + OSTM_TE) & TE)
+			;
+	}
+	iowrite32(0, cs->base + OSTM_CMP);
+	iowrite8(CTL_FREERUN, cs->base + OSTM_CTL);
+	iowrite8(TS, cs->base + OSTM_TS);
+
+	clocksource_mmio_init(cs->base + OSTM_CNT,
+			"ostm_clksrc", cs->rate,
+			pdata->clksrc.rating, 32, clocksource_mmio_readl_up);
+
+	return ret;	/* ret == 0 */
+
+err_iounmap:
+	iounmap(cs->base);
+err:
+	return ret;
+}
+
+/*********************************************************************/
+/*
+ * Setup sched_clock using clocksource device.
+ */
+static u32 notrace rza1_ostm_read_sched_clock(void)
+{
+	return ioread32(system_clock);
+}
+
+static int __init rza1_ostm_init_sched_clock(struct rza1_ostm_clksrc *cs)
+{
+	unsigned long flags;
+
+	system_clock = cs->base + OSTM_CNT;
+	local_irq_save(flags);
+	local_irq_disable();
+	setup_sched_clock(rza1_ostm_read_sched_clock, 32, cs->rate);
+	local_irq_restore(flags);
+	return 0;
+}
+
+/*********************************************************************/
+/*
+ * Setup clock-event device (which is ostm.1)
+ * (interrupt-driven).
+ */
+static void rza1_ostm_clkevt_timer_stop(struct rza1_ostm_clkevt *clkevt)
+{
+	if (ioread8(clkevt->base + OSTM_TE) & TE) {
+		iowrite8(TT, clkevt->base + OSTM_TT);
+		while (ioread8(clkevt->base + OSTM_TE) & TE)
+			;
+	}
+}
+
+static int rza1_ostm_clkevt_set_next_event(unsigned long delta,
+		struct clock_event_device *evt)
+{
+	struct rza1_ostm_clkevt *clkevt = &rza1_ostm_priv->clkevt;
+
+	rza1_ostm_clkevt_timer_stop(clkevt);
+
+	iowrite32(delta, clkevt->base + OSTM_CMP);
+	iowrite8(CTL_ONESHOT, clkevt->base + OSTM_CTL);
+	iowrite8(TS, clkevt->base + OSTM_TS);
+
+	return 0;
+}
+
+static void rza1_ostm_clkevt_set_mode(enum clock_event_mode mode,
+		struct clock_event_device *evt)
+{
+	struct rza1_ostm_clkevt *clkevt = &rza1_ostm_priv->clkevt;
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_ONESHOT:
+		rza1_ostm_clkevt_timer_stop(clkevt);
+		break;
+	case CLOCK_EVT_MODE_PERIODIC:
+		iowrite32(clkevt->ticks_per_jiffy - 1, clkevt->base + OSTM_CMP);
+		iowrite8(CTL_PERIODIC, clkevt->base + OSTM_CTL);
+		iowrite8(TS, clkevt->base + OSTM_TS);
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+	default:
+		break;
+	}
+	clkevt->mode = mode;
+}
+
+static irqreturn_t rza1_ostm_timer_interrupt(int irq, void *dev_id)
+{
+#if 1
+	struct rza1_ostm_clkevt *clkevt = dev_id;
+
+	if (clkevt->mode == CLOCK_EVT_MODE_ONESHOT)
+		rza1_ostm_clkevt_timer_stop(clkevt);
+
+	if (clkevt->evt.event_handler)
+		clkevt->evt.event_handler(&clkevt->evt);
+	return IRQ_HANDLED;
+#else
+	struct clock_event_device *evt = dev_id;
+	struct rza1_ostm_clkevt *clkevt;
+
+	clkevt = container_of(evt, struct rza1_ostm_clkevt, evt);
+	if (clkevt->mode == CLOCK_EVT_MODE_ONESHOT)
+		rza1_ostm_clkevt_timer_stop(clkevt);
+
+	if (evt->event_handler)
+		evt->event_handler(evt);
+	return IRQ_HANDLED;
+#endif
+}
+
+static int __init rza1_ostm_init_clkevt(struct rza1_ostm_priv *priv)
+{
+	struct rza1_ostm_pdata *pdata;
+	struct rza1_ostm_clkevt *ce;
+	struct resource *res;
+	struct clock_event_device *evt;
+	int ret = -ENXIO;
+
+	pdata = priv->pdev->dev.platform_data;
+	ce = &priv->clkevt;
+
+	res = platform_get_resource(priv->pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&priv->pdev->dev, "failed to get I/O memory\n");
+		goto err;
+	}
+	ce->base = ioremap_nocache(res->start, resource_size(res));
+	if (!ce->base) {
+		dev_err(&priv->pdev->dev, "failed to remap I/O memory\n");
+		goto err;
+	}
+
+	ce->irq = platform_get_irq(priv->pdev, 1);
+	if (ce->irq < 0) {
+		dev_err(&priv->pdev->dev, "failed to get irq\n");
+		goto err_iounmap;
+	}
+
+	ce->clk = clk_get_sys(pdata->clkevt.name, NULL);
+	if (!ce->clk) {
+		dev_err(&priv->pdev->dev, "failed to get clock\n");
+		goto err_iounmap;
+	}
+	ce->rate = clk_get_rate(ce->clk);
+	ret = clk_enable(ce->clk);
+	if (ret) {
+		dev_err(&priv->pdev->dev, "failed to enable clock\n");
+		goto err_iounmap;
+	}
+
+	ce->ticks_per_jiffy = (ce->rate + HZ / 2) / HZ;
+	ce->mode = CLOCK_EVT_MODE_UNUSED;
+	ce->irqaction.name = "ostm.1";
+	ce->irqaction.handler = rza1_ostm_timer_interrupt;
+#if 1
+	ce->irqaction.dev_id = ce;
+#else
+	ce->irqaction.dev_id = &priv->clkevt.evt;
+#endif
+	ce->irqaction.irq = ce->irq;
+	ce->irqaction.flags = IRQF_TRIGGER_RISING | IRQF_DISABLED | IRQF_TIMER;
+	ret = setup_irq(ce->irq, &ce->irqaction);
+	if (ret) {
+		dev_err(&priv->pdev->dev, "failed to request irq\n");
+		goto err_iounmap;
+	}
+
+	evt = &ce->evt;
+	evt->name = "ostm";
+	evt->features = CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC;
+	evt->set_mode = rza1_ostm_clkevt_set_mode;
+	evt->set_next_event = rza1_ostm_clkevt_set_next_event;
+	evt->shift = 32;
+	evt->rating = pdata->clkevt.rating;
+	evt->cpumask = cpumask_of(0);
+	clockevents_config_and_register(evt, ce->rate, 0xf, 0xffffffff);
+
+	ret = 0;
+	return ret;
+
+err_iounmap:
+	iounmap(ce->base);
+err:
+	return ret;
+}
+
+static int __init rza1_ostm_timer_init(struct rza1_ostm_priv *priv)
+{
+	int ret = 0;
+
+	ret = rza1_ostm_init_clksrc(priv);
+	if (ret)
+		goto err;
+
+	ret = rza1_ostm_init_sched_clock(&priv->clksrc);
+	if (ret)
+		goto err;
+
+	ret = rza1_ostm_init_clkevt(priv);
+err:
+	return ret;
+}
+
+/***********************************************************************/
+/*
+ * The following source code is left only for the compatibiliy
+ * with RZLSP-V2.0.0.
+ */
+static int __init rza1_ostm_probe(struct platform_device *pdev)
+{
+	struct rza1_ostm_priv *priv;
+	struct rza1_ostm_pdata *pdata;
+	int ret = 0;
+
+	if (!is_early_platform_device(pdev)) {
+		pm_runtime_set_active(&pdev->dev);
+		pm_runtime_enable(&pdev->dev);
+	}
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "failed to get platform data\n");
+		return -ENXIO;
+	}
+
+	priv = platform_get_drvdata(pdev);
+	if (priv) {
+		dev_info(&pdev->dev, "kept as earlytimer\n");
+		goto out;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_info(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+	rza1_ostm_priv = priv;
+
+	priv->pdev = pdev;
+	platform_set_drvdata(priv->pdev, priv);
+
+	ret = rza1_ostm_timer_init(priv);
+	if (ret) {
+		kfree(priv);
+		platform_set_drvdata(pdev, NULL);
+		pm_runtime_idle(&pdev->dev);
+		return ret;
+	}
+
+	if (is_early_platform_device(pdev))
+		return ret;
+
+out:
+	if (pdata->clksrc.rating || pdata->clkevt.rating)
+		pm_runtime_irq_safe(&pdev->dev);
+	else
+		pm_runtime_idle(&pdev->dev);
+
+	return ret;
+}
+
+static int rza1_ostm_remove(struct platform_device *pdev)
+{
+	rza1_ostm_priv = NULL;
+	system_clock = NULL;
+
+	return -EBUSY;	/* cannot unregister */
+}
+
+static struct platform_driver rza1_ostm_timer = {
+	.driver	= {
+		.name	= "ostm",
+	},
+	.probe		= rza1_ostm_probe,
+	.remove		= rza1_ostm_remove,
+};
+
+static int __init rza1_ostm_init(void)
+{
+	return platform_driver_register(&rza1_ostm_timer);
+}
+
+static void __exit rza1_ostm_exit(void)
+{
+	platform_driver_unregister(&rza1_ostm_timer);
+}
+
+early_platform_init("earlytimer", &rza1_ostm_timer);
+subsys_initcall(rza1_ostm_init);
+module_exit(rza1_ostm_exit);
+
+MODULE_AUTHOR("Magnus Damm");	/* original author */
+MODULE_DESCRIPTION("RZ/A1 OSTM Timer Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 605b016..1cb9114 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -171,6 +171,14 @@ config S3C24XX_DMAC
 
 source "drivers/dma/sh/Kconfig"
 
+config RZA1_DMAE
+	tristate "Renesas RZA1 DMAC support"
+	depends on ARCH_R7S72100
+	depends on !SH_DMA_API
+	select DMA_ENGINE
+	help
+	  Enable support for the Renesas RZA1 DMA controllers.
+
 config COH901318
 	bool "ST-Ericsson COH901318 DMA support"
 	select DMA_ENGINE
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index a029d0f4..692a877 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_AT_HDMAC) += at_hdmac.o
 obj-$(CONFIG_MX3_IPU) += ipu/
 obj-$(CONFIG_TXX9_DMAC) += txx9dmac.o
 obj-$(CONFIG_SH_DMAE_BASE) += sh/
+obj-$(CONFIG_RZA1_DMAE) += rza1dma.o
 obj-$(CONFIG_COH901318) += coh901318.o coh901318_lli.o
 obj-$(CONFIG_AMCC_PPC440SPE_ADMA) += ppc4xx/
 obj-$(CONFIG_IMX_SDMA) += imx-sdma.o
diff --git a/drivers/dma/rza1dma.c b/drivers/dma/rza1dma.c
new file mode 100644
index 0000000..557e296
--- /dev/null
+++ b/drivers/dma/rza1dma.c
@@ -0,0 +1,996 @@
+/*
+ * Renesas RZA1 DMA Engine support
+ *
+ * base is drivers/dma/imx-dma.c
+ *
+ * Copyright (C) 2009-2013 Renesas Solutions Corp.
+ * Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/dmaengine.h>
+#include <linux/module.h>
+
+#include <asm/irq.h>
+#include <linux/platform_data/dma-rza1.h>
+
+#include "dmaengine.h"
+#define RZA1DMA_MAX_CHAN_DESCRIPTORS	16
+
+/* set the offset of regs */
+#define	CHSTAT	0x0024
+#define CHCTRL	0x0028
+#define	CHCFG	0x002c
+#define	CHITVL	0x0030
+#define	CHEXT	0x0034
+#define NXLA	0x0038
+#define	CRLA	0x003c
+
+#define	DCTRL		0x0000
+#define	DSTAT_EN	0x0010
+#define	DSTAT_ER	0x0014
+#define	DSTAT_END	0x0018
+#define	DSTAT_TC	0x001c
+#define	DSTAT_SUS	0x0020
+
+#define	EACH_CHANNEL_OFFSET		0x0040
+#define	CHANNEL_0_7_OFFSET		0x0000
+#define	CHANNEL_0_7_COMMON_BASE		0x0300
+#define CHANNEL_8_15_OFFSET		0x0400
+#define	CHANNEL_8_15_COMMON_BASE	0x0700
+
+/* set bit filds */
+/* CHSTAT */
+#define	CHSTAT_TC	(0x1 << 6)
+#define CHSTAT_END	(0x1 << 5)
+#define CHSTAT_ER	(0x1 << 4)
+
+/* CHCTRL */
+#define CHCTRL_CLRINTMSK	(0x1 << 17)
+#define	CHCTRL_SETINTMSK	(0x1 << 16)
+#define	CHCTRL_CLRSUS		(0x1 << 9)
+#define	CHCTRL_SETSUS		(0x1 << 8)
+#define CHCTRL_CLRTC		(0x1 << 6)
+#define	CHCTRL_CLREND		(0x1 << 5)
+#define	CHCTRL_CLRRQ		(0x1 << 4)
+#define	CHCTRL_SWRST		(0x1 << 3)
+#define	CHCTRL_STG		(0x1 << 2)
+#define	CHCTRL_CLREN		(0x1 << 1)
+#define	CHCTRL_SETEN		(0x1 << 0)
+#define	CHCTRL_DEFAULT	(CHCTRL_CLRINTMSK | \
+			CHCTRL_CLRSUS | \
+			CHCTRL_CLRTC | \
+			CHCTRL_CLREND | \
+			CHCTRL_CLRRQ | \
+			CHCTRL_SWRST | \
+			CHCTRL_CLREN)
+
+/* CHCFG */
+#define	CHCFG_DMS		(0x1 << 31)
+#define	CHCFG_DEM		(0x1 << 24)
+#define	CHCFG_TM(bit)		(bit << 22)
+#define	CHCFG_DAD		(0x1 << 21)
+#define	CHCFG_SAD		(0x1 << 20)
+#define	CHCFG_8BIT	(0x00)
+#define	CHCFG_16BIT	(0x01)
+#define	CHCFG_32BIT	(0x02)
+#define	CHCFG_64BIT	(0x03)
+#define CHCFG_128BIT	(0x04)
+#define	CHCFG_256BIT	(0x05)
+#define	CHCFG_512BIT	(0x06)
+#define	CHCFG_1024BIT	(0x07)
+#define	CHCFG_DDS(bit)		(bit << 16)
+#define	CHCFG_SDS(bit)		(bit << 12)
+#define	CHCFG_AM(bits)		(bits << 8)
+#define	CHCFG_LVL(bit)		(bit << 6)
+#define	CHCFG_HIEN(bit)		(bit << 5)
+#define	CHCFG_LOEN(bit)		(bit << 4)
+#define	CHCFG_REQD(bit)		(bit << 3)
+#define	CHCFG_SEL(bits)		((bits & 0x07) << 0)
+
+/* DCTRL */
+#define	DCTRL_LVINT		(0x1 << 1)
+#define	DCTRL_PR		(0x1 << 0)
+#define DCTRL_DEFAULT		(DCTRL_LVINT | DCTRL_PR)
+
+/* DMARS */
+#define	DMARS_RID(bit)		(bit << 0)
+#define	DMARS_MID(bit)		(bit << 2)
+
+/* LINK MODE DESCRIPTOR */
+#define	HEADER_DIM	(0x1 << 3)
+#define	HEADER_WBD	(0x1 << 2)
+#define	HEADER_LE	(0x1 << 1)
+#define	HEADER_LV	(0x1 << 0)
+
+#define to_rza1dma_chan(c) container_of(c, struct rza1dma_channel, chan)
+
+enum  rza1dma_prep_type {
+	RZA1DMA_DESC_MEMCPY,
+	RZA1DMA_DESC_SLAVE_SG,
+};
+
+struct format_desc {
+	u32	header;
+	u32	src_addr;
+	u32	dst_addr;
+	u32	trs_byte;
+	u32	config;
+	u32	interval;
+	u32	extension;
+	u32	next_lk_addr;
+};
+
+#define	FORMAT_DESC_NUM	64
+
+struct rza1dma_desc {
+	struct list_head		node;
+	struct dma_async_tx_descriptor	desc;
+	enum dma_status			status;
+	dma_addr_t			src;
+	dma_addr_t			dest;
+	size_t				len;
+	enum dma_transfer_direction	direction;
+	enum rza1dma_prep_type		type;
+	/* For memcpy */
+	unsigned int			config_port;
+	unsigned int			config_mem;
+	/* For slave sg */
+	struct scatterlist		*sg;
+	unsigned int			sgcount;
+};
+
+struct rza1dma_channel {
+	struct rza1dma_engine		*rza1dma;
+	unsigned int			channel;
+
+	struct tasklet_struct		dma_tasklet;
+	struct list_head		ld_free;
+	struct list_head		ld_queue;
+	struct list_head		ld_active;
+	int				descs_allocated;
+	enum dma_slave_buswidth		word_size;
+	dma_addr_t			per_address;
+	struct dma_chan			chan;
+	struct dma_async_tx_descriptor	desc;
+	enum dma_status			status;
+
+	const struct rza1_dma_slave_config	*slave;
+	void __iomem			*ch_base;
+	void __iomem			*ch_cmn_base;
+	struct format_desc		*desc_base;
+	dma_addr_t			desc_base_dma;
+
+	u32	chcfg;
+	u32	chctrl;
+};
+
+struct rza1dma_engine {
+	struct device			*dev;
+	struct device_dma_parameters	dma_parms;
+	struct dma_device		dma_device;
+	void __iomem			*base;
+	void __iomem			*ext_base;
+	spinlock_t			lock;
+	struct rza1dma_channel		*channel;
+	struct rza1_dma_pdata		*pdata;
+};
+
+static void rza1dma_writel(struct rza1dma_engine *rza1dma, unsigned val,
+				unsigned offset)
+{
+	__raw_writel(val, rza1dma->base + offset);
+}
+
+static void rza1dma_ext_writel(struct rza1dma_engine *rza1dma, unsigned val,
+				unsigned offset)
+{
+	__raw_writel(val, rza1dma->ext_base + offset);
+}
+
+static u32 rza1dma_ext_readl(struct rza1dma_engine *rza1dma, unsigned offset)
+{
+	return __raw_readl(rza1dma->ext_base + offset);
+}
+
+static void rza1dma_ch_writel(struct rza1dma_channel *rza1dmac, unsigned val,
+				unsigned offset, int which)
+{
+	if (which)
+		__raw_writel(val, rza1dmac->ch_base + offset);
+	else
+		__raw_writel(val, rza1dmac->ch_cmn_base + offset);
+}
+
+static u32 rza1dma_ch_readl(struct rza1dma_channel *rza1dmac, unsigned offset,
+				int which)
+{
+	if (which)
+		return __raw_readl(rza1dmac->ch_base + offset);
+	else
+		return __raw_readl(rza1dmac->ch_cmn_base + offset);
+}
+
+static void rza1dma_enable_hw(struct rza1dma_desc *d)
+{
+	struct dma_chan *chan = d->desc.chan;
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	int channel = rza1dmac->channel;
+	unsigned long flags;
+	u32 nxla = rza1dmac->desc_base_dma;
+	u32 chcfg = rza1dmac->chcfg;
+	u32 chctrl = rza1dmac->chctrl;
+
+	dev_dbg(rza1dma->dev, "%s channel %d\n", __func__, channel);
+
+	local_irq_save(flags);
+
+
+	if(chctrl & CHCTRL_SETEN){			/* When [SETEN]is "0".already before process add Descriptor */
+								/* Only add Descriptor case.skip write register */
+		rza1dma_ch_writel(rza1dmac, nxla, NXLA, 1);		/* NXLA reg */
+		rza1dma_ch_writel(rza1dmac, chcfg, CHCFG, 1);		/* CHCFG reg */
+
+		rza1dma_ch_writel(rza1dmac, CHCTRL_SWRST, CHCTRL, 1);	/* CHCTRL reg */
+		rza1dma_ch_writel(rza1dmac, chctrl, CHCTRL, 1);		/* CHCTRL reg */
+	}
+
+	local_irq_restore(flags);
+}
+
+static void rza1dma_disable_hw(struct rza1dma_channel *rza1dmac)
+{
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	int channel = rza1dmac->channel;
+	unsigned long flags;
+
+	dev_dbg(rza1dma->dev, "%s channel %d\n", __func__, channel);
+
+	local_irq_save(flags);
+	rza1dma_ch_writel(rza1dmac, CHCTRL_DEFAULT, CHCTRL, 1); /* CHCTRL reg */
+	local_irq_restore(flags);
+}
+
+static void dma_irq_handle_channel(struct rza1dma_channel *rza1dmac)
+{
+	u32 chstat, chctrl;
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	int channel = rza1dmac->channel;
+
+	chstat = rza1dma_ch_readl(rza1dmac, CHSTAT, 1);
+	if (chstat & CHSTAT_ER) {
+		dev_err(rza1dma->dev, "RZA1 DMAC error ocurred\n");
+		dev_err(rza1dma->dev, "CHSTAT_%d = %08X\n", channel, chstat);
+		rza1dma_ch_writel(rza1dmac,
+				CHCTRL_DEFAULT,
+				CHCTRL, 1);
+		goto schedule;
+	}
+	if (!(chstat & CHSTAT_END))
+		return;
+
+	chctrl = rza1dma_ch_readl(rza1dmac, CHCTRL, 1);
+	rza1dma_ch_writel(rza1dmac,
+			chctrl | CHCTRL_CLREND | CHCTRL_CLRRQ,
+			CHCTRL, 1);
+schedule:
+	/* Tasklet irq */
+	tasklet_schedule(&rza1dmac->dma_tasklet);
+}
+
+static irqreturn_t rza1dma_irq_handler(int irq, void *dev_id)
+{
+	struct rza1dma_engine *rza1dma = dev_id;
+	struct rza1_dma_pdata *pdata = rza1dma->pdata;
+	int i, channel_num = pdata->channel_num;
+
+	dev_dbg(rza1dma->dev, "%s called\n", __func__);
+
+	for (i = 0; i < channel_num; i++)
+		dma_irq_handle_channel(&rza1dma->channel[i]);
+
+	return IRQ_HANDLED;
+}
+
+static void set_dmars_register(struct rza1dma_engine *rza1dma,
+				int channel, u32 dmars)
+{
+	u32 dmars_offset = (channel / 2) * 4;
+	u32 dmars32;
+
+	dmars32 = rza1dma_ext_readl(rza1dma, dmars_offset);
+	if (channel % 2) {
+		dmars32 &= 0x0000ffff;
+		dmars32 |= dmars << 16;
+	} else {
+		dmars32 &= 0xffff0000;
+		dmars32 |= dmars;
+	}
+	rza1dma_ext_writel(rza1dma, dmars32, dmars_offset);
+	dmars32 = rza1dma_ext_readl(rza1dma, dmars_offset);
+}
+
+static void prepare_desc_for_memcpy(struct rza1dma_desc *d)
+{
+	struct dma_chan *chan = d->desc.chan;
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct format_desc *descs = rza1dmac->desc_base;
+	int channel = rza1dmac->channel;
+	u32 chcfg = 0x80400008;
+	u32 dmars = 0;
+
+	dev_dbg(rza1dma->dev, "%s called\n", __func__);
+
+	/* prepare descriptor */
+	descs[0].src_addr = d->src;
+	descs[0].dst_addr = d->dest;
+	descs[0].trs_byte = d->len;
+	descs[0].config = chcfg;
+	descs[0].interval = 0;
+	descs[0].extension = 0;
+	descs[0].header = HEADER_LV | HEADER_LE;
+	descs[0].next_lk_addr = 0;
+
+	/* and set DMARS register */
+	set_dmars_register(rza1dma, channel, dmars);
+
+	rza1dmac->chcfg = chcfg;
+	rza1dmac->chctrl = CHCTRL_STG | CHCTRL_SETEN;
+}
+
+static void prepare_descs_for_slave_sg(struct rza1dma_desc *d)
+{
+	struct dma_chan *chan = d->desc.chan;
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct format_desc *descs = rza1dmac->desc_base;
+	const struct rza1_dma_slave_config *slave = rza1dmac->slave;
+	const struct chcfg_reg *chcfg_p = &slave->chcfg;
+	const struct dmars_reg *dmars_p = &slave->dmars;
+	int channel = rza1dmac->channel;
+	struct scatterlist *sg, *sgl = d->sg;
+	unsigned int i, sg_len = d->sgcount;
+	u32 chcfg;
+	u32 dmars;
+
+	unsigned long flags;
+	
+	int seten_flag = 1, desc_add_flag = 0;
+
+	dev_dbg(rza1dma->dev, "%s called\n", __func__);
+
+	chcfg = (CHCFG_SEL(channel) |
+		CHCFG_REQD(chcfg_p->reqd) |
+		CHCFG_LOEN(chcfg_p->loen) |
+		CHCFG_HIEN(chcfg_p->hien) |
+		CHCFG_LVL(chcfg_p->lvl) |
+		CHCFG_AM(chcfg_p->am) |
+		CHCFG_SDS(chcfg_p->sds) |
+		CHCFG_DDS(chcfg_p->dds) |
+		CHCFG_TM(chcfg_p->tm) |
+		CHCFG_DEM |
+		CHCFG_DMS);
+
+	if (d->direction == DMA_DEV_TO_MEM)
+		chcfg |= CHCFG_SAD;	/* source address is fixed */
+	else
+		chcfg |= CHCFG_DAD;	/* distation address is fixed */
+
+	rza1dmac->per_address = slave->addr;	/* slave device address */
+
+	spin_lock_irqsave(&rza1dma->lock, flags);
+
+	if(sg_len == 1){	/*[sg_len = 1]other than normal process( come value "1" from Audio Driver) */
+		for (i = 0; i < FORMAT_DESC_NUM; i++, sg_len++) {
+			/* Descripter[0]-[1]is use only at first time.Back to 2 If you go up to 63 */
+			if(descs[i].header & HEADER_LE){	/* Link End? */
+				if(descs[i].header & HEADER_LV){
+					if(i >= 2){
+						if(i <= 3){
+							if(descs[(FORMAT_DESC_NUM - 4) + i].header & HEADER_LV){
+								desc_add_flag = 1;
+							}else{
+								if(descs[i - 2].header & HEADER_LV){
+									desc_add_flag = 1;
+								}
+							}
+						}else{
+							if(descs[i - 2].header & HEADER_LV){
+								desc_add_flag = 1;
+							}
+						}
+					}else{
+						desc_add_flag = 1;
+					}
+
+					if(desc_add_flag == 0){
+						dev_err(rza1dma->dev, "RZA1 DMAC Link End Now descs !!\n");
+						i = 0;
+						sg_len = 1;
+					}else{
+						descs[i].header &= ~HEADER_LE;	/* Link End Clear */
+						if(i >= FORMAT_DESC_NUM - 1){	/* if Descripter is over [63] */
+							descs[i].next_lk_addr = rza1dmac->desc_base_dma +
+										sizeof(struct format_desc) * 2;
+							i = 2;
+							sg_len = 3;
+							seten_flag = 0;
+						}else{
+							descs[i].next_lk_addr = rza1dmac->desc_base_dma +
+										sizeof(struct format_desc) * (i + 1);
+							if(i > 1){
+								seten_flag = 0;
+							}
+							i++;
+							sg_len++;
+						}
+					}
+				}else{
+					i = 0;
+					sg_len = 1;
+				}
+				break;
+			}
+		}
+
+		if(descs[i].header & HEADER_LV){
+			dev_err(rza1dma->dev, "RZA1 DMAC descs over flow!!\n");
+		}
+
+		if(i == FORMAT_DESC_NUM){
+			i = 0;
+			sg_len = 1;
+		}
+	}else{
+		i = 0;
+	}
+
+	/* Prepare descriptors */
+	for (sg = sgl; i < sg_len; i++, sg = sg_next(sg)) {
+		if (d->direction == DMA_DEV_TO_MEM) {
+			descs[i].src_addr = rza1dmac->per_address;
+			descs[i].dst_addr = sg_dma_address(sg);
+		} else {
+			descs[i].src_addr = sg_dma_address(sg);
+			descs[i].dst_addr = rza1dmac->per_address;
+		}
+
+		descs[i].trs_byte = sg_dma_len(sg);
+		descs[i].config = chcfg;
+		descs[i].interval = 0x00ff;
+		descs[i].extension = 0;
+		descs[i].next_lk_addr = rza1dmac->desc_base_dma +
+					sizeof(struct format_desc) * (i + 1);
+		descs[i].header = HEADER_LV;
+	}
+	descs[sg_len - 1].header |= HEADER_LE;
+	descs[sg_len - 1].config &= ~CHCFG_DEM;
+	descs[sg_len - 1].next_lk_addr = 0;
+
+	/* and set DMARS register */
+	dmars = DMARS_RID(dmars_p->rid) | DMARS_MID(dmars_p->mid);
+	set_dmars_register(rza1dma, channel, dmars);
+
+	rza1dmac->chcfg = descs[sg_len - 1].config;
+	if(seten_flag == 1){
+		rza1dmac->chctrl = CHCTRL_SETEN;
+	}else{
+		rza1dmac->chctrl = 0;
+	}
+
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+
+}
+
+static int rza1dma_xfer_desc(struct rza1dma_desc *d)
+{
+	/* Configure and enable */
+	switch (d->type) {
+	case RZA1DMA_DESC_MEMCPY:
+		prepare_desc_for_memcpy(d);
+		break;
+
+	case RZA1DMA_DESC_SLAVE_SG:
+		prepare_descs_for_slave_sg(d);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	rza1dma_enable_hw(d);
+	return 0;
+}
+
+static void rza1dma_tasklet(unsigned long data)
+{
+	struct rza1dma_channel *rza1dmac = (void *)data;
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1dma_desc *desc;
+	unsigned long flags;
+
+	dev_dbg(rza1dma->dev, "%s called\n", __func__);
+
+	/* Protection of critical section */
+	spin_lock_irqsave(&rza1dma->lock, flags);
+
+	if (list_empty(&rza1dmac->ld_active)) {
+		/* Someone might have called terminate all */
+		goto out;
+	}
+
+	desc = list_first_entry(&rza1dmac->ld_active, struct rza1dma_desc, node);
+
+	if (desc->desc.callback)
+		desc->desc.callback(desc->desc.callback_param);
+
+	dma_cookie_complete(&desc->desc);
+
+
+	if (list_empty(&rza1dmac->ld_active)) {
+		goto out;
+	}else{
+		list_move_tail(rza1dmac->ld_active.next, &rza1dmac->ld_free);
+	}
+
+	if (!list_empty(&rza1dmac->ld_queue)) {
+		desc = list_first_entry(&rza1dmac->ld_queue, struct rza1dma_desc,
+					node);
+		if (rza1dma_xfer_desc(desc) < 0){
+			dev_warn(rza1dma->dev, "%s: channel: %d couldn't xfer desc\n",
+				 __func__, rza1dmac->channel);
+		}else{
+			list_move_tail(rza1dmac->ld_queue.next, &rza1dmac->ld_active);
+		}
+	}
+out:
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+}
+
+static int rza1dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			unsigned long arg)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct dma_slave_config *dmaengine_cfg = (void *)arg;
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	unsigned long flags;
+
+	switch (cmd) {
+	case DMA_TERMINATE_ALL:
+		rza1dma_disable_hw(rza1dmac);
+
+		spin_lock_irqsave(&rza1dma->lock, flags);
+		list_splice_tail_init(&rza1dmac->ld_active, &rza1dmac->ld_free);
+		list_splice_tail_init(&rza1dmac->ld_queue, &rza1dmac->ld_free);
+		spin_unlock_irqrestore(&rza1dma->lock, flags);
+		return 0;
+	case DMA_SLAVE_CONFIG:
+		if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
+			rza1dmac->per_address = dmaengine_cfg->src_addr;
+			rza1dmac->word_size = dmaengine_cfg->src_addr_width;
+		} else {
+			rza1dmac->per_address = dmaengine_cfg->dst_addr;
+			rza1dmac->word_size = dmaengine_cfg->dst_addr_width;
+		}
+		return 0;
+	default:
+		return -ENOSYS;
+	}
+
+	return -EINVAL;
+}
+
+static const struct rza1_dma_slave_config *dma_find_slave(
+		const struct rza1_dma_slave_config *slave,
+		int slave_num,
+		int slave_id)
+{
+	int i;
+
+	for (i = 0; i < slave_num; i++) {
+		const struct rza1_dma_slave_config *t = &slave[i];
+
+		if (slave_id == t->slave_id)
+			return t;
+	}
+
+	return NULL;
+}
+
+bool rza1dma_chan_filter(struct dma_chan *chan, void *arg)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1_dma_pdata *pdata = rza1dma->pdata;
+	const struct rza1_dma_slave_config *slave = pdata->slave;
+	const struct rza1_dma_slave_config *hit;
+	int slave_num = pdata->slave_num;
+	int slave_id = (int)arg;
+
+	hit = dma_find_slave(slave, slave_num, slave_id);
+	if (hit) {
+		rza1dmac->slave = hit;
+		return true;
+	}
+	return false;
+}
+EXPORT_SYMBOL(rza1dma_chan_filter);
+
+static enum dma_status rza1dma_tx_status(struct dma_chan *chan,
+					dma_cookie_t cookie,
+					struct dma_tx_state *txstate)
+{
+	return dma_cookie_status(chan, cookie, txstate);
+}
+
+static dma_cookie_t rza1dma_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct dma_chan *chan = tx->chan;
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rza1dma->lock, flags);
+	list_move_tail(rza1dmac->ld_free.next, &rza1dmac->ld_queue);
+	cookie = dma_cookie_assign(tx);
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+
+	return cookie;
+}
+
+static int rza1dma_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1_dma_pdata *pdata = rza1dma->pdata;
+	const struct rza1_dma_slave_config *slave = pdata->slave;
+	const struct rza1_dma_slave_config *hit;
+	int slave_num = pdata->slave_num;
+	int *slave_id = chan->private;
+
+	if (slave_id) {
+		hit = dma_find_slave(slave, slave_num, *slave_id);
+		if (!hit)
+			return -ENODEV;
+		rza1dmac->slave = hit;
+	}
+
+	while (rza1dmac->descs_allocated < RZA1DMA_MAX_CHAN_DESCRIPTORS) {
+		struct rza1dma_desc *desc;
+
+		desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+		if (!desc)
+			break;
+		__memzero(&desc->desc, sizeof(struct dma_async_tx_descriptor));
+		dma_async_tx_descriptor_init(&desc->desc, chan);
+		desc->desc.tx_submit = rza1dma_tx_submit;
+		/* txd.flags will be overwritten in prep funcs */
+		desc->desc.flags = DMA_CTRL_ACK;
+		desc->status = DMA_COMPLETE;
+
+		list_add_tail(&desc->node, &rza1dmac->ld_free);
+		rza1dmac->descs_allocated++;
+	}
+	if (!rza1dmac->descs_allocated)
+		return -ENOMEM;
+
+	return rza1dmac->descs_allocated;
+}
+
+static void rza1dma_free_chan_resources(struct dma_chan *chan)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct format_desc *descs = rza1dmac->desc_base;
+	struct rza1dma_desc *desc, *_desc;
+	unsigned long flags;
+	unsigned int i;
+
+	spin_lock_irqsave(&rza1dma->lock, flags);
+
+	for (i = 0; i < FORMAT_DESC_NUM; i++) {
+		descs[i].header = 0;
+	}
+
+	rza1dma_disable_hw(rza1dmac);
+	list_splice_tail_init(&rza1dmac->ld_active, &rza1dmac->ld_free);
+	list_splice_tail_init(&rza1dmac->ld_queue, &rza1dmac->ld_free);
+
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+
+	list_for_each_entry_safe(desc, _desc, &rza1dmac->ld_free, node) {
+		kfree(desc);
+		rza1dmac->descs_allocated--;
+	}
+	INIT_LIST_HEAD(&rza1dmac->ld_free);
+}
+
+static struct dma_async_tx_descriptor *rza1dma_prep_slave_sg(
+		struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_transfer_direction direction,
+		unsigned long flags, void *context)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct scatterlist *sg;
+	int i, dma_length = 0;
+	struct rza1dma_desc *desc;
+
+	if (list_empty(&rza1dmac->ld_free))
+		return NULL;
+
+	desc = list_first_entry(&rza1dmac->ld_free, struct rza1dma_desc, node);
+
+	for_each_sg(sgl, sg, sg_len, i) {
+		dma_length += sg_dma_len(sg);
+	}
+
+	desc->type = RZA1DMA_DESC_SLAVE_SG;
+	desc->sg = sgl;
+	desc->sgcount = sg_len;
+	desc->len = dma_length;
+	desc->direction = direction;
+
+	if (direction == DMA_DEV_TO_MEM)
+		desc->src = rza1dmac->per_address;
+	else
+		desc->dest = rza1dmac->per_address;
+
+	desc->desc.callback = NULL;
+	desc->desc.callback_param = NULL;
+
+	return &desc->desc;
+}
+
+static struct dma_async_tx_descriptor *rza1dma_prep_dma_memcpy(
+	struct dma_chan *chan, dma_addr_t dest,
+	dma_addr_t src, size_t len, unsigned long flags)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1dma_desc *desc;
+
+	dev_dbg(rza1dma->dev, "%s channel: %d src=0x%x dst=0x%x len=%d\n",
+			__func__, rza1dmac->channel, src, dest, len);
+
+	if (list_empty(&rza1dmac->ld_free))
+		return NULL;
+
+	desc = list_first_entry(&rza1dmac->ld_free, struct rza1dma_desc, node);
+
+	desc->type = RZA1DMA_DESC_MEMCPY;
+	desc->src = src;
+	desc->dest = dest;
+	desc->len = len;
+	desc->direction = DMA_MEM_TO_MEM;
+	desc->desc.callback = NULL;
+	desc->desc.callback_param = NULL;
+
+	return &desc->desc;
+}
+
+static void rza1dma_issue_pending(struct dma_chan *chan)
+{
+	struct rza1dma_channel *rza1dmac = to_rza1dma_chan(chan);
+	struct rza1dma_engine *rza1dma = rza1dmac->rza1dma;
+	struct rza1dma_desc *desc;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rza1dma->lock, flags);
+
+	/* queue is piled up on the next active even during execution DMA forwarding */
+	if (!list_empty(&rza1dmac->ld_queue)) {
+		desc = list_first_entry(&rza1dmac->ld_queue,
+					struct rza1dma_desc, node);
+
+		if (rza1dma_xfer_desc(desc) < 0) {
+			dev_warn(rza1dma->dev,
+				 "%s: channel: %d couldn't issue DMA xfer\n",
+				 __func__, rza1dmac->channel);
+		} else {
+			list_move_tail(rza1dmac->ld_queue.next,
+				       &rza1dmac->ld_active);
+		}
+	}
+	spin_unlock_irqrestore(&rza1dma->lock, flags);
+}
+
+static int __init rza1dma_probe(struct platform_device *pdev)
+{
+	struct rza1_dma_pdata *pdata = pdev->dev.platform_data;
+	int channel_num = pdata->channel_num;
+	struct rza1dma_engine *rza1dma;
+	struct resource *base_res, *ext_res, *cirq_res, *eirq_res;
+	int ret, i;
+	int irq, irq_err;
+
+	rza1dma = devm_kzalloc(&pdev->dev, sizeof(*rza1dma), GFP_KERNEL);
+	if (!rza1dma)
+		return -ENOMEM;
+
+	/* Get io base address */
+	base_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!base_res)
+		return -ENODEV;
+	rza1dma->base = devm_request_and_ioremap(&pdev->dev, base_res);
+	if (!rza1dma->base)
+		return -EADDRNOTAVAIL;
+
+	/* Get extension io base address */
+	ext_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!ext_res)
+		return -ENODEV;
+	rza1dma->ext_base = devm_request_and_ioremap(&pdev->dev, ext_res);
+	if (!rza1dma->ext_base)
+		return -EADDRNOTAVAIL;
+
+	/* Register interrupt handler for channels */
+	cirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!cirq_res)
+		return -ENODEV;
+
+	for (irq = cirq_res->start; irq <= cirq_res->end; irq++) {
+		ret = devm_request_irq(&pdev->dev, irq,
+				       rza1dma_irq_handler, 0, "RZA1DMA", rza1dma);
+		if (ret) {
+			dev_warn(rza1dma->dev, "Can't register IRQ for DMA\n");
+			goto err;
+		}
+	}
+
+	/* Register interrupt handler for error */
+	eirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
+	if (!eirq_res)
+		return -ENODEV;
+
+	irq_err = eirq_res->start;
+	ret = devm_request_irq(&pdev->dev, irq_err,
+				rza1dma_irq_handler, 0, "RZA1DMA_E", rza1dma);
+	if (ret) {
+		dev_warn(rza1dma->dev, "Can't register ERRIRQ for DMA\n");
+		goto err;
+	}
+
+	INIT_LIST_HEAD(&rza1dma->dma_device.channels);
+	dma_cap_set(DMA_SLAVE, rza1dma->dma_device.cap_mask);
+	dma_cap_set(DMA_MEMCPY, rza1dma->dma_device.cap_mask);
+	spin_lock_init(&rza1dma->lock);
+
+	rza1dma->channel = devm_kzalloc(&pdev->dev,
+				sizeof(struct rza1dma_channel) * channel_num,
+				GFP_KERNEL);
+
+	/* Initialize channel parameters */
+	for (i = 0; i < channel_num; i++) {
+		struct rza1dma_channel *rza1dmac = &rza1dma->channel[i];
+
+		rza1dmac->rza1dma = rza1dma;
+
+		INIT_LIST_HEAD(&rza1dmac->ld_queue);
+		INIT_LIST_HEAD(&rza1dmac->ld_free);
+		INIT_LIST_HEAD(&rza1dmac->ld_active);
+
+		tasklet_init(&rza1dmac->dma_tasklet, rza1dma_tasklet,
+			     (unsigned long)rza1dmac);
+		rza1dmac->chan.device = &rza1dma->dma_device;
+		dma_cookie_init(&rza1dmac->chan);
+		rza1dmac->channel = i;
+
+		/* Set io base address for each channel */
+		if (i < 8) {
+			rza1dmac->ch_base = rza1dma->base + CHANNEL_0_7_OFFSET +
+						EACH_CHANNEL_OFFSET * i;
+			rza1dmac->ch_cmn_base = rza1dma->base +
+						CHANNEL_0_7_COMMON_BASE;
+		} else {
+			rza1dmac->ch_base = rza1dma->base + CHANNEL_8_15_OFFSET	+
+						EACH_CHANNEL_OFFSET * (i - 8);
+			rza1dmac->ch_cmn_base = rza1dma->base +
+						CHANNEL_8_15_COMMON_BASE;
+		}
+		/* Allocate descriptors */
+		rza1dmac->desc_base = dma_alloc_coherent(NULL,
+					sizeof(struct format_desc) * FORMAT_DESC_NUM,
+					&rza1dmac->desc_base_dma,
+					GFP_KERNEL);
+		/* Add the channel to the DMAC list */
+		list_add_tail(&rza1dmac->chan.device_node,
+			      &rza1dma->dma_device.channels);
+
+		/* Initialize register for each channel */
+		rza1dma_ch_writel(rza1dmac, CHCTRL_DEFAULT, CHCTRL, 1);
+	}
+
+	/* Initialize register for all channels */
+	rza1dma_writel(rza1dma, DCTRL_DEFAULT, CHANNEL_0_7_COMMON_BASE	+ DCTRL);
+	rza1dma_writel(rza1dma, DCTRL_DEFAULT, CHANNEL_8_15_COMMON_BASE + DCTRL);
+
+	rza1dma->pdata = pdata;
+	rza1dma->dev = &pdev->dev;
+	rza1dma->dma_device.dev = &pdev->dev;
+
+	rza1dma->dma_device.device_alloc_chan_resources = rza1dma_alloc_chan_resources;
+	rza1dma->dma_device.device_free_chan_resources = rza1dma_free_chan_resources;
+	rza1dma->dma_device.device_tx_status = rza1dma_tx_status;
+	rza1dma->dma_device.device_prep_slave_sg = rza1dma_prep_slave_sg;
+	rza1dma->dma_device.device_prep_dma_memcpy = rza1dma_prep_dma_memcpy;
+	rza1dma->dma_device.device_control = rza1dma_control;
+	rza1dma->dma_device.device_issue_pending = rza1dma_issue_pending;
+
+	platform_set_drvdata(pdev, rza1dma);
+
+	rza1dma->dma_device.copy_align = 0; /* Set copy_align to zero for net_dma_find_channel
+					     * func to run well. But it might cause problems.
+					     */
+	rza1dma->dma_device.copy_align = 0;
+	rza1dma->dma_device.dev->dma_parms = &rza1dma->dma_parms;
+	dma_set_max_seg_size(rza1dma->dma_device.dev, 0xffffff);
+
+	ret = dma_async_device_register(&rza1dma->dma_device);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register\n");
+		goto err;
+	}
+	return 0;
+err:
+	return ret;
+}
+
+static int __exit rza1dma_remove(struct platform_device *pdev)
+{
+	struct rza1dma_engine *rza1dma = platform_get_drvdata(pdev);
+	struct rza1_dma_pdata *pdata = rza1dma->pdata;
+	int i, channel_num = pdata->channel_num;
+
+	/* free allocated resources */
+	for (i = 0; i < channel_num; i++) {
+		struct rza1dma_channel *rza1dmac = &rza1dma->channel[i];
+
+		dma_free_coherent(NULL,
+				sizeof(struct format_desc) * FORMAT_DESC_NUM,
+				rza1dmac->desc_base,
+				rza1dmac->desc_base_dma);
+	}
+
+	dma_async_device_unregister(&rza1dma->dma_device);
+	return 0;
+}
+
+static struct platform_driver rza1dma_driver = {
+	.driver		= {
+		.name	= "rza1-dma",
+	},
+	.remove		= __exit_p(rza1dma_remove),
+};
+
+static int __init rza1dma_module_init(void)
+{
+	return platform_driver_probe(&rza1dma_driver, rza1dma_probe);
+}
+subsys_initcall(rza1dma_module_init);
+
+MODULE_AUTHOR("RSO");
+MODULE_DESCRIPTION("Renesas RZA1 DMA Engine driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index de17c55..402ef32 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -658,6 +658,19 @@ config I2C_RIIC
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-riic.
 
+config I2C_RIIC_RZA1
+	tristate "Renesas RIIC adapter (Alternate for RZA1)"
+	depends on ARCH_R7S72100
+	help
+	  If you say yes to this option, support will be included for the
+	  Renesas RIIC I2C interface.
+
+	  This driver is more stable and more featured than the standard
+	  riic.c version.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-riic.
+
 config HAVE_S3C2410_I2C
 	bool
 	help
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index a08931f..3078d88 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -64,6 +64,7 @@ obj-$(CONFIG_I2C_PUV3)		+= i2c-puv3.o
 obj-$(CONFIG_I2C_PXA)		+= i2c-pxa.o
 obj-$(CONFIG_I2C_PXA_PCI)	+= i2c-pxa-pci.o
 obj-$(CONFIG_I2C_RIIC)		+= i2c-riic.o
+obj-$(CONFIG_I2C_RIIC_RZA1)	+= i2c-riic_rza1.o
 obj-$(CONFIG_I2C_S3C2410)	+= i2c-s3c2410.o
 obj-$(CONFIG_I2C_S6000)		+= i2c-s6000.o
 obj-$(CONFIG_I2C_SH7760)	+= i2c-sh7760.o
diff --git a/drivers/i2c/busses/i2c-riic.c b/drivers/i2c/busses/i2c-riic.c
index 9e1f8ba..56b1598 100644
--- a/drivers/i2c/busses/i2c-riic.c
+++ b/drivers/i2c/busses/i2c-riic.c
@@ -46,6 +46,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/i2c-riic.h>
 
 #define RIIC_ICCR1	0x00
 #define RIIC_ICCR2	0x04
@@ -333,6 +334,7 @@ static int riic_i2c_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct riic_dev *riic;
+	struct riic_platform_data *pdata;
 	struct i2c_adapter *adap;
 	struct resource *res;
 	u32 bus_rate = 0;
@@ -366,6 +368,8 @@ static int riic_i2c_probe(struct platform_device *pdev)
 		}
 	}
 
+	pdata = dev_get_platdata(&pdev->dev);
+
 	adap = &riic->adapter;
 	i2c_set_adapdata(adap, riic);
 	strlcpy(adap->name, "Renesas RIIC adapter", sizeof(adap->name));
@@ -376,7 +380,11 @@ static int riic_i2c_probe(struct platform_device *pdev)
 
 	init_completion(&riic->msg_done);
 
-	of_property_read_u32(np, "clock-frequency", &bus_rate);
+	if (pdata) {
+		bus_rate = pdata->bus_rate;
+	} else {	
+		of_property_read_u32(np, "clock-frequency", &bus_rate);
+	}
 	ret = riic_init_hw(riic, bus_rate);
 	if (ret)
 		return ret;
@@ -404,7 +412,7 @@ static int riic_i2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static struct of_device_id riic_i2c_dt_ids[] = {
+static const struct of_device_id riic_i2c_dt_ids[] = {
 	{ .compatible = "renesas,riic-rz" },
 	{ /* Sentinel */ },
 };
diff --git a/drivers/i2c/busses/i2c-riic_rza1.c b/drivers/i2c/busses/i2c-riic_rza1.c
new file mode 100644
index 0000000..b4acf69
--- /dev/null
+++ b/drivers/i2c/busses/i2c-riic_rza1.c
@@ -0,0 +1,1370 @@
+/*
+ * RIIC bus driver
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ *
+ * Based on i2c-sh_mobile.c
+ * Copyright (C) 2008 Magnus Damm
+ *
+ * Portions of the code based on out-of-tree driver i2c-sh7343.c
+ * Copyright (c) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/i2c/riic_rza1.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#ifdef CONFIG_ARCH_R7S
+#  include <mach/rza1.h>
+#endif
+
+#define DRIVER_VERSION	"2013-04-19"
+
+#ifdef CONFIG_ARCH_R7S72100
+
+#define RIIC_ICCR1	0x00
+#define RIIC_ICCR2	0x04
+#define RIIC_ICMR1	0x08
+#define RIIC_ICMR2	0x0c
+#define RIIC_ICMR3	0x10
+#define RIIC_ICFER	0x14
+#define RIIC_ICSER	0x18
+#define RIIC_ICIER	0x1c
+#define RIIC_ICSR1	0x20
+#define RIIC_ICSR2	0x24
+#define RIIC_ICBRL	0x34
+#define RIIC_ICBRH	0x38
+#define RIIC_ICDRT	0x3c
+#define RIIC_ICDRR	0x40
+
+/* ICCR1 */
+#define ICCR1_ICE	0x80
+#define ICCR1_IICRST	0x40
+#define ICCR1_CLO	0x20
+#define ICCR1_SOWP	0x10
+#define ICCR1_SCLO	0x08
+#define ICCR1_SDAO	0x04
+#define ICCR1_SCLI	0x02
+#define ICCR1_SDAI	0x01
+
+/* ICCR2 */
+#define ICCR2_BBSY	0x80
+#define ICCR2_MST	0x40
+#define ICCR2_TRS	0x20
+#define ICCR2_SP	0x08
+#define ICCR2_RS	0x04
+#define ICCR2_ST	0x02
+
+/* ICMR1 */
+#define ICMR1_MTWP	0x80
+#define ICMR1_CKS_MASK	0x70
+#define ICMR1_BCWP	0x08
+#define ICMR1_BC_MASK	0x07
+
+#define ICMR1_CKS(_x)	(((_x) << 4) & ICMR1_CKS_MASK)
+#define ICMR1_BC(_x)	((_x) & ICMR1_BC_MASK)
+
+/* ICMR2 */
+#define ICMR2_DLCS	0x80
+#define ICMR2_SDDL_MASK	0x70
+#define ICMR2_TMOH	0x04
+#define ICMR2_TMOL	0x02
+#define ICMR2_TMOS	0x01
+
+/* ICMR3 */
+#define ICMR3_SMBS	0x80
+#define ICMR3_WAIT	0x40
+#define ICMR3_RDRFS	0x20
+#define ICMR3_ACKWP	0x10
+#define ICMR3_ACKBT	0x08
+#define ICMR3_ACKBR	0x04
+#define ICMR3_NF_MASK	0x03
+
+/* ICFER */
+#define ICFER_FMPE	0x80
+#define ICFER_SCLE	0x40
+#define ICFER_NFE	0x20
+#define ICFER_NACKE	0x10
+#define ICFER_SALE	0x08
+#define ICFER_NALE	0x04
+#define ICFER_MALE	0x02
+#define ICFER_TMOE	0x01
+
+/* ICSER */
+#define ICSER_HOAE	0x80
+#define ICSER_DIDE	0x20
+#define ICSER_GCAE	0x08
+#define ICSER_SAR2E	0x04
+#define ICSER_SAR1E	0x02
+#define ICSER_SAR0E	0x01
+
+/* ICIER */
+#define ICIER_TIE	0x80
+#define ICIER_TEIE	0x40
+#define ICIER_RIE	0x20
+#define ICIER_NAKIE	0x10
+#define ICIER_SPIE	0x08
+#define ICIER_STIE	0x04
+#define ICIER_ALIE	0x02
+#define ICIER_TMOIE	0x01
+
+/* ICSR1 */
+#define ICSR1_HOA	0x80
+#define ICSR1_DID	0x20
+#define ICSR1_GCA	0x08
+#define ICSR1_AAS2	0x04
+#define ICSR1_AAS1	0x02
+#define ICSR1_AAS0	0x01
+
+/* ICSR2 */
+#define ICSR2_TDRE	0x80
+#define ICSR2_TEND	0x40
+#define ICSR2_RDRF	0x20
+#define ICSR2_NACKF	0x10
+#define ICSR2_STOP	0x08
+#define ICSR2_START	0x04
+#define ICSR2_AL	0x02
+#define ICSR2_TMOF	0x01
+
+/* SARLn */
+#define SARL_SVA_MASK	0xfe	/* SVA[7:1] */
+#define SARL_SVA	0x01
+
+/* SARUn */
+#define SARU_SVA_MASK	0x06	/* SVA[9:8] */
+#define SARU_FS		0x01
+
+/* ICBRH */
+#define ICBRH_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRH_BRH_MASK	0x1f
+#define ICBRH_SP100K	16	/* PCLK 33MHz */
+#define ICBRH_SP400K	9
+#define ICBRH_SP1000K	14
+
+/* ICBRL */
+#define ICBRL_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRL_BRL_MASK	0x1f
+#define ICBRL_SP100K	19	/* PCLK 33MHz */
+#define ICBRL_SP400K	21
+#define ICBRL_SP1000K	14
+
+#define RIIC_CORE_PARAM_NUM_SLAVE_BUFFERS	16
+
+#define RIIC_NUM_CHANNELS	4
+
+static const char * const riic_name[RIIC_NUM_CHANNELS] = {
+	"riic.0", "riic.1", "riic.2", "riic.3",
+};
+
+enum {
+	RIIC_TXI,
+	RIIC_TEI,
+	RIIC_RXI,
+	RIIC_SPI,
+	RIIC_STI,
+	RIIC_NAK,
+	RIIC_ALI,
+	RIIC_TMOI,
+};
+
+#else /* default RIIC */
+
+#define RIIC_ICCR1	0x00
+#define RIIC_ICCR2	0x01
+#define RIIC_ICMR1	0x02
+#define RIIC_ICMR2	0x03
+#define RIIC_ICMR3	0x04
+#define RIIC_ICFER	0x05
+#define RIIC_ICSER	0x06
+#define RIIC_ICIER	0x07
+#define RIIC_ICSR1	0x08
+#define RIIC_ICSR2	0x09
+#define RIIC_SARL0	0x0a
+#define RIIC_SARU0	0x0b
+#define RIIC_SARL1	0x0c
+#define RIIC_SARU1	0x0d
+#define RIIC_SARL2	0x0e
+#define RIIC_SARU2	0x0f
+#define RIIC_ICBRL	0x10
+#define RIIC_ICBRH	0x11
+#define RIIC_ICDRT	0x12
+#define RIIC_ICDRR	0x13
+
+/* ICCR1 */
+#define ICCR1_ICE	0x80
+#define ICCR1_IICRST	0x40
+#define ICCR1_CLO	0x20
+#define ICCR1_SOWP	0x10
+#define ICCR1_SCLO	0x08
+#define ICCR1_SDAO	0x04
+#define ICCR1_SCLI	0x02
+#define ICCR1_SDAI	0x01
+
+/* ICCR2 */
+#define ICCR2_BBSY	0x80
+#define ICCR2_MST	0x40
+#define ICCR2_TRS	0x20
+#define ICCR2_SP	0x08
+#define ICCR2_RS	0x04
+#define ICCR2_ST	0x02
+
+/* ICMR1 */
+#define ICMR1_MTWP	0x80
+#define ICMR1_CKS_MASK	0x70
+#define ICMR1_BCWP	0x08
+#define ICMR1_BC_MASK	0x07
+
+#define ICMR1_CKS(_x)	((_x << 4) & ICMR1_CKS_MASK)
+#define ICMR1_BC(_x)	((_x) & ICMR1_BC_MASK)
+
+/* ICMR2 */
+#define ICMR2_DLCS	0x80
+#define ICMR2_SDDL_MASK	0x70
+#define ICMR2_TMOH	0x04
+#define ICMR2_TMOL	0x02
+#define ICMR2_TMOS	0x01
+
+/* ICMR3 */
+#define ICMR3_SMBS	0x80
+#define ICMR3_WAIT	0x40
+#define ICMR3_RDRFS	0x20
+#define ICMR3_ACKWP	0x10
+#define ICMR3_ACKBT	0x08
+#define ICMR3_ACKBR	0x04
+#define ICMR3_NF_MASK	0x03
+
+/* ICFER */
+#define ICFER_FMPE	0x80
+#define ICFER_SCLE	0x40
+#define ICFER_NFE	0x20
+#define ICFER_NACKE	0x10
+#define ICFER_SALE	0x08
+#define ICFER_NALE	0x04
+#define ICFER_MALE	0x02
+#define ICFER_TMOE	0x01
+
+/* ICSER */
+#define ICSER_HOAE	0x80
+#define ICSER_DIDE	0x20
+#define ICSER_GCAE	0x08
+#define ICSER_SAR2E	0x04
+#define ICSER_SAR1E	0x02
+#define ICSER_SAR0E	0x01
+
+/* ICIER */
+#define ICIER_TIE	0x80
+#define ICIER_TEIE	0x40
+#define ICIER_RIE	0x20
+#define ICIER_NAKIE	0x10
+#define ICIER_SPIE	0x08
+#define ICIER_STIE	0x04
+#define ICIER_ALIE	0x02
+#define ICIER_TMOIE	0x01
+
+/* ICSR1 */
+#define ICSR1_HOA	0x80
+#define ICSR1_DID	0x20
+#define ICSR1_GCA	0x08
+#define ICSR1_AAS2	0x04
+#define ICSR1_AAS1	0x02
+#define ICSR1_AAS0	0x01
+
+/* ICSR2 */
+#define ICSR2_TDRE	0x80
+#define ICSR2_TEND	0x40
+#define ICSR2_RDRF	0x20
+#define ICSR2_NACKF	0x10
+#define ICSR2_STOP	0x08
+#define ICSR2_START	0x04
+#define ICSR2_AL	0x02
+#define ICSR2_TMOF	0x01
+
+/* SARLn */
+#define SARL_SVA_MASK	0xfe	/* SVA[7:1] */
+#define SARL_SVA	0x01
+
+/* SARUn */
+#define SARU_SVA_MASK	0x06	/* SVA[9:8] */
+#define SARU_FS		0x01
+
+/* ICBRH */
+#define ICBRH_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRH_BRH_MASK	0x1f
+
+/* ICBRL */
+#define ICBRL_RESERVED	0xe0	/* The write value shoud always be 1 */
+#define ICBRL_BRL_MASK	0x1f
+
+#define RIIC_CORE_PARAM_NUM_SLAVE_BUFFERS	16
+
+#define RIIC_NUM_CHANNELS	4
+
+static const char * const riic_name[RIIC_NUM_CHANNELS] = {
+	"riic.0", "riic.1", "riic.2", "riic.3",
+};
+
+enum {
+	RIIC_TXI,
+	RIIC_TEI,
+	RIIC_RXI,
+	RIIC_SPI,
+	RIIC_STI,
+	RIIC_NAK,
+	RIIC_ALI,
+	RIIC_TMOI,
+};
+#endif /* default RIIC */
+
+#define RIIC_TIMEOUT	10000	/* 100msec (unit = 10usec) */
+
+/* Error codes */
+enum {
+	RIIC_CORE_NO_ERROR = 0,
+	RIIC_CORE_INVALID,
+	RIIC_CORE_BUSY,
+	RIIC_CORE_TIMEOUT,
+	RIIC_CORE_AL_ADDR,
+	RIIC_CORE_AL_DATA,
+	RIIC_CORE_NACK_ADDR,
+	RIIC_CORE_NACK_DATA,
+};
+
+enum riic_state {
+	RIIC_STATE_IDLE,
+	RIIC_STATE_MASTER,
+	RIIC_STATE_SLAVE,
+	RIIC_STATE_BUS_RECOVERY
+};
+
+enum riic_master_state {
+	RIIC_MASTER_PREPARE,
+	RIIC_MASTER_ISSUED_START,
+	RIIC_MASTER_SENT_SLAVE_ADDRESS_NEXT,
+	RIIC_MASTER_SENT_SLAVE_ADDRESS,
+	RIIC_MASTER_DMAC_FINISHED,
+	RIIC_MASTER_TRANSMITTING,
+	RIIC_MASTER_TRANSMIT_LAST,
+	RIIC_MASTER_RECEIVING,
+	RIIC_MASTER_RECEIVE_LAST,
+	RIIC_MASTER_ISSUED_STOP,
+	RIIC_MASTER_END,
+};
+
+enum riic_slave_state {
+	RIIC_SLAVE_ISSUED_START,
+	RIIC_SLAVE_START_XFER,
+	RIIC_SLAVE_DMAC_FINISHED,
+	RIIC_SLAVE_ISSUED_STOP,
+	RIIC_SLAVE_ISSUED_RESTART,
+	RIIC_SLAVE_TIMEOUT,
+};
+
+#define NUM_IRQ 8
+
+struct riic_data {
+	struct device *dev;
+	struct clk *clk;
+	void __iomem *reg;
+	struct i2c_adapter adap;
+	struct i2c_msg *msg;
+	int		channel;
+	const char	*name;
+	enum riic_state	state;
+	int irq[NUM_IRQ];
+	int irqn;
+	spinlock_t	lock;
+
+	/* for master mode */
+	enum riic_master_state	master_state;
+	struct riic_core_packet	*pkt;
+	int			num_pkt;
+	int			pkt_index;
+	wait_queue_head_t	wait;
+	int			sending_addr;	/* for _AL or _NACK */
+
+	/* for slave mode */
+	enum riic_slave_state	slave_state;
+	struct riic_core_packet	slv_rx_pkt[RIIC_CORE_PARAM_NUM_SLAVE_BUFFERS];
+	int			slv_rx_head;
+	int			slv_rx_tail;
+	int			slv_timeout;
+	wait_queue_head_t	slv_wait;
+	struct timer_list	slv_timer;
+
+	/* status */
+	unsigned	slave_enabled:1;
+
+	/* status for master mode */
+	unsigned	completed:1;
+	unsigned	aled:1;
+	unsigned	nacked:1;
+
+	/* for debug */
+	int		debug;
+	enum riic_state	old_state;
+	unsigned char	old_icsr2;
+};
+
+static unsigned char riic_read(struct riic_data *rd, unsigned long addr)
+{
+	return ioread8(rd->reg + addr);
+}
+
+static void riic_write(struct riic_data *rd, unsigned char data,
+		       unsigned long addr)
+{
+	iowrite8(data, rd->reg + addr);
+}
+
+static void riic_set_bit(struct riic_data *rd, unsigned char val,
+			 unsigned long offset)
+{
+	unsigned char tmp;
+
+	tmp = riic_read(rd, offset) | val;
+	riic_write(rd, tmp, offset);
+}
+
+static void riic_clear_bit(struct riic_data *rd, unsigned char val,
+			   unsigned long offset)
+{
+	unsigned char tmp;
+
+	tmp = riic_read(rd, offset) & ~val;
+	riic_write(rd, tmp, offset);
+}
+
+static int riic_set_clock(struct riic_data *rd, int clock)
+{
+	switch (clock) {
+	case 100:
+		riic_clear_bit(rd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(rd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(rd, ICMR1_CKS(3), RIIC_ICMR1);
+		riic_write(rd, ICBRH_RESERVED | ICBRH_SP100K, RIIC_ICBRH);
+		riic_write(rd, ICBRL_RESERVED | ICBRL_SP100K, RIIC_ICBRL);
+		break;
+	case 400:
+		riic_clear_bit(rd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(rd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(rd, ICMR1_CKS(1), RIIC_ICMR1);
+		riic_write(rd, ICBRH_RESERVED | ICBRH_SP400K, RIIC_ICBRH);
+		riic_write(rd, ICBRL_RESERVED | ICBRL_SP400K, RIIC_ICBRL);
+		break;
+	case 1000:
+		riic_set_bit(rd, ICFER_FMPE, RIIC_ICFER);
+		riic_clear_bit(rd, ICMR1_CKS_MASK, RIIC_ICMR1);
+		riic_set_bit(rd, ICMR1_CKS(0), RIIC_ICMR1);
+		riic_write(rd, ICBRH_RESERVED | ICBRH_SP1000K, RIIC_ICBRH);
+		riic_write(rd, ICBRL_RESERVED | ICBRL_SP1000K, RIIC_ICBRL);
+		break;
+
+	default:
+		dev_err(rd->dev, "unsupported clock (%dkHz)\n", clock);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int riic_init_setting(struct riic_data *rd, int clock)
+{
+	int ret;
+
+	riic_clear_bit(rd, ICCR1_ICE, RIIC_ICCR1);
+	riic_set_bit(rd, ICCR1_IICRST, RIIC_ICCR1);
+	riic_clear_bit(rd, ICCR1_IICRST, RIIC_ICCR1);
+
+#ifndef CONFIG_ARCH_R7S72100
+	riic_write(rd, 0, RIIC_SARL0);
+	riic_write(rd, 0, RIIC_SARU0);
+#endif
+	riic_write(rd, ICSER_SAR0E, RIIC_ICSER);
+
+	riic_write(rd, ICMR1_BC(7), RIIC_ICMR1);
+	ret = riic_set_clock(rd, clock);
+	if (ret < 0)
+		return ret;
+
+	riic_set_bit(rd, ICCR1_ICE, RIIC_ICCR1);	/* Enable RIIC */
+	riic_set_bit(rd, ICMR3_RDRFS | ICMR3_WAIT | ICMR3_ACKWP, RIIC_ICMR3);
+
+	return 0;
+}
+
+static int riic_check_busy(struct riic_data *rd)
+{
+	if (riic_read(rd, RIIC_ICCR2) & ICCR2_BBSY) {
+		dev_err(rd->dev, "i2c bus is busy.\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int riic_master_issue_stop(struct riic_data *rd)
+{
+	riic_clear_bit(rd, ICSR2_STOP | ICSR2_NACKF, RIIC_ICSR2);
+	if (riic_read(rd, RIIC_ICCR2) & ICCR2_MST) {
+		riic_set_bit(rd, ICIER_SPIE, RIIC_ICIER);
+		riic_set_bit(rd, ICCR2_SP, RIIC_ICCR2);
+		return 0;
+	}
+
+	return -EFAULT;
+}
+
+static int riic_send_slave_address(struct riic_data *rd, int read)
+{
+	unsigned char sa_rw[2];
+
+	if (rd->pkt->rw == RIIC_CORE_RW_MASTER_TRANSMIT) {
+		riic_set_bit(rd, ICIER_TEIE, RIIC_ICIER);
+		sa_rw[0] = (rd->pkt->slave_address << 1);
+	} else {
+		sa_rw[0] = ((rd->pkt->slave_address << 1) | 1);
+	}
+	riic_write(rd, sa_rw[0], RIIC_ICDRT);
+
+	return 0;
+}
+
+static void riic_master_try_to_free_sda(struct riic_data *rd)
+{
+	unsigned long flags;
+	int i, j;
+
+	if (!(riic_read(rd, RIIC_ICCR2) & ICCR2_MST))
+		return;
+	/* If SDA is already high, RIIC will not output extra SCL */
+	if (riic_read(rd, RIIC_ICCR1) & ICCR1_SDAI)
+		return;
+	/* If SCL is low held by other device, RIIC cannot output extra SCL */
+	if (!(riic_read(rd, RIIC_ICCR1) & ICCR1_SCLI))
+		return;
+
+	spin_lock_irqsave(&rd->lock, flags);
+	riic_clear_bit(rd, ICFER_MALE, RIIC_ICFER);
+	for (i = 0; i < 32; i++) {
+		if (riic_read(rd, RIIC_ICCR1) & ICCR1_SDAI)
+			break;
+
+		riic_set_bit(rd, ICCR1_CLO, RIIC_ICCR1);
+		j = 3000;
+		while (riic_read(rd, RIIC_ICCR1) & ICCR1_CLO) {
+			udelay(1);
+			if (j-- < 0) {
+				dev_err(rd->dev, "CLO timeout\n");
+				break;
+			}
+		}
+	}
+	riic_set_bit(rd, ICFER_MALE, RIIC_ICFER);
+	spin_unlock_irqrestore(&rd->lock, flags);
+}
+
+static void riic_master_clean_icier(struct riic_data *rd)
+{
+	/* disable for master mode */
+	riic_clear_bit(rd, ICIER_NAKIE | ICIER_ALIE | ICIER_TEIE | ICIER_SPIE,
+		       RIIC_ICIER);
+
+	/* enable for slave mode */
+	riic_set_bit(rd, ICIER_STIE, RIIC_ICIER);
+}
+
+static void riic_master_clean_up(struct riic_data *rd, int timeout)
+{
+	unsigned long flags;
+	int ret;
+	int retrycnt = 0;
+
+retry:
+	spin_lock_irqsave(&rd->lock, flags);
+	if (rd->state != RIIC_STATE_MASTER) {
+		spin_unlock_irqrestore(&rd->lock, flags);
+		return;
+	}
+	if (!(riic_read(rd, RIIC_ICCR2) & ICCR2_MST)) {
+		spin_unlock_irqrestore(&rd->lock, flags);
+		goto out;
+	}
+
+	rd->master_state = RIIC_MASTER_END;
+	/* dummy read if needed */
+	if (riic_read(rd, RIIC_ICSR2) & ICSR2_RDRF)
+		riic_read(rd, RIIC_ICDRR);
+	riic_master_try_to_free_sda(rd);
+	ret = riic_master_issue_stop(rd);
+	rd->completed = 0;
+	spin_unlock_irqrestore(&rd->lock, flags);
+
+	if (!ret)
+		ret = wait_event_interruptible_timeout(rd->wait, rd->completed,
+					msecs_to_jiffies(timeout));
+
+	/* if a signal happens, the driver sleeps a little to wait STOP */
+	if (ret == -ERESTARTSYS)
+		usleep_range(10000, 11000);
+
+	if (riic_read(rd, RIIC_ICCR2) & ICCR2_MST) {
+		/* riic_dump(rd, "re-issue stop"); */
+		if (retrycnt++ < rd->adap.retries)
+			goto retry;
+		dev_err(rd->dev, "Can't cleanup a I2C bus (iccr2:%x)\n",
+			riic_read(rd, RIIC_ICCR2));
+	}
+
+out:
+	spin_lock_irqsave(&rd->lock, flags);
+	rd->state = RIIC_STATE_IDLE;
+	riic_master_clean_icier(rd);
+	rd->pkt = NULL;
+	spin_unlock_irqrestore(&rd->lock, flags);
+}
+
+static int riic_master(struct riic_data *rd)
+{
+	int ret = 0;
+	int timeout = 1000;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rd->lock, flags);
+	rd->state = RIIC_STATE_MASTER;
+	rd->master_state = RIIC_MASTER_PREPARE;
+	rd->pkt_index = 0;
+	rd->completed = rd->nacked = rd->aled = 0;
+
+	riic_set_bit(rd, ICIER_STIE | ICIER_NAKIE | ICIER_ALIE, RIIC_ICIER);
+	riic_set_bit(rd, ICIER_RIE, RIIC_ICIER);
+	riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+
+	/* Send START */
+	riic_set_bit(rd, ICCR2_ST, RIIC_ICCR2);
+	spin_unlock_irqrestore(&rd->lock, flags);
+
+	ret = wait_event_interruptible_timeout(rd->wait, rd->completed ||
+			rd->nacked || rd->aled, msecs_to_jiffies(timeout));
+	if ((!rd->completed && ret == 0) || ret < 0) {
+		riic_master_clean_up(rd, timeout);
+		ret = RIIC_CORE_TIMEOUT;
+	} else if (rd->nacked) {
+		/* already issued stop in riic_irq_master_nackf() */
+		if (rd->sending_addr)
+			ret = RIIC_CORE_NACK_ADDR;
+		else
+			ret = RIIC_CORE_NACK_DATA;
+	} else if (rd->aled) {
+		if (rd->sending_addr)
+			ret = RIIC_CORE_AL_ADDR;
+		else
+			ret = RIIC_CORE_AL_DATA;
+	} else {
+		ret = RIIC_CORE_NO_ERROR;
+	}
+
+	return ret;
+}
+
+static int riic_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,
+		     int num)
+{
+	struct riic_data *rd = i2c_get_adapdata(adapter);
+	struct riic_core_packet *pkt;
+	int i, ret = 0;
+
+	if (riic_check_busy(rd))
+		return -EBUSY;
+
+	/* msgs to pkt */
+	pkt = kzalloc(sizeof(struct riic_core_packet) * num, GFP_KERNEL);
+	if (!pkt)
+		return -ENOMEM;
+	for (i = 0; i < num; i++) {
+		pkt[i].slave_address = msgs[i].addr;
+		if (msgs[i].flags & I2C_M_RD)
+			pkt[i].rw = RIIC_CORE_RW_MASTER_RECEIVE;
+		else
+			pkt[i].rw = RIIC_CORE_RW_MASTER_TRANSMIT;
+		pkt[i].len = msgs[i].len;
+		pkt[i].data = msgs[i].buf;
+	}
+	rd->pkt = pkt;
+	rd->num_pkt = num;
+
+	ret = riic_master(rd);
+	switch (ret) {
+	case RIIC_CORE_NO_ERROR:
+		ret = num;
+		break;
+	case RIIC_CORE_BUSY:
+		ret = -EBUSY;
+		break;
+	case RIIC_CORE_TIMEOUT:
+		ret = -ETIMEDOUT;
+		break;
+	case RIIC_CORE_AL_ADDR:
+		ret = -EFAULT;
+		break;
+	case RIIC_CORE_AL_DATA:
+		ret = -EIO;
+		break;
+	case RIIC_CORE_NACK_ADDR:
+		ret = -ENXIO;
+		break;
+	case RIIC_CORE_NACK_DATA:
+		ret = -EAGAIN;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	kfree(pkt);
+
+	return ret;
+}
+
+static u32 riic_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm riic_algorithm = {
+	.functionality	= riic_func,
+	.master_xfer	= riic_xfer,
+};
+
+static int riic_remove(struct platform_device *pdev)
+{
+	struct riic_data *rd = platform_get_drvdata(pdev);
+	int i;
+
+	if (!rd)
+		return 0;
+
+	i2c_del_adapter(&rd->adap);
+	for (i = 0; i < rd->irqn; i++)
+		free_irq(rd->irq[i], rd);
+	iounmap(rd->reg);
+	clk_disable(rd->clk);
+	clk_put(rd->clk);
+	kfree(rd);
+
+	return 0;
+}
+
+static int riic_master_is_sending_address(struct riic_data *rd)
+{
+	int ret = 0;
+
+	switch (rd->master_state) {
+	case RIIC_MASTER_PREPARE:
+	case RIIC_MASTER_ISSUED_START:
+		ret = 1;
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static void riic_slave_start_rx_timer(struct riic_data *rd)
+{
+	mod_timer(&rd->slv_timer, jiffies + msecs_to_jiffies(rd->slv_timeout));
+}
+
+static void riic_set_receive_ack(struct riic_data *rd, int ack)
+{
+	if (ack)
+		riic_clear_bit(rd, ICMR3_ACKBT, RIIC_ICMR3);
+	else
+		riic_set_bit(rd, ICMR3_ACKBT, RIIC_ICMR3);
+}
+
+static void riic_slave_prepare(struct riic_data *rd)
+{
+	riic_set_bit(rd, ICIER_SPIE, RIIC_ICIER);
+
+	if (!rd->slave_enabled)
+		return;
+
+	rd->state = RIIC_STATE_SLAVE;
+	rd->slave_state = RIIC_SLAVE_ISSUED_START;
+	riic_clear_bit(rd, ICIER_STIE, RIIC_ICIER);
+	riic_set_receive_ack(rd, 1);
+	riic_slave_start_rx_timer(rd);
+}
+
+static void riic_irq_master_al(struct riic_data *rd, unsigned char icsr2)
+{
+	rd->state = RIIC_STATE_IDLE;
+	rd->sending_addr = riic_master_is_sending_address(rd);
+	riic_master_clean_icier(rd);
+	riic_slave_prepare(rd);	/* enter RIIC_STATE_SLAVE */
+	rd->pkt = NULL;
+	rd->aled = 1;
+	wake_up_interruptible(&rd->wait);
+}
+
+static void riic_irq_master_nackf(struct riic_data *rd)
+{
+	if (rd->master_state != RIIC_MASTER_END) {
+		rd->sending_addr = riic_master_is_sending_address(rd);
+		rd->master_state = RIIC_MASTER_END;
+		riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+		riic_master_issue_stop(rd);
+	}
+
+	rd->nacked = 1;
+}
+
+/* Master Mode */
+static int riic_master_is_last_packet(struct riic_data *rd)
+{
+	if (rd->num_pkt - (rd->pkt_index + 1) == 0)
+		return 1;
+	else
+		return 0;
+}
+
+static int riic_pkt_buf_data_len(struct riic_data *rd)
+{
+	return rd->pkt->len - rd->pkt->buf_idx;
+}
+
+static void riic_write_pkt_buf(struct riic_data *rd)
+{
+	struct riic_core_packet *pkt = rd->pkt;
+	unsigned char *buf = (unsigned char *)rd->pkt->data;
+
+	riic_write(rd, buf[pkt->buf_idx++], RIIC_ICDRT);
+}
+
+static void riic_master_update_packet(struct riic_data *rd)
+{
+	/* update current pkt */
+	rd->pkt->done = 1;
+
+	/* increment pkt pointer if needed */
+	if (!riic_master_is_last_packet(rd)) {
+		rd->pkt++;
+		rd->pkt_index++;
+		rd->pkt->buf_idx = 0;
+	} else {
+		rd->pkt = NULL;
+	}
+}
+
+static int riic_enable_interrupt_transmit_end(struct riic_data *rd)
+{
+	if (!riic_pkt_buf_data_len(rd)) {
+		riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+		return -1;
+	}
+	riic_set_bit(rd, ICIER_TEIE, RIIC_ICIER);
+	return 0;
+}
+
+static void riic_master_kick_transmit(struct riic_data *rd)
+{
+	if (riic_enable_interrupt_transmit_end(rd))
+		return;
+
+	if (riic_pkt_buf_data_len(rd) >= 2) {
+		if (rd->master_state != RIIC_MASTER_TRANSMITTING) {
+			rd->master_state = RIIC_MASTER_TRANSMITTING;
+			rd->pkt->buf_idx = 0;
+		}
+	} else if (riic_pkt_buf_data_len(rd) == 1) {
+		rd->master_state = RIIC_MASTER_TRANSMIT_LAST;
+	} else {
+		dev_err(rd->dev, "got a zero buffer packet!\n");
+	}
+	riic_write_pkt_buf(rd);
+}
+
+static int riic_wait_for_icsr2(struct riic_data *rd, unsigned short bit);
+
+static void riic_read_receive_data(struct riic_data *rd, int clear_wait)
+{
+	struct riic_core_packet *pkt = rd->pkt;
+	unsigned char *buf = pkt->data;
+
+	if (riic_wait_for_icsr2(rd, ICSR2_RDRF) < 0)
+		;	/* An error message is already generated */
+
+	buf[pkt->buf_idx++] = riic_read(rd, RIIC_ICDRR);
+	if (clear_wait)
+		riic_clear_bit(rd, ICMR3_WAIT, RIIC_ICMR3);
+}
+
+static void riic_send_start_cond(struct riic_data *rd, int restart)
+{
+	riic_set_bit(rd, ICIER_STIE, RIIC_ICIER);
+	if (restart)
+		riic_set_bit(rd, ICCR2_RS, RIIC_ICCR2);
+	else
+		riic_set_bit(rd, ICCR2_ST, RIIC_ICCR2);
+}
+
+static int riic_wait_for_icsr2(struct riic_data *rd, unsigned short bit)
+{
+	unsigned char icsr2;
+	int timeout = RIIC_TIMEOUT;
+
+	while (timeout-- > 0) {
+		icsr2 = riic_read(rd, RIIC_ICSR2);
+		if (icsr2 & ICSR2_NACKF)
+			return -EIO;
+		if (icsr2 & bit)
+			return 0;
+		udelay(10);
+	}
+
+	dev_err(rd->dev, "Timeout!(bit = %x icsr2 = %x, iccr2 = %x)\n",
+		bit, riic_read(rd, RIIC_ICSR2), riic_read(rd, RIIC_ICCR2));
+
+	return -ETIMEDOUT;
+}
+
+static void riic_packet_receive(struct riic_data *rd)
+{
+	if (riic_pkt_buf_data_len(rd) >= 2) {
+		rd->master_state = RIIC_MASTER_RECEIVING;
+		riic_read_receive_data(rd, 0);
+		riic_set_receive_ack(rd, 1);
+
+	} else if (riic_pkt_buf_data_len(rd) == 1) {
+		riic_set_receive_ack(rd, 0);
+		if (riic_master_is_last_packet(rd)) {
+			rd->master_state = RIIC_MASTER_RECEIVE_LAST;
+			riic_wait_for_icsr2(rd, ICSR2_RDRF);
+
+			/* issue STOP */
+			riic_master_issue_stop(rd);
+			riic_read_receive_data(rd, 1);
+
+		} else {
+			riic_read_receive_data(rd, 1);
+			riic_master_update_packet(rd);
+
+			/* issue RESTART */
+			riic_send_start_cond(rd, 1);
+		}
+	} else {
+		dev_err(rd->dev, "got a zero buffer packet!\n");
+	}
+}
+
+static void riic_master_kick_receive(struct riic_data *rd)
+{
+	rd->pkt->buf_idx = 0;
+	riic_clear_bit(rd, ICIER_TIE, RIIC_ICIER);
+	riic_clear_bit(rd, ICSR2_TDRE, RIIC_ICSR2);
+
+	/* dummy read */
+	riic_read(rd, RIIC_ICDRR);
+
+	riic_packet_receive(rd);
+}
+
+static void riic_irq_master_tend(struct riic_data *rd)
+{
+	switch (rd->master_state) {
+	case RIIC_MASTER_ISSUED_START:
+		rd->master_state = RIIC_MASTER_SENT_SLAVE_ADDRESS;
+		riic_master_kick_transmit(rd);
+		break;
+	case RIIC_MASTER_SENT_SLAVE_ADDRESS_NEXT:
+		rd->master_state = RIIC_MASTER_SENT_SLAVE_ADDRESS;
+		riic_master_kick_transmit(rd);
+		break;
+	case RIIC_MASTER_TRANSMITTING:
+		break;
+	case RIIC_MASTER_TRANSMIT_LAST:
+		if (riic_master_is_last_packet(rd)) {
+			/* issue STOP */
+			riic_master_issue_stop(rd);
+		} else {
+			riic_master_update_packet(rd);
+			/* issue RESTART */
+			riic_set_bit(rd, ICIER_STIE, RIIC_ICIER);
+			riic_set_bit(rd, ICCR2_RS, RIIC_ICCR2);
+		}
+		break;
+
+	default:
+		dev_err(rd->dev, "ch%d, unexpect master_state (%d)\n",
+			rd->channel, rd->master_state);
+		break;
+	}
+}
+
+static void riic_irq_master_rdrf(struct riic_data *rd)
+{
+	switch (rd->master_state) {
+	case RIIC_MASTER_ISSUED_START:
+		riic_master_kick_receive(rd);
+		break;
+	case RIIC_MASTER_RECEIVING:
+	case RIIC_MASTER_RECEIVE_LAST:
+		riic_packet_receive(rd);
+		break;
+	case RIIC_MASTER_END:
+		break;
+	default:
+		break;
+	}
+}
+
+static void riic_irq_master_start(struct riic_data *rd, unsigned char icsr2)
+{
+	if (!(riic_read(rd, RIIC_ICCR2) & ICCR2_MST)) {
+		riic_slave_prepare(rd);
+		return;
+	}
+
+	switch (rd->master_state) {
+	case RIIC_MASTER_TRANSMIT_LAST:
+	case RIIC_MASTER_RECEIVE_LAST:
+	case RIIC_MASTER_PREPARE:
+		rd->master_state = RIIC_MASTER_ISSUED_START;
+		if (icsr2 & ICSR2_TDRE)
+			riic_send_slave_address(rd, 0);
+		break;
+	default:
+		dev_err(rd->dev, "ch%d, unexpect master_state (%d)\n",
+			rd->channel, rd->master_state);
+		break;
+	}
+}
+
+static void riic_irq_master_stop(struct riic_data *rd)
+{
+	switch (rd->master_state) {
+	case RIIC_MASTER_TRANSMIT_LAST:
+	case RIIC_MASTER_RECEIVE_LAST:
+	case RIIC_MASTER_END:
+		rd->master_state = RIIC_MASTER_ISSUED_STOP;
+		riic_master_clean_icier(rd);
+
+		rd->state = RIIC_STATE_IDLE;
+		if (!rd->nacked) {
+			riic_master_update_packet(rd);
+			rd->completed = 1;
+		}
+		wake_up_interruptible(&rd->wait);
+		break;
+	case RIIC_MASTER_TRANSMITTING:
+	case RIIC_MASTER_ISSUED_START:
+		/* avoid to output the following message */
+		break;
+	default:
+		/* riic_dump(rd, __func__); */
+		dev_err(rd->dev, "ch%d, unexpect master_state (%d)\n",
+			rd->channel, rd->master_state);
+		break;
+	}
+}
+
+static void riic_irq_master(struct riic_data *rd, unsigned char icsr2)
+{
+	if (icsr2 & ICSR2_AL) {
+		riic_clear_bit(rd, ICSR2_AL, RIIC_ICSR2);
+		riic_irq_master_al(rd, icsr2);
+		return;
+	}
+	if (icsr2 & ICSR2_NACKF) {
+		riic_clear_bit(rd, ICSR2_NACKF, RIIC_ICSR2);
+		riic_irq_master_nackf(rd);
+		return;
+	}
+	if (icsr2 & ICSR2_TEND && riic_read(rd, RIIC_ICIER) & ICIER_TEIE) {
+		riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+		riic_irq_master_tend(rd);
+	}
+	if (icsr2 & ICSR2_RDRF) {
+		riic_irq_master_rdrf(rd);
+		riic_clear_bit(rd, ICSR2_RDRF, RIIC_ICSR2);
+		return;
+	}
+	if (icsr2 & ICSR2_START) {
+		riic_clear_bit(rd, ICIER_STIE, RIIC_ICIER);
+		riic_clear_bit(rd, ICSR2_START, RIIC_ICSR2);
+		riic_irq_master_start(rd, icsr2);
+	}
+	if (icsr2 & ICSR2_STOP) {
+		riic_clear_bit(rd, ICIER_SPIE, RIIC_ICIER);
+		riic_clear_bit(rd, ICSR2_STOP, RIIC_ICSR2);
+		riic_irq_master_stop(rd);
+	}
+	if (icsr2 & ICSR2_TDRE) {
+		riic_clear_bit(rd, ICSR2_TDRE, RIIC_ICSR2);
+		if (rd->pkt->rw != RIIC_CORE_RW_MASTER_TRANSMIT)
+			return;
+		riic_master_kick_transmit(rd);
+	}
+}
+
+/* Idle */
+static void riic_irq_idle_start(struct riic_data *rd, unsigned char icsr2)
+{
+	unsigned char iccr2 = riic_read(rd, RIIC_ICCR2);
+
+	if (iccr2 & ICCR2_MST) {
+		dev_err(rd->dev, "No longer in slave mode %d,%02x,%02x\n",
+			rd->channel, icsr2, iccr2);
+		return;
+	}
+	if (!(iccr2 & ICCR2_BBSY)) {
+		dev_err(rd->dev, "no busy %d, %02x\n",
+			rd->channel, iccr2);
+		return;
+	}
+
+	riic_slave_prepare(rd);
+}
+
+static void riic_irq_idle(struct riic_data *rd, unsigned char icsr2)
+{
+	if (icsr2 & ICSR2_AL)
+		riic_clear_bit(rd, ICSR2_AL, RIIC_ICSR2);
+	if (icsr2 & ICSR2_NACKF)
+		riic_clear_bit(rd, ICSR2_NACKF, RIIC_ICSR2);
+	if (icsr2 & ICSR2_TEND &&
+	    riic_read(rd, RIIC_ICIER) & ICIER_TEIE)
+		riic_clear_bit(rd, ICIER_TEIE, RIIC_ICIER);
+
+	switch ((icsr2 & (ICSR2_START | ICSR2_STOP))) {
+	case (ICSR2_START | ICSR2_STOP):
+		/*
+		 * If the following sequence, we should clear the STOP flag:
+		 *  START -> NACK -> STOP ---> START -> ACK -> (IRQ happens)
+		 *  Then, the RIIC's ICSR2 will be set (START | STOP).
+		 */
+		riic_clear_bit(rd, ICSR2_STOP, RIIC_ICSR2);
+		/* through */
+	case ICSR2_START:
+		riic_clear_bit(rd, ICSR2_START, RIIC_ICSR2);
+		riic_irq_idle_start(rd, icsr2);
+		break;
+	case ICSR2_STOP:
+		riic_clear_bit(rd, ICSR2_STOP, RIIC_ICSR2);
+		riic_clear_bit(rd, ICIER_SPIE, RIIC_ICIER);
+		break;
+	default:
+		break;
+	}
+}
+
+/* Slave Mode */
+static void riic_irq_slave(struct riic_data *rd, unsigned char icsr2)
+{
+	dev_err(rd->dev, "This version driver doesn't support slave mode!\n");
+	return;
+}
+
+static irqreturn_t riic_irq(int irq, void *data)
+{
+	struct riic_data *rd = data;
+	unsigned char icsr2 = riic_read(rd, RIIC_ICSR2);
+
+	rd->old_state = rd->state;
+	rd->old_icsr2 = icsr2;
+
+	switch (rd->state) {
+	case RIIC_STATE_MASTER:
+		riic_irq_master(rd, icsr2);
+		break;
+	case RIIC_STATE_SLAVE:
+		riic_irq_slave(rd, icsr2);
+		break;
+	case RIIC_STATE_IDLE:
+		riic_irq_idle(rd, icsr2);
+		break;
+
+	default:
+		break;
+	}
+	return IRQ_HANDLED;
+}
+
+static int riic_probe(struct platform_device *pdev)
+{
+	struct resource *res = NULL;
+	struct riic_data *rd = NULL;
+	struct riic_platform_data *riic_data = NULL;
+	struct i2c_adapter *adap;
+	void __iomem *reg = NULL;
+	int i, irq, j = 0;
+	int ret = 0;
+	char clk_name[16];
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENOENT;
+		dev_err(&pdev->dev, "platform_get_resource failed.\n");
+		goto clean_up;
+	}
+
+	if (!pdev->dev.platform_data) {
+		ret = -ENOENT;
+		dev_err(&pdev->dev, "no platform data\n");
+		goto clean_up;
+	}
+	riic_data = pdev->dev.platform_data;
+
+	reg = ioremap(res->start, resource_size(res));
+	if (reg == NULL) {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "ioremap failed.\n");
+		goto clean_up;
+	}
+
+	rd = kzalloc(sizeof(struct riic_data), GFP_KERNEL);
+	if (rd == NULL) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "kzalloc failed.\n");
+		goto clean_up;
+	}
+
+	rd->dev = &pdev->dev;
+	rd->reg = reg;
+	platform_set_drvdata(pdev, rd);
+
+	adap = &rd->adap;
+	i2c_set_adapdata(adap, rd);
+
+	adap->owner = THIS_MODULE;
+	adap->algo = &riic_algorithm;
+	adap->dev.parent = &pdev->dev;
+	adap->retries = 5;
+	rd->channel = adap->nr = pdev->id;
+
+	strlcpy(adap->name, dev_name(&pdev->dev), sizeof(adap->name));
+	if (pdev->id < RIIC_NUM_CHANNELS) {
+		rd->name = riic_name[pdev->id];
+	} else {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "invalid platform device id.\n");
+		goto clean_up;
+	}
+
+	snprintf(clk_name, sizeof(clk_name), "riic%d", pdev->id);
+	rd->clk = clk_get(&pdev->dev, clk_name);
+	if (IS_ERR(rd->clk)) {
+		dev_err(&pdev->dev, "clk_get failed.\n");
+		ret = PTR_ERR(rd->clk);
+		goto clean_up;
+	}
+	clk_enable(rd->clk);
+
+	ret = riic_init_setting(rd, riic_data->clock);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "riic_init_setting failed.\n");
+		goto clean_up;
+	}
+
+	i = j = 0;
+	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i++))) {
+		for (irq = res->start; irq <= res->end; irq++) {
+			if (j >= NUM_IRQ) {
+				dev_err(&pdev->dev, "irq resource is over\n");
+				ret = -ENODEV;
+				goto clean_up;
+			}
+			if (res->flags & IORESOURCE_IRQ_HIGHEDGE)
+				irq_set_irq_type(irq, IRQ_TYPE_EDGE_RISING);
+			ret = request_irq(irq, riic_irq, IRQF_DISABLED,
+					  rd->name, rd);
+			if (ret < 0) {
+				dev_err(&pdev->dev, "request_irq error\n");
+				goto clean_up;
+			}
+			rd->irq[j++] = irq;
+		}
+	}
+	rd->irqn = j;
+
+	init_waitqueue_head(&rd->wait);
+
+	ret = i2c_add_numbered_adapter(adap);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "i2c_add_numbered_adapter failed.\n");
+		goto clean_up;
+	}
+
+#ifdef CONFIG_ARCH_R7S72100
+	/* I2C pfc pin assign after resetting. */
+//	rskrza1_board_i2c_pfc_assign(pdev->id);
+#endif
+
+	dev_info(&pdev->dev, "version %s: %d[kbps]\n",
+		DRIVER_VERSION, riic_data->clock);
+	return ret;
+
+clean_up:
+	for (i = 0; i < j; i++)
+		free_irq(rd->irq[i], rd);
+	if (rd) {
+		if (!IS_ERR(rd->clk)) {
+			clk_disable(rd->clk);
+			clk_put(rd->clk);
+		}
+		kfree(rd);
+	}
+	if (reg)
+		iounmap(reg);
+	platform_set_drvdata(pdev, NULL);
+
+	return ret;
+}
+
+static struct platform_driver riic_driver = {
+	.probe =	riic_probe,
+	.remove =	riic_remove,
+	.driver		= {
+		.name	= "i2c-riic",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init riic_init(void)
+{
+	return platform_driver_register(&riic_driver);
+}
+module_init(riic_init);
+
+static void __exit riic_cleanup(void)
+{
+	platform_driver_unregister(&riic_driver);
+}
+module_exit(riic_cleanup);
+
+MODULE_DESCRIPTION("Renesas RIIC Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Yoshihiro Shimoda");
+MODULE_ALIAS("platform:i2c-riic");
diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index 2209f28..17797f6 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -204,4 +204,12 @@ config VIPERBOARD_ADC
 	  Say yes here to access the ADC part of the Nano River
 	  Technologies Viperboard.
 
+config SH_ADC
+	tristate "RZA1 ADC support"
+	depends on ARCH_R7S72100
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	help
+	  Support RZA1 ADC
+
 endmenu
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index ba9a10a..f9460b5 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -22,3 +22,4 @@ obj-$(CONFIG_TI_ADC081C) += ti-adc081c.o
 obj-$(CONFIG_TI_AM335X_ADC) += ti_am335x_adc.o
 obj-$(CONFIG_TWL6030_GPADC) += twl6030-gpadc.o
 obj-$(CONFIG_VIPERBOARD_ADC) += viperboard_adc.o
+obj-$(CONFIG_SH_ADC) += sh_adc.o
diff --git a/drivers/iio/adc/sh_adc.c b/drivers/iio/adc/sh_adc.c
new file mode 100644
index 0000000..7b08905
--- /dev/null
+++ b/drivers/iio/adc/sh_adc.c
@@ -0,0 +1,763 @@
+/*
+ * SH ADC driver
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ *
+ * Based on at91_adc.c:
+ * Copyright 2011 Free Electrons
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/driver.h>
+#include <linux/iio/machine.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_data/sh_adc.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+
+
+#define DRIVER_VERSION	"2013-06-12"
+
+#define SH_ADC_ADDRA	0x00
+#define SH_ADC_ADDRB	0x02
+#define SH_ADC_ADDRC	0x04
+#define SH_ADC_ADDRD	0x06
+#define SH_ADC_ADDRE	0x08
+#define SH_ADC_ADDRF	0x0a
+#define SH_ADC_ADDRG	0x0c
+#define SH_ADC_ADDRH	0x0e
+#define SH_ADC_ADCSR	0x60
+
+#define SH_ADC_ADDR_MASK	0xffc0
+#define SH_ADC_ADDR_SHIFT	6
+
+#define SH_ADC_ADCSR_ADF	0x8000
+#define SH_ADC_ADCSR_ADIE	0x4000
+#define SH_ADC_ADCSR_ADST	0x2000
+#define SH_ADC_ADCSR_TRGS_MASK	0x1e00
+#define SH_ADC_ADCSR_TRGS_NON	0x0000	/* external trigger input is disable */
+#define SH_ADC_ADCSR_TRGS_TRGAN	0x0200	/* MTU2, TRGAN */
+#define SH_ADC_ADCSR_TRGS_TRG0N	0x0400	/* MTU2, TRG0N */
+#define SH_ADC_ADCSR_TRGS_TRG4AN	0x0600	/* MTU2, TRG4AN */
+#define SH_ADC_ADCSR_TRGS_TRG4BN	0x0800	/* MTU2, TRG4BN */
+#define SH_ADC_ADCSR_TRGS_EXT	0x1200	/* external pin trigger */
+#define SH_ADC_ADCSR_CKS_MASK	0x01c0
+#define SH_ADC_ADCSR_CKS_256	0x0000
+#define SH_ADC_ADCSR_CKS_298	0x0040
+#define SH_ADC_ADCSR_CKS_340	0x0080
+#define SH_ADC_ADCSR_CKS_382	0x00c0
+#define SH_ADC_ADCSR_CKS_1054	0x0100
+#define SH_ADC_ADCSR_CKS_1096	0x0140
+#define SH_ADC_ADCSR_CKS_1390	0x0180
+#define SH_ADC_ADCSR_CKS_1432	0x01c0
+#define SH_ADC_ADCSR_MDS_MASK	0x0038
+#define SH_ADC_ADCSR_MDS_SINGLE	0x0000
+#define SH_ADC_ADCSR_MDS_M_1_4	0x0020	/* multi mode, channel 1 to 4 */
+#define SH_ADC_ADCSR_MDS_M_1_8	0x0028	/* multi mode, channel 1 to 8 */
+#define SH_ADC_ADCSR_MDS_S_1_4	0x0030	/* scan mode, channel 1 to 4 */
+#define SH_ADC_ADCSR_MDS_S_1_8	0x0038	/* scan mode, channel 1 to 8 */
+#define SH_ADC_ADCSR_CH_MASK	0x0003
+#define SH_ADC_ADCSR_CH_AN0	0x0000
+#define SH_ADC_ADCSR_CH_AN1	0x0001
+#define SH_ADC_ADCSR_CH_AN2	0x0002
+#define SH_ADC_ADCSR_CH_AN3	0x0003
+#define SH_ADC_ADCSR_CH_AN4	0x0004
+#define SH_ADC_ADCSR_CH_AN5	0x0005
+#define SH_ADC_ADCSR_CH_AN6	0x0006
+#define SH_ADC_ADCSR_CH_AN7	0x0007
+
+#define SH_ADC_NUM_CHANNEL	8
+#define sh_adc_get_reg_addr(ch)	(SH_ADC_ADDRA + ch * 2)
+
+struct sh_adc {
+	/* ADC */
+	void __iomem	*reg;
+	struct mutex	lock;
+	bool		done;
+	int		irq;
+	struct clk	*clk;
+	u16		*buffer;
+	wait_queue_head_t wq_data_avail;
+
+	/* MTU2 setting as a ADC trigger */
+	void __iomem	*mtu2_share_reg;
+	void __iomem	*mtu2_reg;
+	struct clk	*mtu2_clk;
+	u8		mtu2_ch;
+	int		val;
+	unsigned long	rate;
+	unsigned long	periodic;
+};
+
+/* MTU2 */
+#define TSTR -1 /* shared register */
+#define TCR  0 /* channel register */
+#define TMDR 1 /* channel register */
+#define TIOR 2 /* channel register */
+#define TIER 3 /* channel register */
+#define TSR  4 /* channel register */
+#define TCNT 5 /* channel register */
+#define TGR  6 /* channel register */
+
+#define SH_MTU2_TSR_TGFA 0x01
+
+#define TIMER_BIT 1 /* MTU2 ch.1 */
+#define CLK_DIV 64 /* count rate P0/64 (depend on TCR setting.) */
+static DEFINE_RAW_SPINLOCK(sh_mtu2_lock);
+
+static unsigned long mtu2_reg_offs[] = {
+	[TCR] = 0,
+	[TMDR] = 1,
+	[TIOR] = 2,
+	[TIER] = 4,
+	[TSR] = 5,
+	[TCNT] = 6,
+	[TGR] = 8,
+};
+
+static inline unsigned long sh_mtu2_read(struct sh_adc *adc, int reg_nr)
+{
+	unsigned long offs;
+
+	if (reg_nr == TSTR)
+		return ioread8(adc->mtu2_share_reg);
+
+	offs = mtu2_reg_offs[reg_nr];
+
+	if ((reg_nr == TCNT) || (reg_nr == TGR))
+		return ioread16(adc->mtu2_reg + offs);
+	else
+		return ioread8(adc->mtu2_reg + offs);
+}
+
+static inline void sh_mtu2_write(struct sh_adc *adc, int reg_nr,
+				unsigned long value)
+{
+	unsigned long offs;
+
+	if (reg_nr == TSTR) {
+		iowrite8(value, adc->mtu2_share_reg);
+		return;
+	}
+
+	offs = mtu2_reg_offs[reg_nr];
+
+	if ((reg_nr == TCNT) || (reg_nr == TGR))
+		iowrite16(value, adc->mtu2_reg + offs);
+	else
+		iowrite8(value, adc->mtu2_reg + offs);
+}
+
+static void sh_mtu2_start_stop_ch(struct sh_adc *adc, bool start)
+{
+	unsigned long flags, value;
+
+	/* start stop register shared by multiple timer channels */
+	raw_spin_lock_irqsave(&sh_mtu2_lock, flags);
+	value = sh_mtu2_read(adc, TSTR);
+
+	if (start)
+		value |= 1 << adc->mtu2_ch;
+	else
+		value &= ~(1 << adc->mtu2_ch);
+
+	sh_mtu2_write(adc, TSTR, value);
+	raw_spin_unlock_irqrestore(&sh_mtu2_lock, flags);
+}
+
+static int sh_mtu2_set_trigger(struct sh_adc *adc, bool timer_start)
+{
+	if (adc->val <= 0)
+		return -EINVAL;
+	/* make sure channel is disabled */
+	sh_mtu2_start_stop_ch(adc, 0);
+
+	adc->rate = clk_get_rate(adc->mtu2_clk) / CLK_DIV;
+	adc->periodic = ((adc->rate * adc->val) / 1000);
+	if (adc->periodic > 0xffff)
+		return -EINVAL;
+
+	/* "Periodic Counter Operation" */
+	sh_mtu2_write(adc, TGR, adc->periodic);
+	sh_mtu2_write(adc, TCNT, 0);
+
+	/* restart timer if timer_start is true */
+	sh_mtu2_start_stop_ch(adc, timer_start);
+
+	return 0;
+}
+
+static int sh_mtu2_enable(struct sh_adc *adc)
+{
+	/* make sure channel is disabled */
+	sh_mtu2_start_stop_ch(adc, false);
+
+	/* "Periodic Counter Operation" */
+	sh_mtu2_write(adc, TCR, 0x23); /* TGRA clear, divide clock by 64 */
+	sh_mtu2_write(adc, TIOR, 0);
+	sh_mtu2_write(adc, TMDR, 0); /* normal operation(bit3-0: 0) */
+	sh_mtu2_write(adc, TIER, 0x81); /* enable ADC trigger & TGFA bit INT */
+
+	/* a default sampling rate is 10Hz */
+	adc->val = 100;
+	return sh_mtu2_set_trigger(adc, false);
+
+}
+
+/* ADC */
+struct sh_adc_avail_chs {
+	int	channel_mask;
+	u8	an;
+};
+static struct sh_adc_avail_chs sh_adc_chs[][SH_ADC_NUM_CHANNEL] = {
+	{
+		{ 0x01, 0},
+		{ 0x03, 1},
+		{ 0x07, 2},
+		{ 0x0f, 3},
+		{ 0x10, 4},
+		{ 0x30, 5},
+		{ 0x70, 6},
+		{ 0xf0, 7},
+	},
+	{
+		{ 0x01, 0},
+		{ 0x03, 1},
+		{ 0x07, 2},
+		{ 0x0f, 3},
+		{ 0x1f, 4},
+		{ 0x3f, 5},
+		{ 0x7f, 6},
+		{ 0xff, 7},
+	},
+};
+
+static void sh_adc_write(struct sh_adc *adc, unsigned short data,
+			 unsigned long offset)
+{
+	iowrite16(data, adc->reg + offset);
+}
+
+static unsigned short sh_adc_read(struct sh_adc *adc, unsigned long offset)
+{
+	return ioread16(adc->reg + offset);
+}
+
+static void sh_adc_set_bit(struct sh_adc *adc, unsigned short val,
+			   unsigned long offset)
+{
+	unsigned short tmp;
+
+	tmp = sh_adc_read(adc, offset);
+	tmp |= val;
+	sh_adc_write(adc, tmp, offset);
+}
+
+static void sh_adc_clear_bit(struct sh_adc *adc, unsigned short val,
+			     unsigned long offset)
+{
+	unsigned short tmp;
+
+	tmp = sh_adc_read(adc, offset);
+	tmp &= ~val;
+	sh_adc_write(adc, tmp, offset);
+}
+
+static int sh_adc_start_adc(struct sh_adc *adc, int channel)
+{
+	sh_adc_clear_bit(adc, SH_ADC_ADCSR_ADST, SH_ADC_ADCSR);
+	sh_adc_clear_bit(adc, SH_ADC_ADCSR_TRGS_MASK, SH_ADC_ADCSR);
+
+	if (channel >= 0) {
+		sh_adc_clear_bit(adc, SH_ADC_ADCSR_MDS_MASK, SH_ADC_ADCSR);
+		sh_adc_clear_bit(adc, SH_ADC_ADCSR_CH_MASK, SH_ADC_ADCSR);
+		sh_adc_set_bit(adc, (SH_ADC_ADCSR_ADST | channel),
+				SH_ADC_ADCSR);
+	} else {
+		sh_adc_set_bit(adc, SH_ADC_ADCSR_TRGS_TRGAN, SH_ADC_ADCSR);
+		sh_mtu2_start_stop_ch(adc, true);
+	}
+	return 0;
+}
+
+static int sh_adc_stop_adc(struct sh_adc *adc)
+{
+	sh_mtu2_start_stop_ch(adc, false);
+	return 0;
+}
+
+static int sh_adc_get_raw_value(struct iio_dev *idev, int *val, int channel)
+{
+	struct sh_adc *adc = iio_priv(idev);
+	int ret = 1;
+
+	mutex_lock(&adc->lock);
+
+	if (!iio_buffer_enabled(idev)) {
+		sh_adc_start_adc(adc, channel);
+		ret = wait_event_interruptible_timeout(adc->wq_data_avail,
+				adc->done, msecs_to_jiffies(1000));
+		adc->done = false;
+	}
+	if (ret > 0)
+		*val = sh_adc_read(adc, sh_adc_get_reg_addr(channel));
+	mutex_unlock(&adc->lock);
+	return ret;
+}
+
+static int sh_adc_read_raw(struct iio_dev *idev,
+		struct iio_chan_spec const *chan,
+		int *val, int *val2, long mask)
+{
+	int ret;
+	struct sh_adc *adc = iio_priv(idev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = adc->val;
+		ret = IIO_VAL_INT;
+		break;
+	case IIO_CHAN_INFO_RAW:
+		ret = sh_adc_get_raw_value(idev, val, chan->channel);
+		*val >>= chan->scan_type.shift;
+		*val &= ((1 << chan->scan_type.realbits) - 1);
+		if (ret > 0)
+			ret = IIO_VAL_INT;
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 1;
+		ret = IIO_VAL_INT;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sh_adc_write_raw(struct iio_dev *idev,
+		struct iio_chan_spec const *chan, int val, int val2, long mask)
+{
+	int ret = 0;
+	struct sh_adc *adc = iio_priv(idev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		adc->val = val;
+		ret = sh_mtu2_set_trigger(adc, iio_buffer_enabled(idev));
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sh_adc_get_ch(struct iio_dev *idev, int i)
+{
+	int j;
+	for (j = 0; j < idev->num_channels; j++)
+		if (sh_adc_chs[i][j].channel_mask == *idev->active_scan_mask)
+			return sh_adc_chs[i][j].an;
+	return -1;
+}
+
+static int sh_adc_get_mds_ch(struct iio_dev *idev)
+{
+	int i, mds_ch, ch, cnt = 0;
+
+	ch = 0;
+	for (i = 0; i < idev->masklength; i++)
+		if (test_bit(i, idev->active_scan_mask)) {
+			ch = i;
+			cnt++;
+		}
+
+	mds_ch = -1;
+	if (cnt == 1)
+		mds_ch = (ch | SH_ADC_ADCSR_MDS_SINGLE);
+	else if (cnt >= 2 && cnt <= idev->num_channels) {
+		mds_ch = sh_adc_get_ch(idev, (cnt > 4));
+		if (mds_ch < 0)
+			return -1;
+		mds_ch |= (cnt > 4 ? SH_ADC_ADCSR_MDS_M_1_8 :
+				   SH_ADC_ADCSR_MDS_M_1_4);
+	}
+	return mds_ch;
+}
+
+static int sh_adc_configure_trigger(struct iio_trigger *trig, bool state)
+{
+	struct iio_dev *idev = (struct iio_dev *)dev_get_drvdata(&trig->dev);
+	struct sh_adc *adc = iio_priv(idev);
+	int mds_ch;
+
+	if (state) {
+		/* set trigger */
+		adc->buffer = kzalloc(idev->scan_bytes, GFP_KERNEL);
+		if (!adc->buffer)
+			return -ENOMEM;
+
+		mds_ch = sh_adc_get_mds_ch(idev);
+		if (mds_ch < 0)
+			return -1;
+		sh_adc_set_bit(adc, mds_ch, SH_ADC_ADCSR);
+
+		sh_adc_start_adc(adc, -1);
+	} else {
+		/* clear trigger */
+		sh_adc_stop_adc(adc);
+		kfree(adc->buffer);
+	}
+	return 0;
+}
+
+static const struct iio_trigger_ops sh_adc_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = &sh_adc_configure_trigger,
+};
+
+static int sh_adc_trigger_init(struct iio_dev *idev)
+{
+	int ret;
+	struct iio_trigger *trig;
+
+	trig = iio_trigger_alloc("%s-dev%i", idev->name, idev->id);
+	if (!trig)
+		return -ENOMEM;
+	trig->dev.parent = idev->dev.parent;
+	dev_set_drvdata(&trig->dev, idev);
+	trig->ops = &sh_adc_trigger_ops;
+
+	ret = iio_trigger_register(trig);
+	if (ret)
+		iio_trigger_free(trig);
+	else
+		idev->trig = trig;
+
+	return ret;
+}
+
+static irqreturn_t sh_adc_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *idev = pf->indio_dev;
+	struct sh_adc *adc = iio_priv(idev);
+	struct iio_chan_spec const *chans;
+	int val, ret, dnum, i;
+
+	chans = idev->channels;
+	i = 0;
+	for (dnum = 0; dnum < idev->masklength; dnum++) {
+		/* skip no-mask channel. */
+		if (!test_bit(dnum, idev->active_scan_mask))
+			continue;
+
+		/* read ch data */
+		ret = sh_adc_get_raw_value(idev, &val, dnum);
+		val >>= chans[dnum].scan_type.shift;
+		val &= ((1 << chans[dnum].scan_type.realbits) - 1);
+		if (ret > 0)
+			adc->buffer[i] = (u16)val;
+		i++;
+	}
+
+	if (idev->scan_timestamp) {
+		s64 *timestamp = (s64 *)((u8 *)adc->buffer +
+				ALIGN(i, sizeof(s64)));
+		*timestamp = pf->timestamp;
+	}
+	iio_push_to_buffers(idev, (u8 *)adc->buffer);
+	iio_trigger_notify_done(idev->trig);
+
+	enable_irq(adc->irq);
+
+	return IRQ_HANDLED;
+}
+
+
+static const struct iio_info sh_adc_info = {
+	.write_raw = sh_adc_write_raw,
+	.read_raw = sh_adc_read_raw,
+	.driver_module = THIS_MODULE,
+};
+
+static inline void sh_adc_iio_map_unregister(struct platform_device *pdev,
+					     struct sh_adc *adc, int map_stat)
+{
+	switch (map_stat) {
+	case 3:
+		devm_iounmap(&pdev->dev, adc->mtu2_reg);
+	case 2:
+		devm_iounmap(&pdev->dev, adc->mtu2_share_reg);
+	case 1:
+		devm_iounmap(&pdev->dev, adc->reg);
+	}
+}
+
+static irqreturn_t sh_adc_irq(int irq, void *private)
+{
+	struct iio_dev *idev = private;
+	struct sh_adc *adc = iio_priv(idev);
+	u8 value;
+
+	value = sh_mtu2_read(adc, TSR);
+	if (value & SH_MTU2_TSR_TGFA) {
+		value &= ~SH_MTU2_TSR_TGFA;
+		sh_mtu2_write(adc, TSR, value);
+		return IRQ_HANDLED;
+	}
+
+	sh_adc_clear_bit(adc, SH_ADC_ADCSR_ADF, SH_ADC_ADCSR);
+
+	if (!iio_buffer_enabled(idev)) {
+		adc->done = true;
+		wake_up_interruptible(&adc->wq_data_avail);
+	} else {
+		adc->irq = irq;
+		disable_irq_nosync(irq);
+		iio_trigger_poll(idev->trig, iio_get_time_ns());
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sh_adc_get_clk(struct platform_device *pdev, struct clk **clk,
+			  char *name)
+{
+	int ret;
+
+	*clk = devm_clk_get(&pdev->dev, name);
+	if (IS_ERR(*clk)) {
+		dev_err(&pdev->dev, "Failed to get the clock.\n");
+		return -1;
+	}
+	ret = clk_prepare_enable(*clk);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Could not prepare or enable the clock.\n");
+		return -1;
+	}
+	/* enable clock */
+	ret = clk_enable(*clk);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot enable clock\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int sh_adc_iio_free_irqs(struct platform_device *pdev, int nres)
+{
+	struct iio_dev *idev = platform_get_drvdata(pdev);
+	struct resource *res;
+	int irq;
+
+	for (nres--; nres >= 0; nres--) {
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, nres);
+		if (!res)
+			continue;
+		for (irq = res->start; irq <= res->end; irq++)
+			free_irq(irq, idev);
+	}
+	return 0;
+}
+
+static int sh_adc_probe(struct platform_device *pdev)
+{
+	struct iio_dev *idev;
+	struct sh_adc *adc;
+	struct resource *res;
+	struct iio_chan_spec *chan_array, *timestamp;
+	struct sh_adc_data *pdata = pdev->dev.platform_data;
+	int i, nmap, nres, irq = 0;
+	int ret = 0;
+
+	idev = iio_device_alloc(sizeof(*adc));
+	if (!idev)
+		return -ENOMEM;
+
+	adc = iio_priv(idev);
+	platform_set_drvdata(pdev, idev);
+
+	/* ADC base address */
+	nmap = 0;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, nmap);
+	adc->reg = devm_request_and_ioremap(&pdev->dev, res);
+	if (!adc->reg)
+		goto error_map;
+	nmap++;
+	/* MTU2 base address */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, nmap);
+	adc->mtu2_share_reg = devm_request_and_ioremap(&pdev->dev, res);
+	if (!adc->mtu2_share_reg)
+		goto error_map;
+	nmap++;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, nmap);
+	adc->mtu2_reg = devm_request_and_ioremap(&pdev->dev, res);
+	if (!adc->mtu2_reg)
+		goto error_map;
+	nmap++;
+
+	init_waitqueue_head(&adc->wq_data_avail);
+	mutex_init(&adc->lock);
+
+	idev->dev.parent = &pdev->dev;
+	idev->name = dev_name(&pdev->dev);
+	idev->modes = INDIO_DIRECT_MODE;
+	idev->info = &sh_adc_info;
+
+	/* channel setup */
+	idev->num_channels = pdata->num_channels;
+	chan_array = devm_kzalloc(&idev->dev,
+				  ((idev->num_channels + 1) *
+					sizeof(struct iio_chan_spec)),
+				  GFP_KERNEL);
+	if (!chan_array) {
+		ret = -ENOMEM;
+		goto error_map;
+	}
+	for (i = 0; i < pdata->num_channels; i++) {
+		struct iio_chan_spec *chan = chan_array + i;
+		chan->type = IIO_VOLTAGE;
+		chan->indexed = 1;
+		chan->channel = i;
+		chan->scan_index = i;
+		chan->scan_type.sign = 'u';
+		chan->scan_type.realbits = 12;
+		chan->scan_type.storagebits = 16;
+		chan->scan_type.shift = 4;
+		chan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |
+				  BIT(IIO_CHAN_INFO_SAMP_FREQ);
+		chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	}
+	timestamp = chan_array + i;
+	timestamp->type = IIO_TIMESTAMP;
+	timestamp->channel = -1;
+	timestamp->scan_index = i;
+	timestamp->scan_type.sign = 's';
+	timestamp->scan_type.realbits = 64;
+	timestamp->scan_type.storagebits = 64;
+	idev->num_channels++;
+
+	idev->channels = chan_array;
+
+	/* request interrupt */
+	for (nres = 0; nres < pdev->num_resources; nres++) {
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, nres);
+		if (!res)
+			continue;
+		for (irq = res->start; irq <= res->end; irq++) {
+			ret = request_irq(irq, sh_adc_irq, IRQF_DISABLED,
+					  idev->name, idev);
+			if (ret < 0) {
+				for (irq--; irq >= res->start; irq--)
+					free_irq(irq, idev);
+				goto error_free_irq;
+			}
+		}
+	}
+	sh_adc_set_bit(adc, SH_ADC_ADCSR_ADIE, SH_ADC_ADCSR);
+
+	/* get clock */
+	ret = sh_adc_get_clk(pdev, &adc->clk, "adc0");
+	if (ret < 0)
+		goto error_free_irq;
+	ret = sh_adc_get_clk(pdev, &adc->mtu2_clk, "mtu2_fck");
+	if (ret < 0)
+		goto error_mtu2_clk;
+
+	/* set buffer and regist the trigger */
+	iio_triggered_buffer_setup(idev, &iio_pollfunc_store_time,
+				 &sh_adc_trigger_handler, NULL);
+	sh_adc_trigger_init(idev);
+
+	/* register iio device */
+	ret = iio_device_register(idev);
+	if (ret) {
+		dev_err(&idev->dev, "Error: iio dev can't register(%d)\n", ret);
+		goto error_iio_dev_reg;
+	}
+
+	/* set convert rate */
+	sh_adc_set_bit(adc, SH_ADC_ADCSR_CKS_1054, SH_ADC_ADCSR);
+
+	dev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);
+
+	/* initialize mtu2 as a ADC trigger */
+	adc->mtu2_ch = pdata->mtu2_ch;
+	sh_mtu2_enable(adc);
+
+	return 0;
+
+error_iio_dev_reg:
+	clk_disable(adc->mtu2_clk);
+	devm_clk_put(&pdev->dev, adc->mtu2_clk);
+error_mtu2_clk:
+	clk_disable(adc->clk);
+	devm_clk_put(&pdev->dev, adc->clk);
+error_free_irq:
+	sh_adc_iio_free_irqs(pdev, nres);
+error_map:
+	sh_adc_iio_map_unregister(pdev, adc, nmap);
+	iio_device_free(idev);
+	return ret;
+}
+
+static int sh_adc_remove(struct platform_device *pdev)
+{
+	struct iio_dev *idev = platform_get_drvdata(pdev);
+	struct sh_adc *adc = iio_priv(idev);
+
+	iio_device_unregister(idev);
+
+	clk_disable(adc->mtu2_clk);
+	devm_clk_put(&pdev->dev, adc->mtu2_clk);
+	clk_disable(adc->clk);
+	devm_clk_put(&pdev->dev, adc->clk);
+
+	sh_adc_iio_free_irqs(pdev, pdev->num_resources);
+	sh_adc_iio_map_unregister(pdev, adc, 3);
+	iio_device_free(idev);
+
+	return 0;
+}
+
+static struct platform_driver sh_adc_driver = {
+	.probe = sh_adc_probe,
+	.remove = sh_adc_remove,
+	.driver = {
+		.name = "sh_adc",
+		.owner = THIS_MODULE,
+	},
+};
+module_platform_driver(sh_adc_driver);
+
+MODULE_DESCRIPTION("SH ADC Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:sh-adc");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 07e9e82..7b13479 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -942,5 +942,21 @@ config TOUCHSCREEN_ZFORCE
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called zforce_ts.
-
+	  
+config TOUCHSCREEN_FT5X06
+	tristate "Focaltech FT5X06 5 point touchscreen"
+	depends on I2C
+	help
+	  If you say yes here you get touchscreen support through
+	  FocalTech's FT5X06 controller.
+		  
+config TOUCHSCREEN_FT5X06_SINGLE_TOUCH
+	bool "FT5X06 touchscreen as single-touch"
+	default N
+	depends on TOUCHSCREEN_FT5X06
+	help
+	  If you say yes here you get single-touch touchscreen support
+	  on the FT5X06 I2C controller.
+	  If you say "no", you'll get the normal 5-finger goodness.
+	
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 62801f2..8988204 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -77,3 +77,4 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5X06)    += ft5x06_ts.o
diff --git a/drivers/input/touchscreen/ft5x06_ts.c b/drivers/input/touchscreen/ft5x06_ts.c
new file mode 100644
index 0000000..a45f094
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x06_ts.c
@@ -0,0 +1,474 @@
+/*
+ * Driver for Focaltech FT5X06 Multiple Touch Controller
+ *
+ * Copyright (C) 2014 Renesas Electronics America.
+ *
+ * based on egalax_ts.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/io.h>  
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/bitops.h>
+#include <linux/input/mt.h>
+#include <mach/r7s72100.h>
+#include <linux/timer.h>
+
+//#define DB_PRINT
+
+#ifdef DB_PRINT
+#define DBG(...) printk("%s: ", __FUNCTION__);printk(__VA_ARGS__)
+#else
+#define DBG(...)
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_FT5X06_SINGLE_TOUCH
+#else
+#define USE_ABS_MT
+#endif
+
+/* Focaltech FT5X06 register set */
+#define WORK_MODE                       0x00
+#define FACTORY_MODE                    0x04
+
+#define ID_G_THGROUP		            0x80
+#define ID_G_PERIODMONITOR	            0x89
+#define FT5X0X_REG_HEIGHT_B	            0x8a
+#define FT5X0X_REG_MAX_FRAME	        0x8b
+#define FT5X0X_REG_FEG_FRAME	        0x8e
+#define FT5X0X_REG_LEFT_RIGHT_OFFSET    0x92
+#define FT5X0X_REG_UP_DOWN_OFFSET	    0x93
+#define FT5X0X_REG_DISTANCE_LEFT_RIGHT	0x94
+#define FT5X0X_REG_DISTANCE_UP_DOWN	    0x95
+#define FT5X0X_REG_MAX_X_HIGH		    0x98
+#define FT5X0X_REG_MAX_X_LOW		    0x99
+#define FT5X0X_REG_MAX_Y_HIGH		    0x9a
+#define FT5X0X_REG_MAX_Y_LOW		    0x9b
+#define FT5X0X_REG_K_X_HIGH		        0x9c
+#define FT5X0X_REG_K_X_LOW		        0x9d
+#define FT5X0X_REG_K_Y_HIGH		        0x9e
+#define FT5X0X_REG_K_Y_LOW		        0x9f
+
+#define ID_G_AUTO_CLB	                0xa0
+#define ID_G_B_AREA_TH	                0xae
+
+//#define USE_ABS_MT 
+
+struct point {
+	int	x;
+	int	y;
+};
+
+struct ft5x06_ts {
+	struct i2c_client	*client;
+	struct input_dev	*idev;
+	struct delayed_work work;
+	int irq;
+	spinlock_t	        lock;
+	struct point	last;
+};
+   
+static struct workqueue_struct *ft5x06_ts_wq;
+
+static int calibration[7] = {
+	65536,0,0,
+	0,65536,0,
+	65536
+};
+module_param_array(calibration, int, NULL, S_IRUGO | S_IWUSR);
+
+static int screenres[2] = {1280, 800};
+module_param_array(screenres, int, NULL, S_IRUGO | S_IWUSR);
+
+static void translate(int *px, int *py)
+{
+	int x, y, x1, y1;
+	if (calibration[6]) {
+		x1 = *px;
+		y1 = *py;
+
+		x = calibration[0] * x1 +
+			calibration[1] * y1 +
+			calibration[2];
+		x /= calibration[6];
+		if (x < 0)
+			x = 0;
+		y = calibration[3] * x1 +
+			calibration[4] * y1 +
+			calibration[5];
+		y /= calibration[6];
+		if (y < 0)
+			y = 0;
+		*px = x ;
+		*py = y ;
+	}
+}
+
+static inline void ts_evt_add(struct ft5x06_ts *ts,
+			                  unsigned buttons, struct point *p)
+{
+	struct input_dev *idev = ts->idev;
+	int i;
+	
+	if (!buttons) { /* send release to user space. */
+		/* Ignore duplicate reports */
+		if( (ts->last.x == -1) && (ts->last.y == -1) )
+			return;
+		ts->last.x = -1;
+		ts->last.y = -1;
+
+#ifdef USE_ABS_MT
+		input_event(idev, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
+		input_event(idev, EV_KEY, BTN_TOUCH, 0);
+		input_mt_sync(idev);
+#else
+		input_report_abs(idev, ABS_PRESSURE, 0);
+		input_report_key(idev, BTN_TOUCH, 0);
+		input_sync(idev);
+#endif
+	} else {
+		for (i = 0; i < buttons; i++) {
+#ifdef CONFIG_MACH_RSKRZA1
+			/* The X and Y are inverted on this LCD panel */
+			p[i].x = 800 - p[i].x;
+			p[i].y = 480 - p[i].y;
+#else
+			translate(&p[i].x, &p[i].y);
+#endif
+			/* Ignore duplicates reports */
+			if( (p[i].x == ts->last.x) && (p[i].y == ts->last.y))
+				continue;
+			ts->last.x = p[i].x;
+			ts->last.y = p[i].y;
+#ifdef USE_ABS_MT
+			input_event(idev, EV_ABS, ABS_MT_POSITION_X, p[i].x);
+			input_event(idev, EV_ABS, ABS_MT_POSITION_Y, p[i].y);
+			input_event(idev, EV_ABS, ABS_MT_TOUCH_MAJOR, 1);
+			input_mt_sync(idev);
+#else
+			input_report_abs(idev, ABS_X, p[i].x);
+			input_report_abs(idev, ABS_Y, p[i].y);
+			input_report_abs(idev, ABS_PRESSURE, 1);
+			input_report_key(idev, BTN_TOUCH, 1);
+			input_sync(idev);
+#endif
+		}
+		input_event(idev, EV_KEY, BTN_TOUCH, 1);
+	}
+#ifdef USE_ABS_MT
+	input_sync(idev);
+#endif
+}
+
+static void read_report(struct ft5x06_ts *ts)
+{
+	uint8_t  cmd = 0;
+	uint8_t  buf[33];
+	uint8_t  *p;
+	int      ret, i, buttons = 0 ;
+	struct point points[5];
+	
+	/* Clear buffer */
+	memset(buf, 0, sizeof(buf));
+	
+	ret = i2c_master_send(ts->client, &cmd, 1);
+	if (ret != 1) {
+		dev_err(&ts->client->dev, "Unable to write to i2c touchscreen!\n");
+		return;
+	}		
+	
+	ret = i2c_master_recv(ts->client, buf, sizeof(buf));
+	if (ret != sizeof(buf)) {
+		dev_err(&ts->client->dev, "Unable to read i2c page!\n");		
+		return;
+	}	
+		
+	p = buf + 3; 
+	buttons = buf[2];
+	
+	if (buttons > 5) {
+		printk(KERN_ERR 
+		       "%s: invalid button count %02x\n",
+				__func__, buttons);
+				buttons = 0 ;
+	} else {
+		for (i = 0; i < buttons; i++) {
+			points[i].x = ((p[0] << 8) | p[1]) & 0x7ff;
+			points[i].y = ((p[2] << 8) | p[3]) & 0x7ff;
+			p += 6;
+		}
+	}	
+	
+	ts_evt_add(ts, buttons, points);	
+}
+
+static void ft5x06_ts_poscheck(struct work_struct *work)
+{
+	struct ft5x06_ts *ts = container_of(work, struct ft5x06_ts, work.work);
+
+	read_report(ts);
+	
+	enable_irq(ts->client->irq);	
+}
+
+static irqreturn_t ft5x06_ts_isr(int irq, void *dev_id)
+{     
+	struct ft5x06_ts *ts = dev_id;
+
+	disable_irq_nosync(irq);
+		
+	queue_work(ft5x06_ts_wq, &ts->work.work);
+	
+	return IRQ_HANDLED;	
+}
+
+#if 0
+/* wake up controller by an falling edge of interrupt gpio.  */
+static int ft5x06_wake_up_device(struct i2c_client *client)
+{
+	return 0;
+}
+#endif
+
+static int ft5x06_write_reg(struct i2c_client *client, uint8_t reg, uint8_t val)
+{
+	uint8_t buf[2];
+
+	buf[0] = reg;
+	buf[1] = val;
+
+	if (i2c_master_send(client, buf, 2) != 2) {
+		dev_err(&client->dev, "%s: i2c send failed\n", __func__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void ft5x06_set_mode(struct i2c_client *client, int mode)
+{
+	ft5x06_write_reg(client, 0, (mode & 7) << 4);
+	printk(KERN_DEBUG "%s: changed mode to 0x%02x\n", __func__, mode);
+}
+
+static int ft5x06_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	char buffer;
+	struct i2c_msg pkt = {
+		client->addr,
+		I2C_M_RD,
+		sizeof(buffer),
+		&buffer
+	};
+	
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+	if (i2c_transfer(adapter, &pkt, 1) != 1)
+		return -ENODEV;
+
+    DBG ("detect_ft5x06 sucessfully\n"); 	
+	return 0;
+}
+
+static int ft5x06_init_panel(struct i2c_client *client)
+{ 	
+	int ret;
+	
+	ret = ft5x06_detect(client);
+	
+	if (ret != 0) {
+		dev_err(&client->dev, "%s: could not detect ft5x06\n", __func__);
+		return ret;
+	}	
+	
+	ft5x06_set_mode(client, WORK_MODE);
+	
+	return 0;
+}
+
+static int ft5x06_ts_probe(struct i2c_client *client, const struct i2c_device_id *id) 
+{
+    struct ft5x06_ts *ts;
+	struct input_dev *idev;
+	int ret;
+	int error;
+		
+	if (!i2c_check_functionality(client->adapter,
+					I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
+					I2C_FUNC_SMBUS_READ_WORD_DATA  |
+					I2C_FUNC_SMBUS_READ_I2C_BLOCK))
+	{	
+		dev_err(&client->dev, "Error bus incompatible\n");
+		return -EIO;
+	}
+
+    /* allocate driver data struture */ 	
+	ts = kzalloc(sizeof(struct ft5x06_ts), GFP_KERNEL);
+	if (!ts) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	idev = input_allocate_device();
+	if (!idev) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		error = -ENOMEM;
+		goto err_free_ts;
+	}
+	
+	ts->client = client;
+	ts->idev = idev;
+	ts->irq = client->irq;
+	ts->last.x = -1;
+	ts->last.y = -1;
+
+	idev->name = "FT5X06 Multiple Touch Controller";
+	idev->id.bustype = BUS_I2C;
+	idev->dev.parent = &client->dev;
+     	
+	__set_bit(EV_ABS, idev->evbit);
+	__set_bit(EV_KEY, idev->evbit);
+	__set_bit(BTN_TOUCH, idev->keybit);
+
+#ifdef USE_ABS_MT
+	input_set_abs_params(idev, ABS_MT_POSITION_X, 0, screenres[0]-1, 0, 0);
+	input_set_abs_params(idev, ABS_MT_POSITION_Y, 0, screenres[1]-1, 0, 0);
+	input_set_abs_params(idev, ABS_X, 0, screenres[0]-1, 0, 0);
+	input_set_abs_params(idev, ABS_Y, 0, screenres[1]-1, 0, 0);
+	input_set_abs_params(idev, ABS_MT_TOUCH_MAJOR, 0, 1, 0, 0);
+#else
+	__set_bit(EV_SYN, idev->evbit);
+	input_set_abs_params(idev, ABS_X, 0, screenres[0]-1, 0, 0);
+	input_set_abs_params(idev, ABS_Y, 0, screenres[1]-1, 0, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, 1, 0, 0);
+#endif
+		
+	/* get idev */
+    input_set_drvdata(idev, ts);
+   
+    /* Controller chip interrrupt active low enable */
+	ret = ft5x06_init_panel(client);
+	if (ret < 0) {
+		dev_err(&client->dev, "could not init touch panel\n");
+		error = -EIO;
+		goto err_free_ts;
+	}	
+	
+	/* Register input device */
+	error = input_register_device(ts->idev);
+	if (error)
+		goto err_free_ts;
+
+	i2c_set_clientdata(client, ts);
+	
+	spin_lock_init(&ts->lock);
+	
+	/* Create workqueue */
+    ft5x06_ts_wq = create_singlethread_workqueue ("ft5x06_ts_wq");
+	
+    if(!ft5x06_ts_wq) {
+	   error = -ENOMEM;
+	   goto err_free_dev;
+    }
+	
+	INIT_WORK(&ts->work.work, ft5x06_ts_poscheck);
+   
+    /* gpio irq handler register */
+	error = request_irq(client->irq, ft5x06_ts_isr, 0, "ft5x06_ts", ts);
+					
+	if (error < 0) {
+		dev_err(&client->dev, "Failed to register interrupt\n");
+		goto err_free_wq;
+	}
+	
+	device_init_wakeup(&client->dev, 1);
+		
+	return 0;
+
+err_free_wq:
+	destroy_workqueue(ft5x06_ts_wq);	
+err_free_dev:
+	input_free_device(idev);
+err_free_ts:
+	kfree(ts);
+	return error;
+}
+
+static int ft5x06_ts_remove(struct i2c_client *client) 
+{
+	struct ft5x06_ts *ts = i2c_get_clientdata(client);
+
+	if (ft5x06_ts_wq) {
+	  flush_workqueue(ft5x06_ts_wq);
+	  destroy_workqueue(ft5x06_ts_wq);
+	}
+	  
+	free_irq(client->irq, ts);
+
+	input_unregister_device(ts->idev);
+	kfree(ts);
+
+	return 0;
+}
+
+static const struct i2c_device_id ft5x06_ts_id[] = {
+	{ "ft5x06-ts", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ft5x06_ts_id);
+
+#ifdef CONFIG_PM_SLEEP
+static int ft5x06_ts_suspend(struct device *dev) 
+{
+	struct i2c_client *client = to_i2c_client(dev);	
+	struct ft5x06_ts *ts = dev_get_drvdata(&client->dev);
+
+	if (device_may_wakeup(&client->dev))
+		enable_irq_wake(ts->irq);
+		
+	return 0;
+}
+
+static int ft5x06_ts_resume(struct device *dev) 
+{
+	struct i2c_client *client = to_i2c_client(dev);	
+	struct ft5x06_ts *ts = dev_get_drvdata(&client->dev);
+	
+	if (device_may_wakeup(&client->dev))
+		disable_irq_wake(ts->irq);	
+	
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(ft5x06_ts_pm_ops, ft5x06_ts_suspend, ft5x06_ts_resume);
+
+
+static struct i2c_driver ft5x06_ts_driver = {
+	.driver = {
+		.name	= "ft5x06-ts",
+		.owner	= THIS_MODULE,
+		.pm	= &ft5x06_ts_pm_ops,
+	},
+	.id_table	= ft5x06_ts_id,
+	.probe		= ft5x06_ts_probe,
+	.remove		= ft5x06_ts_remove,
+};
+
+module_i2c_driver(ft5x06_ts_driver);
+
+MODULE_AUTHOR("Renesas Electronics America");
+MODULE_DESCRIPTION("Touchscreen driver for FT5X06 touch controller");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/sh_mobile_sdhi.c b/drivers/mmc/host/sh_mobile_sdhi.c
index 2d6ce25..e9fb1b76 100644
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@ -30,11 +30,20 @@
 #include <linux/mfd/tmio.h>
 #include <linux/sh_dma.h>
 #include <linux/delay.h>
+#ifdef CONFIG_RZA1_DMAE
+#include <linux/platform_data/dma-rza1.h>
+#endif
 
 #include "tmio_mmc.h"
 
 #define EXT_ACC           0xe4
 
+#ifdef CONFIG_RZA1_DMAE
+#define sh_mobile_sdhi_filter	rza1dma_chan_filter
+#else
+#define sh_mobile_sdhi_filter	shdma_chan_filter
+#endif
+
 struct sh_mobile_sdhi_of_data {
 	unsigned long tmio_flags;
 };
@@ -194,7 +203,7 @@ static int sh_mobile_sdhi_probe(struct platform_device *pdev)
 	}
 
 	dma_priv->alignment_shift = 1; /* 2-byte alignment */
-	dma_priv->filter = shdma_chan_filter;
+	dma_priv->filter = sh_mobile_sdhi_filter;
 
 	mmc_data->dma = dma_priv;
 
diff --git a/drivers/mmc/host/tmio_mmc_dma.c b/drivers/mmc/host/tmio_mmc_dma.c
index 03e7b28..1b11435 100644
--- a/drivers/mmc/host/tmio_mmc_dma.c
+++ b/drivers/mmc/host/tmio_mmc_dma.c
@@ -74,6 +74,9 @@ static void tmio_mmc_start_dma_rx(struct tmio_mmc_host *host)
 
 	if (sg->length < TMIO_MMC_MIN_DMA_LEN) {
 		host->force_pio = true;
+#if defined(CONFIG_ARCH_R7S72100)
+		tmio_mmc_enable_dma(host, false);
+#endif
 		return;
 	}
 
@@ -107,6 +110,9 @@ pio:
 		tmio_mmc_enable_dma(host, false);
 		if (ret >= 0)
 			ret = -EIO;
+#if defined(CONFIG_ARCH_R7S72100)
+		tmio_mmc_enable_dma(host, false);
+#endif
 		host->chan_rx = NULL;
 		dma_release_channel(chan);
 		/* Free the Tx channel too */
@@ -151,6 +157,9 @@ static void tmio_mmc_start_dma_tx(struct tmio_mmc_host *host)
 
 	if (sg->length < TMIO_MMC_MIN_DMA_LEN) {
 		host->force_pio = true;
+#if defined(CONFIG_ARCH_R7S72100)
+		tmio_mmc_enable_dma(host, false);
+#endif
 		return;
 	}
 
@@ -188,6 +197,9 @@ pio:
 		tmio_mmc_enable_dma(host, false);
 		if (ret >= 0)
 			ret = -EIO;
+#if defined(CONFIG_ARCH_R7S72100)
+		tmio_mmc_enable_dma(host, false);
+#endif
 		host->chan_tx = NULL;
 		dma_release_channel(chan);
 		/* Free the Rx channel too */
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
index 8d8abf2..e9c2cfb 100644
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@ -38,6 +38,7 @@
 #include <linux/mmc/mmc.h>
 #include <linux/mmc/slot-gpio.h>
 #include <linux/mmc/tmio.h>
+#include <linux/mmc/sdio.h>
 #include <linux/module.h>
 #include <linux/pagemap.h>
 #include <linux/platform_device.h>
@@ -50,6 +51,22 @@
 
 #include "tmio_mmc.h"
 
+#if defined(CONFIG_ARCH_R7S72100) && \
+    (defined(CONFIG_MMC_SDHI) || defined(CONFIG_MMC_SDHI_MODULE))
+#define RZA1_SDHI 1
+static inline void sd_ctrl_read32_rep(struct tmio_mmc_host *host, int addr,
+		u32 *buf, int count)
+{
+	readsl(host->ctl + (addr << host->pdata->bus_shift), buf, count);
+}
+
+static inline void sd_ctrl_write32_rep(struct tmio_mmc_host *host, int addr,
+		u32 *buf, int count)
+{
+	writesl(host->ctl + (addr << host->pdata->bus_shift), buf, count);
+}
+#endif
+
 void tmio_mmc_enable_mmc_irqs(struct tmio_mmc_host *host, u32 i)
 {
 	host->sdcard_irq_mask &= ~(i & TMIO_MASK_IRQ);
@@ -164,24 +181,24 @@ static void tmio_mmc_clk_stop(struct tmio_mmc_host *host)
 	/* implicit BUG_ON(!res) */
 	if (host->pdata->flags & TMIO_MMC_HAVE_HIGH_REG) {
 		sd_ctrl_write16(host, CTL_CLK_AND_WAIT_CTL, 0x0000);
-		msleep(10);
+		usleep_range(10000, 11000);
 	}
 
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~0x0100 &
 		sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
-	msleep(10);
+	usleep_range(10000, 11000);
 }
 
 static void tmio_mmc_clk_start(struct tmio_mmc_host *host)
 {
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, 0x0100 |
 		sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
-	msleep(10);
+	usleep_range(10000, 11000);
 
 	/* implicit BUG_ON(!res) */
 	if (host->pdata->flags & TMIO_MMC_HAVE_HIGH_REG) {
 		sd_ctrl_write16(host, CTL_CLK_AND_WAIT_CTL, 0x0100);
-		msleep(10);
+		usleep_range(10000, 11000);
 	}
 }
 
@@ -192,11 +209,11 @@ static void tmio_mmc_reset(struct tmio_mmc_host *host)
 	/* implicit BUG_ON(!res) */
 	if (host->pdata->flags & TMIO_MMC_HAVE_HIGH_REG)
 		sd_ctrl_write16(host, CTL_RESET_SDIO, 0x0000);
-	msleep(10);
+	usleep_range(10000, 11000);
 	sd_ctrl_write16(host, CTL_RESET_SD, 0x0001);
 	if (host->pdata->flags & TMIO_MMC_HAVE_HIGH_REG)
 		sd_ctrl_write16(host, CTL_RESET_SDIO, 0x0001);
-	msleep(10);
+	usleep_range(10000, 11000);
 }
 
 static void tmio_mmc_reset_work(struct work_struct *work)
@@ -236,6 +253,10 @@ static void tmio_mmc_reset_work(struct work_struct *work)
 	host->data = NULL;
 	host->force_pio = false;
 
+#if defined(CONFIG_ARCH_R7S72100)
+	tmio_mmc_enable_dma(host, true);
+#endif
+
 	spin_unlock_irqrestore(&host->lock, flags);
 
 	tmio_mmc_reset(host);
@@ -264,6 +285,9 @@ static void tmio_mmc_finish_request(struct tmio_mmc_host *host)
 	host->cmd = NULL;
 	host->data = NULL;
 	host->force_pio = false;
+#if defined(CONFIG_ARCH_R7S72100)
+	tmio_mmc_enable_dma(host, true);
+#endif
 
 	cancel_delayed_work(&host->delayed_reset_work);
 
@@ -380,9 +404,19 @@ static void tmio_mmc_pio_irq(struct tmio_mmc_host *host)
 
 	/* Transfer the data */
 	if (data->flags & MMC_DATA_READ)
+#if defined(CONFIG_ARCH_R7S72100)
+		sd_ctrl_read32_rep(host, CTL_SD_DATA_PORT, (u32 *)buf,
+					count >> 2);
+#else
 		sd_ctrl_read16_rep(host, CTL_SD_DATA_PORT, buf, count >> 1);
+#endif
 	else
+#if defined(CONFIG_ARCH_R7S72100)
+		sd_ctrl_write32_rep(host, CTL_SD_DATA_PORT, (u32 *)buf,
+					count >> 2);
+#else
 		sd_ctrl_write16_rep(host, CTL_SD_DATA_PORT, buf, count >> 1);
+#endif
 
 	host->sg_off += count;
 
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index ad19139..ffa73eb 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -1259,13 +1259,14 @@ static int m25p_probe(struct spi_device *spi)
 	else if (flash->mtd.size > 0x1000000) {
 		/* enable 4-byte addressing if the device exceeds 16MiB */
 		flash->addr_width = 4;
-		if (JEDEC_MFR(info->jedec_id) == CFI_MFR_AMD) {
+		if (0) { //JEDEC_MFR(info->jedec_id) == CFI_MFR_AMD) {
 			/* Dedicated 4-byte command set */
 			switch (flash->flash_read) {
 			case M25P80_QUAD:
 				flash->read_opcode = OPCODE_QUAD_READ_4B;
 				break;
 			case M25P80_FAST:
+				printk("WTF?\n");
 				flash->read_opcode = OPCODE_FAST_READ_4B;
 				break;
 			case M25P80_NORMAL:
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 22f2f28..0c8d99f 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -253,4 +253,15 @@ config PWM_VT8500
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-vt8500.
 
+config PWM_RZA1
+	tristate "RZ/A1 pwm support (TIOC4A)"
+	depends on ARCH_R7S72100
+	help
+	  Generic PWM framework driver for RZ/A1.
+	  PWM out is for TIOC4A pin only.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-rza1.
+
+
 endif
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index d8906ec..dc8c06f 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -23,3 +23,4 @@ obj-$(CONFIG_PWM_TIPWMSS)	+= pwm-tipwmss.o
 obj-$(CONFIG_PWM_TWL)		+= pwm-twl.o
 obj-$(CONFIG_PWM_TWL_LED)	+= pwm-twl-led.o
 obj-$(CONFIG_PWM_VT8500)	+= pwm-vt8500.o
+obj-$(CONFIG_PWM_RZA1)		+= pwm-rza1.o
diff --git a/drivers/pwm/pwm-rza1.c b/drivers/pwm/pwm-rza1.c
new file mode 100644
index 0000000..10aac03
--- /dev/null
+++ b/drivers/pwm/pwm-rza1.c
@@ -0,0 +1,311 @@
+/*
+ * RZ/A1 PWM driver
+ *
+ * Copyright (C) 2014  Renesas Solutions Corp.
+ *
+ * Based on pwm-pxa.c:
+ * 2008-02-13	initial version
+ *      eric miao <eric.miao@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/pwm.h>
+
+#include <asm/div64.h>
+
+#define HAS_SECONDARY_PWM	0x10
+
+static DEFINE_RAW_SPINLOCK(mtu2_lock);
+
+static const struct platform_device_id pwm_id_table[] = {
+	/*   PWM    has_secondary_pwm? */
+	{ "rza1-pwm", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(platform, pwm_id_table);
+
+/* PWM registers and bits definitions */
+
+#define TCR_4		(0x001)
+#define TMDR_4		(0x003)
+#define TIORH_4		(0x006)
+#define TIORL_4		(0x007)
+#define TIER_4		(0x009)
+#define TSR_4		(0x02D)
+#define TCNT_4		(0x012)
+#define TGRA_4		(0x01C)
+#define TGRB_4		(0x01E)
+
+#define TOER		(0x00A)
+
+#define TSTR		(0x000)
+#define TSYR		(0x001)
+#define TRWER		(0x004)
+
+#define TGR_MAX_VALUE (0xFFFF)
+
+struct rza1_pwm_chip {
+	struct pwm_chip	chip;
+	struct device	*dev;
+
+	struct clk	*clk;
+	int		clk_enabled;
+	void __iomem	*mmio_base;
+	void __iomem	*mmio_share_base;
+};
+
+static inline struct rza1_pwm_chip *to_rza1_pwm_chip(struct pwm_chip *chip)
+{
+	return container_of(chip, struct rza1_pwm_chip, chip);
+}
+
+static int rza1_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			  int duty_ns, int period_ns)
+{
+	struct rza1_pwm_chip *pc = to_rza1_pwm_chip(chip);
+	unsigned long long c, clk_rate;
+	unsigned long period_cycles, prescale, pv, dc;
+	int rc;
+	unsigned char  reg_b;
+	unsigned long flags;
+
+	clk_rate = clk_get_rate(pc->clk);
+	c = clk_rate * period_ns;
+	do_div(c, 1000000000);
+	period_cycles = c;
+
+	if (period_cycles < 1)
+		period_cycles = 1;
+
+	c = clk_rate * duty_ns;
+	do_div(c, 1000000000);
+
+	/* prescale 1,4,16,64 */
+	/* 1 Dividing */
+	if ((period_cycles / TGR_MAX_VALUE) == 0) {
+		prescale = 0;
+		pv = period_cycles;
+		dc = c;
+	/* 4 Dividing */
+	} else if ((period_cycles / (TGR_MAX_VALUE * 4)) == 0) {
+		prescale = 1;
+		pv = period_cycles / 4;
+		dc = c / 4;
+	/* 16 Dividing */
+	} else if ((period_cycles / (TGR_MAX_VALUE * 16)) == 0) {
+		prescale = 2;
+		pv = period_cycles / 16;
+		dc = c / 16;
+	/* 64 Dividing */
+	} else if ((period_cycles / (TGR_MAX_VALUE * 64)) == 0) {
+		prescale = 3;
+		pv = period_cycles / 64;
+		dc = c / 64;
+	/* Over 64 Dividing */
+	} else {
+		dev_err(chip->dev, "rza1-pwm prescale over!!\n");
+		return -EINVAL;
+	}
+
+	if (duty_ns == period_ns)
+		dc = pv;
+
+	/* NOTE: the clock to PWM has to be enabled first
+	 * before writing to the registers
+	 */
+	rc = clk_prepare_enable(pc->clk);
+	if (rc < 0)
+		return rc;
+
+	/* PWM mode setting */
+	/* Timer count stop */
+	/*  TSTR:CST4 = 0 */
+	raw_spin_lock_irqsave(&mtu2_lock, flags);
+	reg_b = ioread8(pc->mmio_share_base + TSTR);
+	reg_b &= 0x7F;	/* CST4 = 0 */
+	iowrite8(reg_b, pc->mmio_share_base + TSTR);
+	raw_spin_unlock_irqrestore(&mtu2_lock, flags);
+
+	/* Counter 0 clear */
+	iowrite16(0, pc->mmio_base + TCNT_4);
+
+	/* Selection of a counter clock */
+	/*  TCR:CKEG = 00b(counts by a rising edge) */
+	/*  TCR:TPSC = prescale */
+	/* Selection of a counter clear factor */
+	/*  TCR:CCLR = 001b(counter clearance at TGRA) */
+	iowrite8((0x20 | prescale), pc->mmio_base + TCR_4);
+
+	/* Selection of a waveform output level */
+	if (duty_ns <= 0) {	/* PWM OFF */
+		/* TIOR:IOB = 0001b(initial output of TRGB = 0, Compar = 0) */
+		/* TIOR:IOA = 0001b(initial output of TRGA = 0, Compar = 0) */
+		iowrite8(0x11, pc->mmio_base + TIORH_4);
+	} else {
+		/* TIOR:IOB = 0101b(initial output of TRGB = 1, Compar = 0) */
+		/* TIOR:IOA = 0110b(initial output of TRGA = 1, Compar = 1) */
+		iowrite8(0x56, pc->mmio_base + TIORH_4);
+	}
+
+	/* setup of TGR */
+	/*  TRGA Setting(PWM period Setting) */
+	/*  TRGB Setting(PWM duty Setting) */
+	iowrite16(pv, pc->mmio_base + TGRA_4);
+	iowrite16(dc, pc->mmio_base + TGRB_4);
+
+	/* setup in PWM mode */
+	/*  TMDR:MD = 0010b(PWM mode 1) */
+	iowrite8(0x02, pc->mmio_base + TMDR_4);
+
+	/* Output Enable */
+	/*  TOER:OE4A = 1(TIOC4A output enable) */
+	reg_b = ioread8(pc->mmio_base + TOER);
+	reg_b |= 0x02;	/* OE4A = 1 */
+	iowrite8(reg_b, pc->mmio_base + TOER);
+
+	/* Timer count start */
+	/*  TSTR:CST4 = 1 */
+	if (duty_ns > 0) {	/* PWM ON */
+		raw_spin_lock_irqsave(&mtu2_lock, flags);
+		reg_b = ioread8(pc->mmio_share_base + TSTR);
+		reg_b |= 0x80;	/* CST4 = 1 */
+		iowrite8(reg_b, pc->mmio_share_base + TSTR);
+		raw_spin_unlock_irqrestore(&mtu2_lock, flags);
+	}
+
+	clk_disable_unprepare(pc->clk);
+
+	return 0;
+}
+
+static int rza1_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct rza1_pwm_chip *pc = to_rza1_pwm_chip(chip);
+	int rc = 0;
+
+	if (!pc->clk_enabled) {
+		rc = clk_prepare_enable(pc->clk);
+		if (!rc)
+			pc->clk_enabled++;
+	}
+	return rc;
+}
+
+static void rza1_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct rza1_pwm_chip *pc = to_rza1_pwm_chip(chip);
+
+	if (pc->clk_enabled) {
+		clk_disable_unprepare(pc->clk);
+		pc->clk_enabled--;
+	}
+}
+
+static struct pwm_ops rza1_pwm_ops = {
+	.config = rza1_pwm_config,
+	.enable = rza1_pwm_enable,
+	.disable = rza1_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+static int pwm_probe(struct platform_device *pdev)
+{
+	const struct platform_device_id *id = platform_get_device_id(pdev);
+	struct rza1_pwm_chip *pwm;
+	struct resource *r;
+	int ret = 0;
+
+	pwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);
+	if (pwm == NULL) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	pwm->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pwm->clk))
+		return PTR_ERR(pwm->clk);
+
+	pwm->clk_enabled = 0;
+
+	pwm->chip.dev = &pdev->dev;
+	pwm->chip.ops = &rza1_pwm_ops;
+	pwm->chip.base = -1;
+	pwm->chip.npwm = (id->driver_data & HAS_SECONDARY_PWM) ? 2 : 1;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		dev_err(&pdev->dev, "no memory resource defined\n");
+		return -ENODEV;
+	}
+
+	pwm->mmio_base = devm_request_and_ioremap(&pdev->dev, r);
+	if (pwm->mmio_base == NULL)
+		return -EADDRNOTAVAIL;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (r == NULL) {
+		dev_err(&pdev->dev, "no memory resource defined\n");
+		return -ENODEV;
+	}
+
+	pwm->mmio_share_base = ioremap(r->start, resource_size(r));
+	if (pwm->mmio_share_base == NULL)
+		return -EADDRNOTAVAIL;
+
+	ret = pwmchip_add(&pwm->chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
+		return ret;
+	}
+
+	dev_info(&pdev->dev, "RZ/A1 PWM Driver probed\n");
+
+	platform_set_drvdata(pdev, pwm);
+	return 0;
+}
+
+static int pwm_remove(struct platform_device *pdev)
+{
+	struct rza1_pwm_chip *chip;
+
+	chip = platform_get_drvdata(pdev);
+	if (chip == NULL)
+		return -ENODEV;
+
+	return pwmchip_remove(&chip->chip);
+}
+
+static struct platform_driver pwm_driver = {
+	.driver		= {
+		.name	= "rza1-pwm",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= pwm_probe,
+	.remove		= pwm_remove,
+	.id_table	= pwm_id_table,
+};
+module_platform_driver(pwm_driver);
+
+MODULE_ALIAS("platform:rza1-pwm");
+MODULE_DESCRIPTION("Renesas RZA1 PWM Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index db933de..e13426c 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -976,7 +976,7 @@ config RTC_DRV_SA1100
 
 config RTC_DRV_SH
 	tristate "SuperH On-Chip RTC"
-	depends on SUPERH && HAVE_CLK
+	depends on (SUPERH || ARCH_SHMOBILE) && HAVE_CLK
 	help
 	  Say Y here to enable support for the on-chip RTC found in
 	  most SuperH processors.
diff --git a/drivers/rtc/rtc-sh.c b/drivers/rtc/rtc-sh.c
index d0d2b04..c6e6886 100644
--- a/drivers/rtc/rtc-sh.c
+++ b/drivers/rtc/rtc-sh.c
@@ -1,6 +1,7 @@
 /*
  * SuperH On-Chip RTC Support
  *
+ * Copyright (C) 2013 Renesas Solutions Corp.
  * Copyright (C) 2006 - 2009  Paul Mundt
  * Copyright (C) 2006  Jamie Lenehan
  * Copyright (C) 2008  Angelo Castello
@@ -27,7 +28,11 @@
 #include <linux/log2.h>
 #include <linux/clk.h>
 #include <linux/slab.h>
+#ifdef CONFIG_ARCH_SHMOBILE
+#include <mach/rtc.h>
+#else
 #include <asm/rtc.h>
+#endif
 
 #define DRV_NAME	"sh-rtc"
 #define DRV_VERSION	"0.2.3"
@@ -592,6 +597,7 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 	struct rtc_time r;
 	char clk_name[6];
 	int clk_id, ret;
+	unsigned int tmp;
 
 	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
 	if (unlikely(!rtc))
@@ -610,9 +616,17 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 	rtc->carry_irq = platform_get_irq(pdev, 1);
 	rtc->alarm_irq = platform_get_irq(pdev, 2);
 
+#ifdef CONFIG_ARCH_SHMOBILE
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+#else
 	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+#endif
 	if (unlikely(res == NULL)) {
+#ifdef CONFIG_ARCH_SHMOBILE
+		dev_err(&pdev->dev, "No MEM resource\n");
+#else
 		dev_err(&pdev->dev, "No IO resource\n");
+#endif
 		return -ENOENT;
 	}
 
@@ -647,6 +661,10 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 	}
 
 	clk_enable(rtc->clk);
+	/* Start RTC */
+	tmp = readb(rtc->regbase + RCR2);
+	tmp |= RCR2_RTCEN ;				
+	writeb(tmp, rtc->regbase + RCR2);
 
 	rtc->capabilities = RTC_DEF_CAPABILITIES;
 	if (dev_get_platdata(&pdev->dev)) {
@@ -722,11 +740,22 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 		rtc_time_to_tm(0, &r);
 		rtc_set_time(rtc->rtc_dev, &r);
 	}
+	
+	tmp = readb(rtc->regbase + RCR2);
+	if( ( tmp & RCR2_START) == 0) {
+		tmp |= RCR2_START;
+		writeb(tmp, rtc->regbase + RCR2);
+	}
 
 	device_init_wakeup(&pdev->dev, 1);
+
 	return 0;
 
 err_unmap:
+	/* STOP RTC */
+	tmp = readb(rtc->regbase + RCR2);
+	tmp &= ~RCR2_RTCEN;				
+	writeb(tmp, rtc->regbase + RCR2);
 	clk_disable(rtc->clk);
 
 	return ret;
@@ -734,6 +763,7 @@ err_unmap:
 
 static int __exit sh_rtc_remove(struct platform_device *pdev)
 {
+	unsigned int tmp;
 	struct sh_rtc *rtc = platform_get_drvdata(pdev);
 
 	sh_rtc_irq_set_state(&pdev->dev, 0);
@@ -741,6 +771,20 @@ static int __exit sh_rtc_remove(struct platform_device *pdev)
 	sh_rtc_setaie(&pdev->dev, 0);
 	sh_rtc_setcie(&pdev->dev, 0);
 
+	free_irq(rtc->periodic_irq, rtc);
+
+	if (rtc->carry_irq > 0) {
+		free_irq(rtc->carry_irq, rtc);
+		free_irq(rtc->alarm_irq, rtc);
+	}
+
+	/* STOP RTC */
+	tmp = readb(rtc->regbase + RCR2);
+	tmp &= ~RCR2_RTCEN;				
+	writeb(tmp, rtc->regbase + RCR2);
+
+	iounmap(rtc->regbase);
+	release_mem_region(rtc->res->start, rtc->regsize);
 	clk_disable(rtc->clk);
 
 	return 0;
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 581ee2a..d0b9443 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -381,6 +381,12 @@ config SPI_RSPI
 	help
 	  SPI driver for Renesas RSPI and QSPI blocks.
 
+config SPI_SH_SPIBSC
+	tristate "Renesas SPIBSC controller for RZA1"
+	depends on ARCH_R7S72100 && !XIP_KERNEL
+	help
+	  SPIBSC driver for Renesas SPIBSC blocks.
+
 config SPI_S3C24XX
 	tristate "Samsung S3C24XX series SPI"
 	depends on ARCH_S3C24XX
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 95af48d..2f063fe 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -60,6 +60,7 @@ spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_DMA)	+= spi-pxa2xx-dma.o
 obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
 obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
 obj-$(CONFIG_SPI_RSPI)			+= spi-rspi.o
+obj-$(CONFIG_SPI_SH_SPIBSC)		+= spi-sh-spibsc.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi-s3c24xx-hw.o
 spi-s3c24xx-hw-y			:= spi-s3c24xx.o
 spi-s3c24xx-hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi-s3c24xx-fiq.o
diff --git a/drivers/spi/spi-rspi.c b/drivers/spi/spi-rspi.c
index 28987d9..1fb0ad2 100644
--- a/drivers/spi/spi-rspi.c
+++ b/drivers/spi/spi-rspi.c
@@ -1,7 +1,8 @@
 /*
  * SH RSPI driver
  *
- * Copyright (C) 2012  Renesas Solutions Corp.
+ * Copyright (C) 2012, 2013  Renesas Solutions Corp.
+ * Copyright (C) 2014 Glider bvba
  *
  * Based on spi-sh.c:
  * Copyright (C) 2011 Renesas Solutions Corp.
@@ -25,14 +26,14 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/errno.h>
-#include <linux/list.h>
-#include <linux/workqueue.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/sh_dma.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/rspi.h>
@@ -49,7 +50,7 @@
 #define RSPI_SPCKD		0x0c	/* Clock Delay Register */
 #define RSPI_SSLND		0x0d	/* Slave Select Negation Delay Register */
 #define RSPI_SPND		0x0e	/* Next-Access Delay Register */
-#define RSPI_SPCR2		0x0f	/* Control Register 2 */
+#define RSPI_SPCR2		0x0f	/* Control Register 2 (SH only) */
 #define RSPI_SPCMD0		0x10	/* Command Register 0 */
 #define RSPI_SPCMD1		0x12	/* Command Register 1 */
 #define RSPI_SPCMD2		0x14	/* Command Register 2 */
@@ -58,16 +59,23 @@
 #define RSPI_SPCMD5		0x1a	/* Command Register 5 */
 #define RSPI_SPCMD6		0x1c	/* Command Register 6 */
 #define RSPI_SPCMD7		0x1e	/* Command Register 7 */
+#define RSPI_SPCMD(i)		(RSPI_SPCMD0 + (i) * 2)
+#define RSPI_NUM_SPCMD		8
+#define RSPI_RZ_NUM_SPCMD	4
+#define QSPI_NUM_SPCMD		4
+
+/* RSPI on RZ only */
 #define RSPI_SPBFCR		0x20	/* Buffer Control Register */
 #define RSPI_SPBFDR		0x22	/* Buffer Data Count Setting Register */
 
-/*qspi only */
+/* QSPI only */
 #define QSPI_SPBFCR		0x18	/* Buffer Control Register */
 #define QSPI_SPBDCR		0x1a	/* Buffer Data Count Register */
 #define QSPI_SPBMUL0		0x1c	/* Transfer Data Length Multiplier Setting Register 0 */
 #define QSPI_SPBMUL1		0x20	/* Transfer Data Length Multiplier Setting Register 1 */
 #define QSPI_SPBMUL2		0x24	/* Transfer Data Length Multiplier Setting Register 2 */
 #define QSPI_SPBMUL3		0x28	/* Transfer Data Length Multiplier Setting Register 3 */
+#define QSPI_SPBMUL(i)		(QSPI_SPBMUL0 + (i) * 4)
 
 /* SPCR - Control Register */
 #define SPCR_SPRIE		0x80	/* Receive Interrupt Enable */
@@ -104,7 +112,7 @@
 #define SPSR_PERF		0x08	/* Parity Error Flag */
 #define SPSR_MODF		0x04	/* Mode Fault Error Flag */
 #define SPSR_IDLNF		0x02	/* RSPI Idle Flag */
-#define SPSR_OVRF		0x01	/* Overrun Error Flag */
+#define SPSR_OVRF		0x01	/* Overrun Error Flag (RSPI only) */
 
 /* SPSCR - Sequence Control Register */
 #define SPSCR_SPSLN_MASK	0x07	/* Sequence Length Specification */
@@ -121,13 +129,13 @@
 #define SPDCR_SPLWORD		SPDCR_SPLW1
 #define SPDCR_SPLBYTE		SPDCR_SPLW0
 #define SPDCR_SPLW		0x20	/* Access Width Specification (SH) */
-#define SPDCR_SPRDTD		0x10	/* Receive Transmit Data Select */
+#define SPDCR_SPRDTD		0x10	/* Receive Transmit Data Select (SH) */
 #define SPDCR_SLSEL1		0x08
 #define SPDCR_SLSEL0		0x04
-#define SPDCR_SLSEL_MASK	0x0c	/* SSL1 Output Select */
+#define SPDCR_SLSEL_MASK	0x0c	/* SSL1 Output Select (SH) */
 #define SPDCR_SPFC1		0x02
 #define SPDCR_SPFC0		0x01
-#define SPDCR_SPFC_MASK		0x03	/* Frame Count Setting (1-4) */
+#define SPDCR_SPFC_MASK		0x03	/* Frame Count Setting (1-4) (SH) */
 
 /* SPCKD - Clock Delay Register */
 #define SPCKD_SCKDL_MASK	0x07	/* Clock Delay Setting (1-8) */
@@ -151,7 +159,7 @@
 #define SPCMD_LSBF		0x1000	/* LSB First */
 #define SPCMD_SPB_MASK		0x0f00	/* Data Length Setting */
 #define SPCMD_SPB_8_TO_16(bit)	(((bit - 1) << 8) & SPCMD_SPB_MASK)
-#define SPCMD_SPB_8BIT		0x0000	/* qspi only */
+#define SPCMD_SPB_8BIT		0x0000	/* QSPI only */
 #define SPCMD_SPB_16BIT		0x0100
 #define SPCMD_SPB_20BIT		0x0000
 #define SPCMD_SPB_24BIT		0x0100
@@ -170,8 +178,8 @@
 #define SPCMD_CPHA		0x0001	/* Clock Phase Setting */
 
 /* SPBFCR - Buffer Control Register */
-#define SPBFCR_TXRST		0x80	/* Transmit Buffer Data Reset (qspi only) */
-#define SPBFCR_RXRST		0x40	/* Receive Buffer Data Reset (qspi only) */
+#define SPBFCR_TXRST		0x80	/* Transmit Buffer Data Reset */
+#define SPBFCR_RXRST		0x40	/* Receive Buffer Data Reset */
 #define SPBFCR_TXTRG_MASK	0x30	/* Transmit Buffer Data Triggering Number */
 #define SPBFCR_RXTRG_MASK	0x07	/* Receive Buffer Data Triggering Number */
 
@@ -181,22 +189,21 @@ struct rspi_data {
 	void __iomem *addr;
 	u32 max_speed_hz;
 	struct spi_master *master;
-	struct list_head queue;
-	struct work_struct ws;
 	wait_queue_head_t wait;
-	spinlock_t lock;
 	struct clk *clk;
-	u8 spsr;
 	u16 spcmd;
+	u8 spsr;
+	u8 sppcr;
+	int rx_irq, tx_irq;
 	const struct spi_ops *ops;
 
 	/* for dmaengine */
 	struct dma_chan *chan_tx;
 	struct dma_chan *chan_rx;
-	int irq;
 
 	unsigned dma_width_16bit:1;
 	unsigned dma_callbacked:1;
+	unsigned byte_access:1;
 };
 
 static void rspi_write8(const struct rspi_data *rspi, u8 data, u16 offset)
@@ -224,34 +231,47 @@ static u16 rspi_read16(const struct rspi_data *rspi, u16 offset)
 	return ioread16(rspi->addr + offset);
 }
 
+static void rspi_write_data(const struct rspi_data *rspi, u16 data)
+{
+	if (rspi->byte_access)
+		rspi_write8(rspi, data, RSPI_SPDR);
+	else /* 16 bit */
+		rspi_write16(rspi, data, RSPI_SPDR);
+}
+
+static u16 rspi_read_data(const struct rspi_data *rspi)
+{
+	if (rspi->byte_access)
+		return rspi_read8(rspi, RSPI_SPDR);
+	else /* 16 bit */
+		return rspi_read16(rspi, RSPI_SPDR);
+}
+
 /* optional functions */
 struct spi_ops {
-	int (*set_config_register)(const struct rspi_data *rspi,
-				   int access_size);
-	int (*send_pio)(struct rspi_data *rspi, struct spi_message *mesg,
-			struct spi_transfer *t);
-	int (*receive_pio)(struct rspi_data *rspi, struct spi_message *mesg,
-			   struct spi_transfer *t);
-
+	int (*set_config_register)(struct rspi_data *rspi, int access_size);
+	int (*transfer_one)(struct spi_master *master, struct spi_device *spi,
+			    struct spi_transfer *xfer);
+	u16 mode_bits;
 };
 
 /*
- * functions for RSPI
+ * functions for RSPI on legacy SH
  */
-static int rspi_set_config_register(const struct rspi_data *rspi,
-				    int access_size)
+static int rspi_set_config_register(struct rspi_data *rspi, int access_size)
 {
 	int spbr;
 
-	/* Sets output mode(CMOS) and MOSI signal(from previous transfer) */
-	rspi_write8(rspi, 0x00, RSPI_SPPCR);
+	/* Sets output mode, MOSI signal, and (optionally) loopback */
+	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
 
 	/* Sets transfer bit rate */
 	spbr = clk_get_rate(rspi->clk) / (2 * rspi->max_speed_hz) - 1;
 	rspi_write8(rspi, clamp(spbr, 0, 255), RSPI_SPBR);
 
-	/* Sets number of frames to be used: 1 frame */
-	rspi_write8(rspi, 0x00, RSPI_SPDCR);
+	/* Disable dummy transmission, set 16-bit word access, 1 frame */
+	rspi_write8(rspi, 0, RSPI_SPDCR);
+	rspi->byte_access = 0;
 
 	/* Sets RSPCK, SSL, next-access delay value */
 	rspi_write8(rspi, 0x00, RSPI_SPCKD);
@@ -262,8 +282,41 @@ static int rspi_set_config_register(const struct rspi_data *rspi,
 	rspi_write8(rspi, 0x00, RSPI_SPCR2);
 
 	/* Sets SPCMD */
-	rspi_write16(rspi, SPCMD_SPB_8_TO_16(access_size) | rspi->spcmd,
-		     RSPI_SPCMD0);
+	rspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);
+	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
+
+	/* Sets RSPI mode */
+	rspi_write8(rspi, SPCR_MSTR, RSPI_SPCR);
+
+	return 0;
+}
+
+/*
+ * functions for RSPI on RZ
+ */
+static int rspi_rz_set_config_register(struct rspi_data *rspi, int access_size)
+{
+	int spbr;
+
+	/* Sets output mode, MOSI signal, and (optionally) loopback */
+	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
+
+	/* Sets transfer bit rate */
+	spbr = clk_get_rate(rspi->clk) / (2 * rspi->max_speed_hz) - 1;
+	rspi_write8(rspi, clamp(spbr, 0, 255), RSPI_SPBR);
+
+	/* Disable dummy transmission, set byte access */
+	rspi_write8(rspi, SPDCR_SPLBYTE, RSPI_SPDCR);
+	rspi->byte_access = 1;
+
+	/* Sets RSPCK, SSL, next-access delay value */
+	rspi_write8(rspi, 0x00, RSPI_SPCKD);
+	rspi_write8(rspi, 0x00, RSPI_SSLND);
+	rspi_write8(rspi, 0x00, RSPI_SPND);
+
+	/* Sets SPCMD */
+	rspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);
+	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
 
 	/* Sets RSPI mode */
 	rspi_write8(rspi, SPCR_MSTR, RSPI_SPCR);
@@ -274,21 +327,20 @@ static int rspi_set_config_register(const struct rspi_data *rspi,
 /*
  * functions for QSPI
  */
-static int qspi_set_config_register(const struct rspi_data *rspi,
-				    int access_size)
+static int qspi_set_config_register(struct rspi_data *rspi, int access_size)
 {
-	u16 spcmd;
 	int spbr;
 
-	/* Sets output mode(CMOS) and MOSI signal(from previous transfer) */
-	rspi_write8(rspi, 0x00, RSPI_SPPCR);
+	/* Sets output mode, MOSI signal, and (optionally) loopback */
+	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
 
 	/* Sets transfer bit rate */
 	spbr = clk_get_rate(rspi->clk) / (2 * rspi->max_speed_hz);
 	rspi_write8(rspi, clamp(spbr, 0, 255), RSPI_SPBR);
 
-	/* Sets number of frames to be used: 1 frame */
-	rspi_write8(rspi, 0x00, RSPI_SPDCR);
+	/* Disable dummy transmission, set byte access */
+	rspi_write8(rspi, 0, RSPI_SPDCR);
+	rspi->byte_access = 1;
 
 	/* Sets RSPCK, SSL, next-access delay value */
 	rspi_write8(rspi, 0x00, RSPI_SPCKD);
@@ -297,13 +349,13 @@ static int qspi_set_config_register(const struct rspi_data *rspi,
 
 	/* Data Length Setting */
 	if (access_size == 8)
-		spcmd = SPCMD_SPB_8BIT;
+		rspi->spcmd |= SPCMD_SPB_8BIT;
 	else if (access_size == 16)
-		spcmd = SPCMD_SPB_16BIT;
+		rspi->spcmd |= SPCMD_SPB_16BIT;
 	else
-		spcmd = SPCMD_SPB_32BIT;
+		rspi->spcmd |= SPCMD_SPB_32BIT;
 
-	spcmd |= SPCMD_SCKDEN | SPCMD_SLNDEN | rspi->spcmd | SPCMD_SPNDEN;
+	rspi->spcmd |= SPCMD_SCKDEN | SPCMD_SLNDEN | SPCMD_SPNDEN;
 
 	/* Resets transfer data length */
 	rspi_write32(rspi, 0, QSPI_SPBMUL0);
@@ -314,9 +366,9 @@ static int qspi_set_config_register(const struct rspi_data *rspi,
 	rspi_write8(rspi, 0x00, QSPI_SPBFCR);
 
 	/* Sets SPCMD */
-	rspi_write16(rspi, spcmd, RSPI_SPCMD0);
+	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
 
-	/* Enables SPI function in a master mode */
+	/* Enables SPI function in master mode */
 	rspi_write8(rspi, SPCR_SPE | SPCR_MSTR, RSPI_SPCR);
 
 	return 0;
@@ -340,6 +392,9 @@ static int rspi_wait_for_interrupt(struct rspi_data *rspi, u8 wait_mask,
 	int ret;
 
 	rspi->spsr = rspi_read8(rspi, RSPI_SPSR);
+	if (rspi->spsr & wait_mask)
+		return 0;
+
 	rspi_enable_irq(rspi, enable_bit);
 	ret = wait_event_timeout(rspi->wait, rspi->spsr & wait_mask, HZ);
 	if (ret == 0 && !(rspi->spsr & wait_mask))
@@ -348,78 +403,39 @@ static int rspi_wait_for_interrupt(struct rspi_data *rspi, u8 wait_mask,
 	return 0;
 }
 
-static void rspi_assert_ssl(const struct rspi_data *rspi)
-{
-	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_SPE, RSPI_SPCR);
-}
-
-static void rspi_negate_ssl(const struct rspi_data *rspi)
+static int rspi_data_out(struct rspi_data *rspi, u8 data)
 {
-	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_SPE, RSPI_SPCR);
+	if (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {
+		dev_err(&rspi->master->dev, "transmit timeout\n");
+		return -ETIMEDOUT;
+	}
+	rspi_write_data(rspi, data);
+	return 0;
 }
 
-static int rspi_send_pio(struct rspi_data *rspi, struct spi_message *mesg,
-			 struct spi_transfer *t)
+static int rspi_data_in(struct rspi_data *rspi)
 {
-	int remain = t->len;
-	const u8 *data = t->tx_buf;
-	while (remain > 0) {
-		rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_TXMD,
-			    RSPI_SPCR);
-
-		if (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {
-			dev_err(&rspi->master->dev,
-				"%s: tx empty timeout\n", __func__);
-			return -ETIMEDOUT;
-		}
+	u8 data;
 
-		rspi_write16(rspi, *data, RSPI_SPDR);
-		data++;
-		remain--;
+	if (rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE) < 0) {
+		dev_err(&rspi->master->dev, "receive timeout\n");
+		return -ETIMEDOUT;
 	}
-
-	/* Waiting for the last transmission */
-	rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);
-
-	return 0;
+	data = rspi_read_data(rspi);
+	return data;
 }
 
-static int qspi_send_pio(struct rspi_data *rspi, struct spi_message *mesg,
-			 struct spi_transfer *t)
+static int rspi_data_out_in(struct rspi_data *rspi, u8 data)
 {
-	int remain = t->len;
-	const u8 *data = t->tx_buf;
-
-	rspi_write8(rspi, SPBFCR_TXRST, QSPI_SPBFCR);
-	rspi_write8(rspi, 0x00, QSPI_SPBFCR);
-
-	while (remain > 0) {
-
-		if (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {
-			dev_err(&rspi->master->dev,
-				"%s: tx empty timeout\n", __func__);
-			return -ETIMEDOUT;
-		}
-		rspi_write8(rspi, *data++, RSPI_SPDR);
-
-		if (rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE) < 0) {
-			dev_err(&rspi->master->dev,
-				"%s: receive timeout\n", __func__);
-			return -ETIMEDOUT;
-		}
-		rspi_read8(rspi, RSPI_SPDR);
-
-		remain--;
-	}
+	int ret;
 
-	/* Waiting for the last transmission */
-	rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);
+	ret = rspi_data_out(rspi, data);
+	if (ret < 0)
+		return ret;
 
-	return 0;
+	return rspi_data_in(rspi);
 }
 
-#define send_pio(spi, mesg, t) spi->ops->send_pio(spi, mesg, t)
-
 static void rspi_dma_complete(void *arg)
 {
 	struct rspi_data *rspi = arg;
@@ -471,7 +487,7 @@ static int rspi_send_dma(struct rspi_data *rspi, struct spi_transfer *t)
 	struct scatterlist sg;
 	const void *buf = NULL;
 	struct dma_async_tx_descriptor *desc;
-	unsigned len;
+	unsigned int len;
 	int ret = 0;
 
 	if (rspi->dma_width_16bit) {
@@ -509,7 +525,7 @@ static int rspi_send_dma(struct rspi_data *rspi, struct spi_transfer *t)
 	 * DMAC needs SPTIE, but if SPTIE is set, this IRQ routine will be
 	 * called. So, this driver disables the IRQ while DMA transfer.
 	 */
-	disable_irq(rspi->irq);
+	disable_irq(rspi->tx_irq);
 
 	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_TXMD, RSPI_SPCR);
 	rspi_enable_irq(rspi, SPCR_SPTIE);
@@ -528,7 +544,7 @@ static int rspi_send_dma(struct rspi_data *rspi, struct spi_transfer *t)
 		ret = -ETIMEDOUT;
 	rspi_disable_irq(rspi, SPCR_SPTIE);
 
-	enable_irq(rspi->irq);
+	enable_irq(rspi->tx_irq);
 
 end:
 	rspi_dma_unmap_sg(&sg, rspi->chan_tx, DMA_TO_DEVICE);
@@ -545,46 +561,17 @@ static void rspi_receive_init(const struct rspi_data *rspi)
 
 	spsr = rspi_read8(rspi, RSPI_SPSR);
 	if (spsr & SPSR_SPRF)
-		rspi_read16(rspi, RSPI_SPDR);	/* dummy read */
+		rspi_read_data(rspi);	/* dummy read */
 	if (spsr & SPSR_OVRF)
 		rspi_write8(rspi, rspi_read8(rspi, RSPI_SPSR) & ~SPSR_OVRF,
 			    RSPI_SPSR);
 }
 
-static int rspi_receive_pio(struct rspi_data *rspi, struct spi_message *mesg,
-			    struct spi_transfer *t)
+static void rspi_rz_receive_init(const struct rspi_data *rspi)
 {
-	int remain = t->len;
-	u8 *data;
-
 	rspi_receive_init(rspi);
-
-	data = t->rx_buf;
-	while (remain > 0) {
-		rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_TXMD,
-			    RSPI_SPCR);
-
-		if (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {
-			dev_err(&rspi->master->dev,
-				"%s: tx empty timeout\n", __func__);
-			return -ETIMEDOUT;
-		}
-		/* dummy write for generate clock */
-		rspi_write16(rspi, DUMMY_DATA, RSPI_SPDR);
-
-		if (rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE) < 0) {
-			dev_err(&rspi->master->dev,
-				"%s: receive timeout\n", __func__);
-			return -ETIMEDOUT;
-		}
-		/* SPDR allows 16 or 32-bit access only */
-		*data = (u8)rspi_read16(rspi, RSPI_SPDR);
-
-		data++;
-		remain--;
-	}
-
-	return 0;
+	rspi_write8(rspi, SPBFCR_TXRST | SPBFCR_RXRST, RSPI_SPBFCR);
+	rspi_write8(rspi, 0, RSPI_SPBFCR);
 }
 
 static void qspi_receive_init(const struct rspi_data *rspi)
@@ -593,51 +580,17 @@ static void qspi_receive_init(const struct rspi_data *rspi)
 
 	spsr = rspi_read8(rspi, RSPI_SPSR);
 	if (spsr & SPSR_SPRF)
-		rspi_read8(rspi, RSPI_SPDR);   /* dummy read */
+		rspi_read_data(rspi);   /* dummy read */
 	rspi_write8(rspi, SPBFCR_TXRST | SPBFCR_RXRST, QSPI_SPBFCR);
-	rspi_write8(rspi, 0x00, QSPI_SPBFCR);
+	rspi_write8(rspi, 0, QSPI_SPBFCR);
 }
 
-static int qspi_receive_pio(struct rspi_data *rspi, struct spi_message *mesg,
-			    struct spi_transfer *t)
-{
-	int remain = t->len;
-	u8 *data;
-
-	qspi_receive_init(rspi);
-
-	data = t->rx_buf;
-	while (remain > 0) {
-
-		if (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {
-			dev_err(&rspi->master->dev,
-				"%s: tx empty timeout\n", __func__);
-			return -ETIMEDOUT;
-		}
-		/* dummy write for generate clock */
-		rspi_write8(rspi, DUMMY_DATA, RSPI_SPDR);
-
-		if (rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE) < 0) {
-			dev_err(&rspi->master->dev,
-				"%s: receive timeout\n", __func__);
-			return -ETIMEDOUT;
-		}
-		/* SPDR allows 8, 16 or 32-bit access */
-		*data++ = rspi_read8(rspi, RSPI_SPDR);
-		remain--;
-	}
-
-	return 0;
-}
-
-#define receive_pio(spi, mesg, t) spi->ops->receive_pio(spi, mesg, t)
-
 static int rspi_receive_dma(struct rspi_data *rspi, struct spi_transfer *t)
 {
 	struct scatterlist sg, sg_dummy;
 	void *dummy = NULL, *rx_buf = NULL;
 	struct dma_async_tx_descriptor *desc, *desc_dummy;
-	unsigned len;
+	unsigned int len;
 	int ret = 0;
 
 	if (rspi->dma_width_16bit) {
@@ -695,7 +648,9 @@ static int rspi_receive_dma(struct rspi_data *rspi, struct spi_transfer *t)
 	 * DMAC needs SPTIE, but if SPTIE is set, this IRQ routine will be
 	 * called. So, this driver disables the IRQ while DMA transfer.
 	 */
-	disable_irq(rspi->irq);
+	disable_irq(rspi->tx_irq);
+	if (rspi->rx_irq != rspi->tx_irq)
+		disable_irq(rspi->rx_irq);
 
 	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_TXMD, RSPI_SPCR);
 	rspi_enable_irq(rspi, SPCR_SPTIE | SPCR_SPRIE);
@@ -718,7 +673,9 @@ static int rspi_receive_dma(struct rspi_data *rspi, struct spi_transfer *t)
 		ret = -ETIMEDOUT;
 	rspi_disable_irq(rspi, SPCR_SPTIE | SPCR_SPRIE);
 
-	enable_irq(rspi->irq);
+	enable_irq(rspi->tx_irq);
+	if (rspi->rx_irq != rspi->tx_irq)
+		enable_irq(rspi->rx_irq);
 
 end:
 	rspi_dma_unmap_sg(&sg, rspi->chan_rx, DMA_FROM_DEVICE);
@@ -746,56 +703,175 @@ static int rspi_is_dma(const struct rspi_data *rspi, struct spi_transfer *t)
 	return 0;
 }
 
-static void rspi_work(struct work_struct *work)
+static int rspi_transfer_out_in(struct rspi_data *rspi,
+				struct spi_transfer *xfer)
 {
-	struct rspi_data *rspi = container_of(work, struct rspi_data, ws);
-	struct spi_message *mesg;
-	struct spi_transfer *t;
-	unsigned long flags;
-	int ret;
+	int remain = xfer->len, ret;
+	const u8 *tx_buf = xfer->tx_buf;
+	u8 *rx_buf = xfer->rx_buf;
+	u8 spcr, data;
 
-	while (1) {
-		spin_lock_irqsave(&rspi->lock, flags);
-		if (list_empty(&rspi->queue)) {
-			spin_unlock_irqrestore(&rspi->lock, flags);
-			break;
-		}
-		mesg = list_entry(rspi->queue.next, struct spi_message, queue);
-		list_del_init(&mesg->queue);
-		spin_unlock_irqrestore(&rspi->lock, flags);
-
-		rspi_assert_ssl(rspi);
-
-		list_for_each_entry(t, &mesg->transfers, transfer_list) {
-			if (t->tx_buf) {
-				if (rspi_is_dma(rspi, t))
-					ret = rspi_send_dma(rspi, t);
-				else
-					ret = send_pio(rspi, mesg, t);
-				if (ret < 0)
-					goto error;
-			}
-			if (t->rx_buf) {
-				if (rspi_is_dma(rspi, t))
-					ret = rspi_receive_dma(rspi, t);
-				else
-					ret = receive_pio(rspi, mesg, t);
-				if (ret < 0)
-					goto error;
-			}
-			mesg->actual_length += t->len;
+	rspi_receive_init(rspi);
+
+	spcr = rspi_read8(rspi, RSPI_SPCR);
+	if (rx_buf)
+		spcr &= ~SPCR_TXMD;
+	else
+		spcr |= SPCR_TXMD;
+	rspi_write8(rspi, spcr, RSPI_SPCR);
+
+	while (remain > 0) {
+		data = tx_buf ? *tx_buf++ : DUMMY_DATA;
+		ret = rspi_data_out(rspi, data);
+		if (ret < 0)
+			return ret;
+		if (rx_buf) {
+			ret = rspi_data_in(rspi);
+			if (ret < 0)
+				return ret;
+			*rx_buf++ = ret;
 		}
-		rspi_negate_ssl(rspi);
+		remain--;
+	}
+
+	/* Wait for the last transmission */
+	rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);
+
+	return 0;
+}
+
+static int rspi_transfer_one(struct spi_master *master, struct spi_device *spi,
+			     struct spi_transfer *xfer)
+{
+	struct rspi_data *rspi = spi_master_get_devdata(master);
+	int ret;
+
+	if (!rspi_is_dma(rspi, xfer))
+		return rspi_transfer_out_in(rspi, xfer);
+
+	if (xfer->tx_buf) {
+		ret = rspi_send_dma(rspi, xfer);
+		if (ret < 0)
+			return ret;
+	}
+	if (xfer->rx_buf)
+		return rspi_receive_dma(rspi, xfer);
+
+	return 0;
+}
+
+static int rspi_rz_transfer_out_in(struct rspi_data *rspi,
+				   struct spi_transfer *xfer)
+{
+	int remain = xfer->len, ret;
+	const u8 *tx_buf = xfer->tx_buf;
+	u8 *rx_buf = xfer->rx_buf;
+	u8 data;
+
+	rspi_rz_receive_init(rspi);
+
+	while (remain > 0) {
+		data = tx_buf ? *tx_buf++ : DUMMY_DATA;
+		ret = rspi_data_out_in(rspi, data);
+		if (ret < 0)
+			return ret;
+		if (rx_buf)
+			*rx_buf++ = ret;
+		remain--;
+	}
+
+	/* Wait for the last transmission */
+	rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);
+
+	return 0;
+}
+
+static int rspi_rz_transfer_one(struct spi_master *master,
+				struct spi_device *spi,
+				struct spi_transfer *xfer)
+{
+	struct rspi_data *rspi = spi_master_get_devdata(master);
+
+	return rspi_rz_transfer_out_in(rspi, xfer);
+}
+
+static int qspi_transfer_out_in(struct rspi_data *rspi,
+				struct spi_transfer *xfer)
+{
+	int remain = xfer->len, ret;
+	const u8 *tx_buf = xfer->tx_buf;
+	u8 *rx_buf = xfer->rx_buf;
+	u8 data;
 
-		mesg->status = 0;
-		mesg->complete(mesg->context);
+	qspi_receive_init(rspi);
+
+	while (remain > 0) {
+		data = tx_buf ? *tx_buf++ : DUMMY_DATA;
+		ret = rspi_data_out_in(rspi, data);
+		if (ret < 0)
+			return ret;
+		if (rx_buf)
+			*rx_buf++ = ret;
+		remain--;
+	}
+
+	/* Wait for the last transmission */
+	rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);
+
+	return 0;
+}
+
+static int qspi_transfer_out(struct rspi_data *rspi, struct spi_transfer *xfer)
+{
+	const u8 *buf = xfer->tx_buf;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < xfer->len; i++) {
+		ret = rspi_data_out(rspi, *buf++);
+		if (ret < 0)
+			return ret;
 	}
 
-	return;
+	/* Wait for the last transmission */
+	rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);
 
-error:
-	mesg->status = ret;
-	mesg->complete(mesg->context);
+	return 0;
+}
+
+static int qspi_transfer_in(struct rspi_data *rspi, struct spi_transfer *xfer)
+{
+	u8 *buf = xfer->rx_buf;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < xfer->len; i++) {
+		ret = rspi_data_in(rspi);
+		if (ret < 0)
+			return ret;
+		*buf++ = ret;
+	}
+
+	return 0;
+}
+
+static int qspi_transfer_one(struct spi_master *master, struct spi_device *spi,
+			     struct spi_transfer *xfer)
+{
+	struct rspi_data *rspi = spi_master_get_devdata(master);
+
+	if (spi->mode & SPI_LOOP) {
+		return qspi_transfer_out_in(rspi, xfer);
+	} else if (xfer->tx_buf && xfer->tx_nbits > SPI_NBITS_SINGLE) {
+		/* Quad or Dual SPI Write */
+		return qspi_transfer_out(rspi, xfer);
+	} else if (xfer->rx_buf && xfer->rx_nbits > SPI_NBITS_SINGLE) {
+		/* Quad or Dual SPI Read */
+		return qspi_transfer_in(rspi, xfer);
+	} else {
+		/* Single SPI Transfer */
+		return qspi_transfer_out_in(rspi, xfer);
+	}
 }
 
 static int rspi_setup(struct spi_device *spi)
@@ -810,32 +886,115 @@ static int rspi_setup(struct spi_device *spi)
 	if (spi->mode & SPI_CPHA)
 		rspi->spcmd |= SPCMD_CPHA;
 
+	/* CMOS output mode and MOSI signal from previous transfer */
+	rspi->sppcr = 0;
+	if (spi->mode & SPI_LOOP)
+		rspi->sppcr |= SPPCR_SPLP;
+
 	set_config_register(rspi, 8);
 
 	return 0;
 }
 
-static int rspi_transfer(struct spi_device *spi, struct spi_message *mesg)
+static u16 qspi_transfer_mode(const struct spi_transfer *xfer)
 {
-	struct rspi_data *rspi = spi_master_get_devdata(spi->master);
-	unsigned long flags;
+	if (xfer->tx_buf)
+		switch (xfer->tx_nbits) {
+		case SPI_NBITS_QUAD:
+			return SPCMD_SPIMOD_QUAD;
+		case SPI_NBITS_DUAL:
+			return SPCMD_SPIMOD_DUAL;
+		default:
+			return 0;
+		}
+	if (xfer->rx_buf)
+		switch (xfer->rx_nbits) {
+		case SPI_NBITS_QUAD:
+			return SPCMD_SPIMOD_QUAD | SPCMD_SPRW;
+		case SPI_NBITS_DUAL:
+			return SPCMD_SPIMOD_DUAL | SPCMD_SPRW;
+		default:
+			return 0;
+		}
+
+	return 0;
+}
 
-	mesg->actual_length = 0;
-	mesg->status = -EINPROGRESS;
+static int qspi_setup_sequencer(struct rspi_data *rspi,
+				const struct spi_message *msg)
+{
+	const struct spi_transfer *xfer;
+	unsigned int i = 0, len = 0;
+	u16 current_mode = 0xffff, mode;
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		mode = qspi_transfer_mode(xfer);
+		if (mode == current_mode) {
+			len += xfer->len;
+			continue;
+		}
+
+		/* Transfer mode change */
+		if (i) {
+			/* Set transfer data length of previous transfer */
+			rspi_write32(rspi, len, QSPI_SPBMUL(i - 1));
+		}
 
-	spin_lock_irqsave(&rspi->lock, flags);
-	list_add_tail(&mesg->queue, &rspi->queue);
-	schedule_work(&rspi->ws);
-	spin_unlock_irqrestore(&rspi->lock, flags);
+		if (i >= QSPI_NUM_SPCMD) {
+			dev_err(&msg->spi->dev,
+				"Too many different transfer modes");
+			return -EINVAL;
+		}
+
+		/* Program transfer mode for this transfer */
+		rspi_write16(rspi, rspi->spcmd | mode, RSPI_SPCMD(i));
+		current_mode = mode;
+		len = xfer->len;
+		i++;
+	}
+	if (i) {
+		/* Set final transfer data length and sequence length */
+		rspi_write32(rspi, len, QSPI_SPBMUL(i - 1));
+		rspi_write8(rspi, i - 1, RSPI_SPSCR);
+	}
 
 	return 0;
 }
 
-static void rspi_cleanup(struct spi_device *spi)
+static int rspi_prepare_message(struct spi_master *master,
+				struct spi_message *msg)
 {
+	struct rspi_data *rspi = spi_master_get_devdata(master);
+	int ret;
+
+	if (msg->spi->mode &
+	    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)) {
+		/* Setup sequencer for messages with multiple transfer modes */
+		ret = qspi_setup_sequencer(rspi, msg);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Enable SPI function in master mode */
+	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_SPE, RSPI_SPCR);
+	return 0;
 }
 
-static irqreturn_t rspi_irq(int irq, void *_sr)
+static int rspi_unprepare_message(struct spi_master *master,
+				  struct spi_message *msg)
+{
+	struct rspi_data *rspi = spi_master_get_devdata(master);
+
+	/* Disable SPI function */
+	rspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_SPE, RSPI_SPCR);
+
+	/* Reset sequencer for Single SPI Transfers */
+	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
+	rspi_write8(rspi, 0, RSPI_SPSCR);
+	return 0;
+}
+
+static irqreturn_t rspi_irq_mux(int irq, void *_sr)
 {
 	struct rspi_data *rspi = _sr;
 	u8 spsr;
@@ -857,6 +1016,36 @@ static irqreturn_t rspi_irq(int irq, void *_sr)
 	return ret;
 }
 
+static irqreturn_t rspi_irq_rx(int irq, void *_sr)
+{
+	struct rspi_data *rspi = _sr;
+	u8 spsr;
+
+	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
+	if (spsr & SPSR_SPRF) {
+		rspi_disable_irq(rspi, SPCR_SPRIE);
+		wake_up(&rspi->wait);
+		return IRQ_HANDLED;
+	}
+
+	return 0;
+}
+
+static irqreturn_t rspi_irq_tx(int irq, void *_sr)
+{
+	struct rspi_data *rspi = _sr;
+	u8 spsr;
+
+	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
+	if (spsr & SPSR_SPTEF) {
+		rspi_disable_irq(rspi, SPCR_SPTIE);
+		wake_up(&rspi->wait);
+		return IRQ_HANDLED;
+	}
+
+	return 0;
+}
+
 static int rspi_request_dma(struct rspi_data *rspi,
 				      struct platform_device *pdev)
 {
@@ -923,34 +1112,89 @@ static int rspi_remove(struct platform_device *pdev)
 	struct rspi_data *rspi = platform_get_drvdata(pdev);
 
 	rspi_release_dma(rspi);
-	clk_disable(rspi->clk);
+	pm_runtime_disable(&pdev->dev);
 
 	return 0;
 }
 
+static const struct spi_ops rspi_ops = {
+	.set_config_register =		rspi_set_config_register,
+	.transfer_one =			rspi_transfer_one,
+	.mode_bits =			SPI_CPHA | SPI_CPOL | SPI_LOOP,
+};
+
+static const struct spi_ops rspi_rz_ops = {
+	.set_config_register =		rspi_rz_set_config_register,
+	.transfer_one =			rspi_rz_transfer_one,
+	.mode_bits =			SPI_CPHA | SPI_CPOL | SPI_LOOP,
+};
+
+static const struct spi_ops qspi_ops = {
+	.set_config_register =		qspi_set_config_register,
+	.transfer_one =			qspi_transfer_one,
+	.mode_bits =			SPI_CPHA | SPI_CPOL | SPI_LOOP |
+					SPI_TX_DUAL | SPI_TX_QUAD |
+					SPI_RX_DUAL | SPI_RX_QUAD,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id rspi_of_match[] = {
+	/* RSPI on legacy SH */
+	{ .compatible = "renesas,rspi", .data = &rspi_ops },
+	/* RSPI on RZ/A1H */
+	{ .compatible = "renesas,rspi-rz", .data = &rspi_rz_ops },
+	/* QSPI on R-Car Gen2 */
+	{ .compatible = "renesas,qspi", .data = &qspi_ops },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, rspi_of_match);
+
+static int rspi_parse_dt(struct device *dev, struct spi_master *master)
+{
+	u32 num_cs;
+	int error;
+
+	/* Parse DT properties */
+	error = of_property_read_u32(dev->of_node, "num-cs", &num_cs);
+	if (error) {
+		dev_err(dev, "of_property_read_u32 num-cs failed %d\n", error);
+		return error;
+	}
+
+	master->num_chipselect = num_cs;
+	return 0;
+}
+#else
+#define rspi_of_match	NULL
+static inline int rspi_parse_dt(struct device *dev, struct spi_master *master)
+{
+	return -EINVAL;
+}
+#endif /* CONFIG_OF */
+
+static int rspi_request_irq(struct device *dev, unsigned int irq,
+			    irq_handler_t handler, const char *suffix,
+			    void *dev_id)
+{
+	const char *base = dev_name(dev);
+	size_t len = strlen(base) + strlen(suffix) + 2;
+	char *name = devm_kzalloc(dev, len, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+	snprintf(name, len, "%s:%s", base, suffix);
+	return devm_request_irq(dev, irq, handler, 0, name, dev_id);
+}
+
 static int rspi_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct spi_master *master;
 	struct rspi_data *rspi;
-	int ret, irq;
-	char clk_name[16];
-	const struct rspi_plat_data *rspi_pd = dev_get_platdata(&pdev->dev);
+	int ret;
+	const struct of_device_id *of_id;
+	const struct rspi_plat_data *rspi_pd;
 	const struct spi_ops *ops;
-	const struct platform_device_id *id_entry = pdev->id_entry;
-
-	ops = (struct spi_ops *)id_entry->driver_data;
-	/* ops parameter check */
-	if (!ops->set_config_register) {
-		dev_err(&pdev->dev, "there is no set_config_register\n");
-		return -ENODEV;
-	}
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "platform_get_irq error\n");
-		return -ENODEV;
-	}
 
 	master = spi_alloc_master(&pdev->dev, sizeof(struct rspi_data));
 	if (master == NULL) {
@@ -958,6 +1202,28 @@ static int rspi_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
+	of_id = of_match_device(rspi_of_match, &pdev->dev);
+	if (of_id) {
+		ops = of_id->data;
+		ret = rspi_parse_dt(&pdev->dev, master);
+		if (ret)
+			goto error1;
+	} else {
+		ops = (struct spi_ops *)pdev->id_entry->driver_data;
+		rspi_pd = dev_get_platdata(&pdev->dev);
+		if (rspi_pd && rspi_pd->num_chipselect)
+			master->num_chipselect = rspi_pd->num_chipselect;
+		else
+			master->num_chipselect = 2; /* default */
+	};
+
+	/* ops parameter check */
+	if (!ops->set_config_register) {
+		dev_err(&pdev->dev, "there is no set_config_register\n");
+		ret = -ENODEV;
+		goto error1;
+	}
+
 	rspi = spi_master_get_devdata(master);
 	platform_set_drvdata(pdev, rspi);
 	rspi->ops = ops;
@@ -970,39 +1236,61 @@ static int rspi_probe(struct platform_device *pdev)
 		goto error1;
 	}
 
-	snprintf(clk_name, sizeof(clk_name), "%s%d", id_entry->name, pdev->id);
-	rspi->clk = devm_clk_get(&pdev->dev, clk_name);
+	rspi->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(rspi->clk)) {
 		dev_err(&pdev->dev, "cannot get clock\n");
 		ret = PTR_ERR(rspi->clk);
 		goto error1;
 	}
-	clk_enable(rspi->clk);
 
-	INIT_LIST_HEAD(&rspi->queue);
-	spin_lock_init(&rspi->lock);
-	INIT_WORK(&rspi->ws, rspi_work);
-	init_waitqueue_head(&rspi->wait);
+	pm_runtime_enable(&pdev->dev);
 
-	if (rspi_pd && rspi_pd->num_chipselect)
-		master->num_chipselect = rspi_pd->num_chipselect;
-	else
-		master->num_chipselect = 2; /* default */
+	init_waitqueue_head(&rspi->wait);
 
 	master->bus_num = pdev->id;
 	master->setup = rspi_setup;
-	master->transfer = rspi_transfer;
-	master->cleanup = rspi_cleanup;
-	master->mode_bits = SPI_CPHA | SPI_CPOL;
+	master->auto_runtime_pm = true;
+	master->transfer_one = ops->transfer_one;
+	master->prepare_message = rspi_prepare_message;
+	master->unprepare_message = rspi_unprepare_message;
+	master->mode_bits = ops->mode_bits;
+	master->dev.of_node = pdev->dev.of_node;
+
+	ret = platform_get_irq_byname(pdev, "rx");
+	if (ret < 0) {
+		ret = platform_get_irq_byname(pdev, "mux");
+		if (ret < 0)
+			ret = platform_get_irq(pdev, 0);
+		if (ret >= 0)
+			rspi->rx_irq = rspi->tx_irq = ret;
+	} else {
+		rspi->rx_irq = ret;
+		ret = platform_get_irq_byname(pdev, "tx");
+		if (ret >= 0)
+			rspi->tx_irq = ret;
+	}
+	if (ret < 0) {
+		dev_err(&pdev->dev, "platform_get_irq error\n");
+		goto error2;
+	}
 
-	ret = devm_request_irq(&pdev->dev, irq, rspi_irq, 0,
-			       dev_name(&pdev->dev), rspi);
+	if (rspi->rx_irq == rspi->tx_irq) {
+		/* Single multiplexed interrupt */
+		ret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_mux,
+				       "mux", rspi);
+	} else {
+		/* Multi-interrupt mode, only SPRI and SPTI are used */
+		ret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_rx,
+				       "rx", rspi);
+		if (!ret)
+			ret = rspi_request_irq(&pdev->dev, rspi->tx_irq,
+					       rspi_irq_tx, "tx", rspi);
+	}
 	if (ret < 0) {
 		dev_err(&pdev->dev, "request_irq error\n");
 		goto error2;
 	}
 
-	rspi->irq = irq;
 	ret = rspi_request_dma(rspi, pdev);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "rspi_request_dma failed.\n");
@@ -1022,27 +1310,16 @@ static int rspi_probe(struct platform_device *pdev)
 error3:
 	rspi_release_dma(rspi);
 error2:
-	clk_disable(rspi->clk);
+	pm_runtime_disable(&pdev->dev);
 error1:
 	spi_master_put(master);
 
 	return ret;
 }
 
-static struct spi_ops rspi_ops = {
-	.set_config_register =		rspi_set_config_register,
-	.send_pio =			rspi_send_pio,
-	.receive_pio =			rspi_receive_pio,
-};
-
-static struct spi_ops qspi_ops = {
-	.set_config_register =		qspi_set_config_register,
-	.send_pio =			qspi_send_pio,
-	.receive_pio =			qspi_receive_pio,
-};
-
 static struct platform_device_id spi_driver_ids[] = {
 	{ "rspi",	(kernel_ulong_t)&rspi_ops },
+	{ "rspi-rz",	(kernel_ulong_t)&rspi_rz_ops },
 	{ "qspi",	(kernel_ulong_t)&qspi_ops },
 	{},
 };
@@ -1056,6 +1333,7 @@ static struct platform_driver rspi_driver = {
 	.driver		= {
 		.name = "renesas_spi",
 		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(rspi_of_match),
 	},
 };
 module_platform_driver(rspi_driver);
diff --git a/drivers/spi/spi-sh-spibsc.c b/drivers/spi/spi-sh-spibsc.c
new file mode 100644
index 0000000..74a629a
--- /dev/null
+++ b/drivers/spi/spi-sh-spibsc.c
@@ -0,0 +1,1152 @@
+/*
+ * SuperH SPIBSC bus driver
+ *
+ * Copyright (C) 2011-2014 Renesas Solutions Corp.
+ *
+ * Based on spi-sh-hspi.c:
+ *
+ * Copyright (C) 2011  Kuninori Morimoto
+ *
+ * Based on spi-sh.c:
+ * Based on pxa2xx_spi.c:
+ * Copyright (C) 2005 Stephen Street / StreetFire Sound Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/sh_spibsc.h>
+
+/* SPIBSC registers */
+#define	CMNCR	0x00
+#define	SSLDR	0x04
+#define SPBCR	0x08
+#define DRCR	0x0c
+#define	SMCR	0x20
+#define	SMCMR	0x24
+#define	SMADR	0x28
+#define	SMOPR	0x2c
+#define	SMENR	0x30
+#define SMRDR0	0x38
+#define SMRDR1	0x3c
+#define	SMWDR0	0x40
+#define SMWDR1	0x44
+#define	CMNSR	0x48
+#define SMDMCR	0x60
+#define SMDRENR	0x64
+
+/* CMNCR */
+#define	CMNCR_MD	(1u << 31)
+#define	CMNCR_SFDE	(1u << 24)
+
+#define	CMNCR_MOIIO3(x)		(((u32)(x) & 0x3) << 22)
+#define	CMNCR_MOIIO2(x)		(((u32)(x) & 0x3) << 20)
+#define	CMNCR_MOIIO1(x)		(((u32)(x) & 0x3) << 18)
+#define	CMNCR_MOIIO0(x)		(((u32)(x) & 0x3) << 16)
+#define	CMNCR_IO3FV(x)		(((u32)(x) & 0x3) << 14)
+#define	CMNCR_IO2FV(x)		(((u32)(x) & 0x3) << 12)
+#define	CMNCR_IO0FV(x)		(((u32)(x) & 0x3) << 8)
+
+#define	CMNCR_CPHAT	(1u << 6)
+#define	CMNCR_CPHAR	(1u << 5)
+#define	CMNCR_SSLP	(1u << 4)
+#define	CMNCR_CPOL	(1u << 3)
+#define	CMNCR_BSZ(n)	(((u32)(n) & 0x3) << 0)
+
+#define	OUT_0		(0u)
+#define	OUT_1		(1u)
+#define	OUT_REV		(2u)
+#define	OUT_HIZ		(3u)
+
+#define	BSZ_SINGLE	(0)
+#define	BSZ_DUAL	(1)
+
+#define CMNCR_INIT	(CMNCR_MD | \
+			CMNCR_SFDE | \
+			CMNCR_MOIIO3(OUT_HIZ) | \
+			CMNCR_MOIIO2(OUT_HIZ) | \
+			CMNCR_MOIIO1(OUT_HIZ) | \
+			CMNCR_MOIIO0(OUT_HIZ) | \
+			CMNCR_IO3FV(OUT_HIZ) | \
+			CMNCR_IO2FV(OUT_HIZ) | \
+			CMNCR_IO0FV(OUT_HIZ) | \
+			CMNCR_CPHAR | \
+			CMNCR_BSZ(BSZ_SINGLE))
+
+/* SSLDR */
+#define	SSLDR_SPNDL(x)	(((u32)(x) & 0x7) << 16)
+#define	SSLDR_SLNDL(x)	(((u32)(x) & 0x7) << 8)
+#define	SSLDR_SCKDL(x)	(((u32)(x) & 0x7) << 0)
+
+#define	SPBCLK_1_0	(0)
+#define	SPBCLK_1_5	(0)
+#define	SPBCLK_2_0	(1)
+#define	SPBCLK_2_5	(1)
+#define	SPBCLK_3_0	(2)
+#define	SPBCLK_3_5	(2)
+#define	SPBCLK_4_0	(3)
+#define	SPBCLK_4_5	(3)
+#define	SPBCLK_5_0	(4)
+#define	SPBCLK_5_5	(4)
+#define	SPBCLK_6_0	(5)
+#define	SPBCLK_6_5	(5)
+#define	SPBCLK_7_0	(6)
+#define	SPBCLK_7_5	(6)
+#define	SPBCLK_8_0	(7)
+#define	SPBCLK_8_5	(7)
+
+#define	SSLDR_INIT	(SSLDR_SPNDL(SPBCLK_1_0) | \
+			SSLDR_SLNDL(SPBCLK_1_0) | \
+			SSLDR_SCKDL(SPBCLK_1_0))
+
+/* SPBCR */
+#define	SPBCR_SPBR(x)		(((u32)(x) & 0xff) << 8)
+#define	SPBCR_BRDV(x)		(((u32)(x) & 0x3) << 0)
+
+
+#define SPBCR_INIT	(SPBCR_SPBR(2) | SPBCR_BRDV(0))	/* Clock : 33MHz */
+
+/* DRCR (read mode) */
+#define	DRCR_SSLN		(1u << 24)
+#define	DRCR_RBURST(x)		(((u32)(x) & 0xf) << 16)
+#define	DRCR_RCF		(1u << 9)
+#define	DRCR_RBE		(1u << 8)
+#define	DRCR_SSLE		(1u << 0)
+
+/* DRCMR (read mode) */
+#define	DRCMR_CMD(c)		(((u32)(c) & 0xff) << 16)
+#define	DRCMR_OCMD(c)		(((u32)(c) & 0xff) << 0)
+
+/* DREAR (read mode) */
+#define	DREAR_EAV(v)		(((u32)(v) & 0xff) << 16)
+#define	DREAR_EAC(v)		(((u32)(v) & 0x7) << 0)
+
+/* DROPR (read mode) */
+#define	DROPR_OPD3(o)		(((u32)(o) & 0xff) << 24)
+#define	DROPR_OPD2(o)		(((u32)(o) & 0xff) << 16)
+#define	DROPR_OPD1(o)		(((u32)(o) & 0xff) << 8)
+#define	DROPR_OPD0(o)		(((u32)(o) & 0xff) << 0)
+
+/* DRENR (read mode) */
+#define	DRENR_CDB(b)		(((u32)(b) & 0x3) << 30)
+#define	DRENR_OCDB(b)		(((u32)(b) & 0x3) << 28)
+#define	DRENR_ADB(b)		(((u32)(b) & 0x3) << 24)
+#define	DRENR_OPDB(b)		(((u32)(b) & 0x3) << 20)
+#define	DRENR_DRDB(b)		(((u32)(b) & 0x3) << 16)
+#define	DRENR_DME		(1u << 15)
+#define	DRENR_CDE		(1u << 14)
+#define	DRENR_OCDE		(1u << 12)
+#define	DRENR_ADE(a)		(((u32)(a) & 0xf) << 8)
+#define	DRENR_OPDE(o)		(((u32)(o) & 0xf) << 4)
+
+/* SMCR (spi mode) */
+#define	SMCR_SSLKP		(1u << 8)
+#define	SMCR_SPIRE		(1u << 2)
+#define	SMCR_SPIWE		(1u << 1)
+#define	SMCR_SPIE		(1u << 0)
+
+/* SMCMR (spi mode) */
+#define	SMCMR_CMD(c)		(((u32)(c) & 0xff) << 16)
+#define	SMCMR_OCMD(o)		(((u32)(o) & 0xff) << 0)
+
+/* SMADR (spi mode) */
+
+/* SMOPR (spi mode) */
+#define	SMOPR_OPD3(o)		(((u32)(o) & 0xff) << 24)
+#define	SMOPR_OPD2(o)		(((u32)(o) & 0xff) << 16)
+#define	SMOPR_OPD1(o)		(((u32)(o) & 0xff) << 8)
+#define	SMOPR_OPD0(o)		(((u32)(o) & 0xff) << 0)
+
+/* SMENR (spi mode) */
+#define	SMENR_CDB(b)		(((u32)(b) & 0x3) << 30)
+#define	SMENR_OCDB(b)		(((u32)(b) & 0x3) << 28)
+#define	SMENR_ADB(b)		(((u32)(b) & 0x3) << 24)
+#define	SMENR_OPDB(b)		(((u32)(b) & 0x3) << 20)
+#define	SMENR_SPIDB(b)		(((u32)(b) & 0x3) << 16)
+#define	SMENR_DME		(1u << 15)
+#define	SMENR_CDE		(1u << 14)
+#define	SMENR_OCDE		(1u << 12)
+#define	SMENR_ADE(b)		(((u32)(b) & 0xf) << 8)
+#define	SMENR_OPDE(b)		(((u32)(b) & 0xf) << 4)
+#define	SMENR_SPIDE(b)		(((u32)(b) & 0xf) << 0)
+
+#define	ADE_23_16	(0x4)
+#define	ADE_23_8	(0x6)
+#define	ADE_23_0	(0x7)
+#define	ADE_31_0	(0xf)
+
+#define	BITW_1BIT	(0)
+#define	BITW_2BIT	(1)
+#define	BITW_4BIT	(2)
+
+#define	SPIDE_8BITS	(0x8)
+#define	SPIDE_16BITS	(0xc)
+#define	SPIDE_32BITS	(0xf)
+
+#define	OPDE_3		(0x8)
+#define	OPDE_3_2	(0xc)
+#define	OPDE_3_2_1	(0xe)
+#define	OPDE_3_2_1_0	(0xf)
+
+/* SMRDR0 (spi mode) */
+/* SMRDR1 (spi mode) */
+/* SMWDR0 (spi mode) */
+/* SMWDR1 (spi mode) */
+
+/* CMNSR (spi mode) */
+#define	CMNSR_SSLF	(1u << 1)
+#define	CMNSR_TEND	(1u << 0)
+
+/* DRDMCR (read mode) */
+#define	DRDMCR_DMDB(b)		(((u32)(b) & 0x3) << 16)
+#define	DRDMCR_DMCYC(b)		(((u32)(b) & 0x7) << 0)
+
+/* DRDRENR (read mode) */
+#define	DRDRENR_ADDRE	(1u << 8)
+#define	DRDRENR_OPDRE	(1u << 4)
+#define	DRDRENR_DRDRE	(1u << 0)
+
+/* SMDMCR (spi mode) */
+#define	SMDMCR_DMDB(b)		(((u32)(b) & 0x3) << 16)
+#define	SMDMCR_DMCYC(b)		(((u32)(b) & 0x7) << 0)
+
+/* SMDRENR (spi mode) */
+#define	SMDRENR_ADDRE	(1u << 8)
+#define	SMDRENR_OPDRE	(1u << 4)
+#define	SMDRENR_SPIDRE	(1u << 0)
+
+/*
+ *  FlashROM Chip Commands
+ */
+#define	CMD_READ_ID	(0x90)	/* Read Electronic Manufacturer Signature */
+#define	CMD_PP		(0x02)	/* Page Program (3-byte address) */
+#define	CMD_QPP		(0x32)	/* Quad Page Program (3-byte address) */
+#define	CMD_READ	(0x03)	/* Read (3-byte address) */
+#define	CMD_FAST_READ	(0x0b)	/* Fast Read (3-byte address) */
+#define	CMD_DOR		(0x3b)	/* Read Dual Out (3-byte address) */
+#define	CMD_QOR		(0x6b)	/* Read Quad Out (3-byte address) */
+#define	CMD_WREN	(0x06)	/* Write enable */
+#define CMD_RDSR	(0x05)	/* Read status */
+#define CMD_SE		(0xd8)	/* Sector erase */
+#define	CMD_RDID	(0x9f)	/* Read Identification */
+#define	CMD_WRR		(0x01)	/* Write SR1, CR1 register */
+#define	CMD_RDCR	(0x35)	/* Read configuration register */
+#define	CMD_BRWR	(0x17)	/* Bank register write*/
+#define	CMD_CLSR	(0x30)	/* clear E_ERR(SR1:bit5) and P_ERR(SR1:bit6) */
+#define	CMD_WRDI	(0x04)	/* set WEL(SR1:bit1)bit to 0 */
+#define	CMD_RESET	(0xF0)	/* Software Reset */
+#define CMD_MBR		(0xFF)	/* Mode Bit Reset */
+
+/* SR1 register bit */
+#define	SR1_SRWD	0x80	/* Status Register Write Disable */
+#define	SR1_P_ERR	0x40	/* Programming Error */
+#define	SR1_E_ERR	0x20	/* Erase Error */
+#define	SR1_BP_MASK	0x1c	/* Block Protection */
+#define	SR1_WEL		0x02	/* Write Enable Latch */
+#define	SR1_WIP		0x01	/* Write In Progress */
+/* CR1 register bit */
+#define	CR1_LC_MASK	0xc0	/* Latency Code */
+#define	CR1_BPNV	0x08	/* Block Protection Non-Volatile */
+#define	CR1_QUAD	0x02	/* Quad Data Width */
+#define	CR1_FREEZE	0x01	/* Freeze Protection */
+
+/* SPIBSC registers */
+#define	CMNCR	0x00
+#define	SSLDR	0x04
+#define SPBCR	0x08
+#define DRCR	0x0c
+#define	SMCR	0x20
+#define	SMCMR	0x24
+#define	SMADR	0x28
+#define	SMOPR	0x2c
+#define	SMENR	0x30
+#define SMRDR0	0x38
+#define SMRDR1	0x3c
+#define	SMWDR0	0x40
+#define SMWDR1	0x44
+#define	CMNSR	0x48
+#define SMDMCR	0x60
+#define SMDRENR	0x64
+
+struct spibsc_priv {
+	void __iomem *addr;
+	struct spi_master *master;
+	struct device *dev;
+	struct clk *clk;
+	struct sh_spibsc_info *info;
+	u8 bspw;	/* bits per word */
+	u32 max_speed;	/* max speed hz */
+	u32 bitw;	/* data_bitw */
+	u32 dcyle;	/* dmy_cycle */
+};
+
+#define BITW_1BIT	(0)
+#define BITW_2BIT	(1)
+#define BITW_4BIT	(2)
+
+#undef DEBUG
+#ifdef DEBUG
+#define	DEBUG_COMMAND()						\
+	do {							\
+		int i;						\
+		dev_err(sbsc->dev, "command:");			\
+		for (i = 0; i < len; i++)			\
+			dev_err(sbsc->dev, " %02X", command[i]);\
+		dev_err(sbsc->dev, "\n");			\
+	} while (0)
+#define	DEBUG_SEND()						\
+	do {							\
+		int i;						\
+		dev_err(sbsc->dev, "send data:");		\
+		for (i = 0; i < len; i++)			\
+			dev_err(sbsc->dev, " %02X", data[i]);	\
+			dev_err(sbsc->dev, "\n");		\
+	} while (0)
+#define DEBUG_RECEIVE()						\
+	do {							\
+		int i;						\
+		dev_err(sbsc->dev, "receive data:");		\
+		for (i = 0; i < len; i++)			\
+			dev_err(sbsc->dev, " %02X", data[i]);	\
+			dev_err(sbsc->dev, "\n");		\
+	} while (0)
+#else
+#define	DEBUG_COMMAND()	do {} while (0)
+#define	DEBUG_SEND()	do {} while (0)
+#define DEBUG_RECEIVE()	do {} while (0)
+#endif
+
+/* select value for SMENR.SPIDBbit(bit width) */
+/*     and SMDMCR.DMCYC(number of dummy cycle)*/
+static void spibsc_set_busio(struct spibsc_priv *sbsc, u8 cmd)
+{
+	u32 bitw, dcyle;
+
+	switch (cmd) {
+	case CMD_FAST_READ:	/* 0x0b Fast Read (3-byte address) */
+		dcyle = 8;
+		bitw = BITW_1BIT;
+		break;
+
+	case CMD_DOR:		/* 0x3b Read Dual Out (3-byte address) */
+		dcyle = 8;
+		bitw = BITW_2BIT;
+		break;
+
+	case CMD_QOR:		/* 0x6b Read Quad Out (3-byte address) */
+		dcyle = 8;
+		bitw = BITW_4BIT;
+		break;
+
+	case CMD_QPP:		/* 0x32 Quad Page Program (3-byte address) */
+		dcyle = 0;
+		bitw = BITW_4BIT;
+		break;
+
+	default:
+		dcyle = 0;
+		bitw = BITW_1BIT;
+		break;
+	}
+
+	sbsc->bitw	= bitw;
+	sbsc->dcyle	= dcyle;
+}
+
+static void spibsc_write(struct spibsc_priv *sbsc, int reg, u32 val)
+{
+	iowrite32(val, sbsc->addr + reg);
+}
+static void spibsc_write8(struct spibsc_priv *sbsc, int reg, u8 val)
+{
+	iowrite8(val, sbsc->addr + reg);
+}
+static void spibsc_write16(struct spibsc_priv *sbsc, int reg, u16 val)
+{
+	iowrite16(val, sbsc->addr + reg);
+}
+
+static u32 spibsc_read(struct spibsc_priv *sbsc, int reg)
+{
+	return ioread32(sbsc->addr + reg);
+}
+static u8 spibsc_read8(struct spibsc_priv *sbsc, int reg)
+{
+	return ioread8(sbsc->addr + reg);
+}
+static u16 spibsc_read16(struct spibsc_priv *sbsc, int reg)
+{
+	return ioread16(sbsc->addr + reg);
+}
+
+
+static int spibsc_wait_trans_completion(struct spibsc_priv *sbsc)
+{
+	int t = 256 * 100000;
+
+	while (t--) {
+		if (spibsc_read(sbsc, CMNSR) & CMNSR_TEND)
+			return 0;
+
+		ndelay(1);
+	}
+
+	dev_err(sbsc->dev, "timeout\n");
+	return -ETIMEDOUT;
+}
+
+static int spibsc_do_send_data(
+	struct spibsc_priv *sbsc,
+	const u8 *data,
+	int len);
+
+static int spibsc_do_send_cmd(
+	struct spibsc_priv *sbsc,
+	const u8 *command,
+	int clen)
+{
+	int ret;
+	u32 cmd, addr = 0, smopr = 0, smenr, smcr, smdmcr = 0;
+
+	cmd = SMCMR_CMD(command[0]);
+	smenr = SMENR_CDE | SMENR_CDB(BITW_1BIT);
+
+	switch (clen) {
+	case 1:
+		/* NOTHING TO DO... */
+		if (command[0] == CMD_WREN)
+			break;	/* WREN */
+		if (command[0] == CMD_WRDI)
+			break;	/* WRDI */
+		if (command[0] == CMD_CLSR)
+			break;	/* CLSR */
+		if (command[0] == CMD_RDSR)
+			break;	/* RDSR + read-data(1) */
+		if (command[0] == CMD_RDCR)
+			break;	/* RDCR + read-data(1) */
+		if (command[0] == CMD_RDID)
+			break;	/* RDID + read-data */
+		if (command[0] == CMD_RESET)
+			break;	/* Software Reset */
+		if (command[0] == CMD_MBR)
+			break;	/* Mode Bit Reset */
+		goto _show_me;
+		break;
+	case 2:
+		smopr |= SMOPR_OPD3(command[1]);
+		/* output optional command(op3) */
+		smenr |= SMENR_OPDE(OPDE_3) | SMENR_OPDB(BITW_1BIT);
+
+		if (command[0] == CMD_BRWR)
+			break;	/* BRWR + write-data(1) */
+		goto _show_me;
+		break;
+	case 3:
+		smopr |= SMOPR_OPD3(command[1]);
+		smopr |= SMOPR_OPD2(command[2]);
+		/* output optional command(op3,2) */
+		smenr |= SMENR_OPDE(OPDE_3_2) | SMENR_OPDB(BITW_1BIT);
+
+		if (command[0] == CMD_WRR)
+			break;	/* WRR + write-data(1or2) */
+		goto _show_me;
+		break;
+	case 4:		/* set 3byte address */
+		addr = (command[1] << 16) |
+			   (command[2] <<  8) |
+			    command[3];
+
+		smenr |= SMENR_ADE(ADE_23_0) | SMENR_ADB(BITW_1BIT);
+
+		/* set dummy param. */
+		if (sbsc->dcyle > 0) {
+			smenr |= SMENR_DME;
+			smdmcr = SMDMCR_DMDB(BITW_1BIT) |
+					 SMDMCR_DMCYC(sbsc->dcyle - 1);
+		}
+
+		if (command[0] == CMD_READ)
+			break;	/* READ      + ADDR24 */
+		if (command[0] == CMD_FAST_READ)
+			break;	/* FAST_READ + ADDR24 */
+		if (command[0] == CMD_DOR)
+			break;	/* DOR       + ADDR24 */
+		if (command[0] == CMD_QOR)
+			break;	/* QOR       + ADDR24 */
+		if (command[0] == CMD_PP)
+			break;	/* PP        + ADDR24 */
+		if (command[0] == CMD_QPP)
+			break;	/* QPP       + ADDR32 */
+		if (command[0] == CMD_SE)
+			break;	/* SE        + ADDR24 */
+		if (command[0] == CMD_READ_ID)
+			break;	/* READ_ID   + ADDR24 */
+		goto _show_me;
+		break;
+	case 6:
+		/* CMD_FAST_READ with 4 byte address comes here */
+		/* m25p80 adds 1 extra byte as dummy cycle... */
+
+		/* FALL INTO */
+	case 5:		/* set 4byte address */
+		addr =	(command[1] << 24) |
+				(command[2] << 16) |
+				(command[3] << 8)  |
+				 command[4];
+
+		smenr |= SMENR_ADE(ADE_31_0) | SMENR_ADB(BITW_1BIT);
+
+		/* set dummy param. */
+		if (sbsc->dcyle > 0) {
+			smenr |= SMENR_DME;
+			smdmcr = SMDMCR_DMDB(BITW_1BIT) |
+					 SMDMCR_DMCYC(sbsc->dcyle - 1);
+		}
+
+		if (command[0] == CMD_READ)
+			break;	/* READ      + ADDR32 */
+		if (command[0] == CMD_FAST_READ)
+			break;	/* FAST_READ + ADDR32 */
+		if (command[0] == CMD_DOR)
+			break;	/* DOR       + ADDR32 */
+		if (command[0] == CMD_QOR)
+			break;	/* QOR       + ADDR32 */
+		if (command[0] == CMD_PP)
+			break;	/* PP        + ADDR32 */
+		if (command[0] == CMD_QPP)
+			break;	/* QPP       + ADDR32 */
+		if (command[0] == CMD_SE)
+			break;	/* SE        + ADDR32 */
+		goto _show_me;
+		break;
+_show_me:
+	default:
+		pr_err("%s: ERROR bad clen(%d) or command(%02x)\n",
+							__func__, clen, cmd);
+		return -ENODATA;
+		break;
+	}
+
+	/* set params */
+	spibsc_write(sbsc, SMCMR, cmd);
+	spibsc_write(sbsc, SMADR, addr);
+	spibsc_write(sbsc, SMOPR, smopr);
+	spibsc_write(sbsc, SMENR, smenr);
+	spibsc_write(sbsc, SMDMCR, smdmcr);
+
+	/* start spi transfer*/
+	smcr = SMCR_SPIE;
+	switch (command[0]) {
+	case CMD_WREN:
+	case CMD_SE:
+	case CMD_WRR:
+	case CMD_BRWR:
+	case CMD_CLSR:
+	case CMD_WRDI:
+	case CMD_RESET:
+	case CMD_MBR:
+		break;
+	default:
+		/* Hold signal level (SPBSSL#(=CS#)) up to the next access */
+		smcr |= SMCR_SSLKP;
+		break;
+	}
+	spibsc_write(sbsc, SMCR, smcr);
+
+	/* wait for spi transfer completed */
+	ret = spibsc_wait_trans_completion(sbsc);
+	if (ret)
+		return ret;	/* return error */
+
+	if (command[0] == CMD_RESET)
+		udelay(40);
+
+	return 0;
+}
+
+static int spibsc_do_send_data(
+	struct spibsc_priv *sbsc,
+	const u8 *data,
+	int len)
+{
+	u32 smcr, smenr, smwdr0;
+	int ret, unit, sslkp = 1;
+
+	while (len > 0) {
+		if (len >= 4) {
+			unit = 4;
+			smenr = SMENR_SPIDE(SPIDE_32BITS) |
+					SMENR_SPIDB(sbsc->bitw);
+		} else {
+			unit = len;
+			if (unit == 3)
+				unit = 2;
+
+			if (unit >= 2)
+				smenr = SMENR_SPIDE(SPIDE_16BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+			else
+				smenr = SMENR_SPIDE(SPIDE_8BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+		}
+
+		/* set 4bytes data, bit stream */
+		smwdr0 = *data++;
+		if (unit >= 2)
+			smwdr0 |= (u32)(*data++ << 8);
+		if (unit >= 3)
+			smwdr0 |= (u32)(*data++ << 16);
+		if (unit >= 4)
+			smwdr0 |= (u32)(*data++ << 24);
+
+		/* mask unwrite area */
+		if (unit == 3)
+			smwdr0 |= 0xFF000000;
+		else if (unit == 2)
+			smwdr0 |= 0xFFFF0000;
+		else if (unit == 1)
+			smwdr0 |= 0xFFFFFF00;
+
+		/* write send data. */
+		if (unit == 2)
+			spibsc_write16(sbsc, SMWDR0, (u16)smwdr0);
+		else if (unit == 1)
+			spibsc_write8(sbsc, SMWDR0, (u8)smwdr0);
+		else
+		spibsc_write(sbsc, SMWDR0, smwdr0);
+
+		len -= unit;
+		if (len <= 0)
+			sslkp = 0;
+
+		/* set params */
+		spibsc_write(sbsc, SMCMR, 0);
+		spibsc_write(sbsc, SMADR, 0);
+		spibsc_write(sbsc, SMOPR, 0);
+		spibsc_write(sbsc, SMENR, smenr);
+
+		/* start spi transfer */
+		smcr = SMCR_SPIE|SMCR_SPIWE;
+		if (sslkp)
+			smcr |= SMCR_SSLKP;
+		spibsc_write(sbsc, SMCR, smcr);
+
+		/* wait for spi transfer completed */
+		ret = spibsc_wait_trans_completion(sbsc);
+		if (ret)
+			return  ret;	/* return error */
+	}
+	return 0;
+}
+
+static int spibsc_do_receive_data(struct spibsc_priv *sbsc, u8 *data, int len)
+{
+	u32 smcr, smenr, smrdr0;
+	int ret, unit, sslkp = 1;
+
+	while (len > 0) {
+		if (len >= 4) {
+			unit = 4;
+			smenr = SMENR_SPIDE(SPIDE_32BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+		} else {
+			unit = len;
+			if (unit == 3)
+				unit = 2;
+
+			if (unit >= 2)
+				smenr = SMENR_SPIDE(SPIDE_16BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+			else
+				smenr = SMENR_SPIDE(SPIDE_8BITS) |
+						SMENR_SPIDB(sbsc->bitw);
+		}
+
+		len -= unit;
+		if (len <= 0)
+			sslkp = 0;
+
+		/* set params */
+		spibsc_write(sbsc, SMCMR, 0);
+		spibsc_write(sbsc, SMADR, 0);
+		spibsc_write(sbsc, SMOPR, 0);
+		spibsc_write(sbsc, SMENR, smenr);
+
+		/* start spi transfer */
+		smcr = SMCR_SPIE|SMCR_SPIRE;
+		if (sbsc->bitw == BITW_1BIT)
+			smcr |= SMCR_SPIWE;
+		if (sslkp)
+			smcr |= SMCR_SSLKP;
+		spibsc_write(sbsc, SMCR, smcr);
+
+		/* wait for spi transfer completed */
+		ret = spibsc_wait_trans_completion(sbsc);
+		if (ret)
+			return ret;	/* return error */
+
+		/* read SMRDR */
+		if (unit == 2)
+			smrdr0 = (u32)spibsc_read16(sbsc, SMRDR0);
+		else if (unit == 1)
+			smrdr0 = (u32)spibsc_read8(sbsc, SMRDR0);
+		else
+		smrdr0 = spibsc_read(sbsc, SMRDR0);
+
+		*data++ = (u8)(smrdr0 & 0xff);
+		if (unit >= 2)
+			*data++ = (u8)((smrdr0 >> 8) & 0xff);
+		if (unit >= 3)
+			*data++ = (u8)((smrdr0 >> 16) & 0xff);
+		if (unit >= 4)
+			*data++ = (u8)((smrdr0 >> 24) & 0xff);
+	}
+	return 0;
+}
+
+static int spibsc_send_cmd(struct spibsc_priv *sbsc, struct spi_transfer *t)
+{
+	const u8 *command;
+	int len, ret;
+
+	/* wait for spi transfer completed */
+	ret = spibsc_wait_trans_completion(sbsc);
+	if (ret)
+		return	ret;	/* return error */
+
+	command = t->tx_buf;
+	len = t->len;
+
+	DEBUG_COMMAND();
+
+	{
+#define CMD_LENGTH (10)
+		u8 cmd[CMD_LENGTH];
+		int loop;
+
+		if (len > CMD_LENGTH) {
+			pr_err("%s: command length error\n", __func__);
+			return -EIO;
+		}
+
+		cmd[0] = (u8)command[0];
+		switch (command[0]) {
+		case CMD_FAST_READ:
+			/* cmd[0] = CMD_DOR; */	/* change Dual Mode */
+			cmd[0] = CMD_QOR;	/* change Quad Mode */
+			break;
+		#if 0	/* comment out because not tested */
+		case CMD_PP:
+			cmd[0] = CMD_QPP;	/* change Quad Mode */
+			break;	/* nothing to do */
+		#endif
+		case CMD_READ:
+		default:
+			break;	/* nothing to do */
+		}
+		/* command copy */
+		for (loop = 1; loop < len; loop++)
+			cmd[loop] = (u8)command[loop];
+
+		spibsc_set_busio(sbsc, cmd[0]);
+		return spibsc_do_send_cmd(sbsc, cmd, len);
+
+	}
+
+}
+
+static int spibsc_send_data(struct spibsc_priv *sbsc, struct spi_transfer *t)
+{
+	const u8 *data;
+	int len, ret;
+
+	/* wait for spi transfer completed */
+	ret = spibsc_wait_trans_completion(sbsc);
+	if (ret)
+		return	ret;	/* return error */
+
+	data = t->tx_buf;
+	len = t->len;
+
+	DEBUG_SEND();
+
+	return spibsc_do_send_data(sbsc, data, len);
+}
+
+static int spibsc_receive_data(struct spibsc_priv *sbsc, struct spi_transfer *t)
+{
+	u8 *data;
+	int len, ret;
+
+	/* wait for spi transfer completed */
+	ret = spibsc_wait_trans_completion(sbsc);
+	if (ret)
+		return	ret;	/* return error */
+
+	data = t->rx_buf;
+	len = t->len;
+
+	ret = spibsc_do_receive_data(sbsc, data, len);
+
+	DEBUG_RECEIVE();
+
+	return ret;
+}
+
+static void spibsc_hw_cs_disable(struct spibsc_priv *sbsc)
+{
+	u8 cmd = CMD_RDSR, data;
+
+	/* send Read status command to negate SSL line */
+	spibsc_do_send_cmd(sbsc, &cmd, 1);
+	spibsc_do_receive_data(sbsc, &data, 1);
+}
+
+/*
+ *		spi master function
+ */
+static int spibsc_prepare_transfer(struct spi_master *master)
+{
+	struct spibsc_priv *sbsc = spi_master_get_devdata(master);
+
+	pm_runtime_get_sync(sbsc->dev);
+	return 0;
+}
+
+static int spibsc_unprepare_transfer(struct spi_master *master)
+{
+	struct spibsc_priv *spibsc = spi_master_get_devdata(master);
+
+	pm_runtime_put_sync(spibsc->dev);
+	return 0;
+}
+
+static int spibsc_transfer_one_message(struct spi_master *master,
+				     struct spi_message *msg)
+{
+	struct spibsc_priv *sbsc = spi_master_get_devdata(master);
+	struct spi_transfer *t;
+	int ret;
+	unsigned int cs_change;
+
+	dev_dbg(sbsc->dev, "%s\n", __func__);
+
+	/* start transfer each of struct spi_transfer */
+	cs_change = 1;
+	ret = 0;
+	list_for_each_entry(t, &msg->transfers, transfer_list) {
+		/* send command or send data or recevie data */
+		if (cs_change) {
+			ret = spibsc_send_cmd(sbsc, t);	/* send command */
+			if (ret)
+				break;
+
+		} else {
+			if (t->tx_buf) {	/* send data */
+				ret = spibsc_send_data(sbsc, t);
+				if (ret)
+					break;
+			} else if (t->rx_buf) { /* receive data */
+				ret = spibsc_receive_data(sbsc, t);
+				if (ret)
+					break;
+			}
+		}
+		cs_change = t->cs_change;
+		msg->actual_length += t->len;
+	}
+
+	if (!cs_change)
+		spibsc_hw_cs_disable(sbsc);
+
+	msg->status = ret;
+	spi_finalize_current_message(master);
+
+	return ret;
+}
+
+static int spibsc_send_then_receive(
+	struct spibsc_priv *sbsc,
+	const u8 *command,
+	int clen,
+	u8 *data,
+	int len)
+{
+	int ret;
+
+	do {
+		ret = spibsc_wait_trans_completion(sbsc);
+		if (ret)
+			break;
+
+		spibsc_set_busio(sbsc, command[0]);
+
+		ret = spibsc_do_send_cmd(sbsc, command, clen);
+		if (ret)
+			break;
+
+		if (len > 0) {
+			ret = spibsc_do_receive_data(sbsc, data, len);
+			if (ret)
+				break;
+		}
+		return 0;
+	} while (0);
+
+	dev_err(sbsc->dev, "error %d for command %02x\n", ret, command[0]);
+	return ret;	/* return error */
+}
+
+static int wait_for_device_ready(struct spibsc_priv *sbsc)
+{
+	u8 cmd[1], sr1;
+	int timeout;
+#define	TIMEOUT		50000
+	int err;
+
+	timeout = 0;
+	do {
+		cmd[0] = CMD_RDSR;
+		err = spibsc_send_then_receive(sbsc, cmd, 1, &sr1, 1);
+		if (err < 0) {
+			dev_err(sbsc->dev, "error %d reading SR\n", err);
+				return -EIO;
+		}
+		if (sr1 & (SR1_P_ERR | SR1_E_ERR)) {	/* Error Occurred */
+			/* clear P_ERR/E_ERR(SR1:bit6/5) */
+			cmd[0] = CMD_CLSR;
+			(void) spibsc_send_then_receive(sbsc, cmd, 1, NULL, 0);
+			continue;
+		}
+		if (sr1 & SR1_WIP) {	/* device busy */
+			udelay(10);
+			continue;
+		}
+		if (sr1 & SR1_WEL) {	/* Device accepts Write Registers */
+			cmd[0] = CMD_WRDI;	/* clear WEL(SR1:bit1)*/
+			(void) spibsc_send_then_receive(sbsc, cmd, 1, NULL, 0);
+			continue;
+		}
+		/* Only SRWD and BP0-BP2 bits are valid here */
+		/* P_ERR, E_ERR, WEL and WIP bits are cleared here */
+		break;
+	} while (timeout++ < TIMEOUT);
+
+	if (timeout >= TIMEOUT)
+		pr_err("%s: timedout (last sr1=%02x)\n", __func__, sr1);
+
+	return 0;
+}
+
+static int set_quad_mode(struct spibsc_priv *sbsc)
+{
+	u8 cmd[3];
+	u8 sr1, cr1;
+
+	wait_for_device_ready(sbsc);		/* RZLSP */
+
+	cmd[0] = CMD_MBR;					/* Mode Bit Reset */
+	(void) spibsc_send_then_receive(sbsc, cmd, 1, NULL, 0);
+	cmd[0] = CMD_RESET;					/* Software Reset */
+	(void) spibsc_send_then_receive(sbsc, cmd, 1, NULL, 0);
+	cmd[0] = CMD_RDSR;
+	(void) spibsc_send_then_receive(sbsc, cmd, 1, &sr1, 1);
+	cmd[0] = CMD_RDCR;
+	(void) spibsc_send_then_receive(sbsc, cmd, 1, &cr1, 1);
+
+	if ((cr1 & (CR1_QUAD | CR1_BPNV)) != CR1_QUAD) {
+
+		/* operation for CR1:BPNV(OTP bit)=1  */
+
+		cmd[0] = CMD_WREN;	/* set WEL bit(SR1:bit1) to 1 */
+		(void) spibsc_send_then_receive(sbsc, cmd, 1, NULL, 0);
+
+		cmd[0] = CMD_RDSR;
+		(void) spibsc_send_then_receive(sbsc, cmd, 1, &sr1, 1);
+
+		if (!(sr1 & SR1_WEL))
+			pr_err("%s: Can't set SR1.WEL=1\n", __func__);
+
+		/* to no protection */
+		cmd[0] = CMD_WRR;
+		cmd[1] = sr1  & ~(SR1_SRWD | SR1_BP_MASK);
+		cmd[2] = (cr1 & ~(CR1_LC_MASK | CR1_FREEZE)) | CR1_QUAD;
+		(void) spibsc_send_then_receive(sbsc, cmd, 3, NULL, 0);
+
+		wait_for_device_ready(sbsc);
+	}
+
+	cmd[0] = CMD_RDSR;
+	(void) spibsc_send_then_receive(sbsc, cmd, 1, &sr1, 1);
+	cmd[0] = CMD_RDCR;
+	(void) spibsc_send_then_receive(sbsc, cmd, 1, &cr1, 1);
+
+	/* otp bit check */
+	if (cr1 & 0x28)
+		pr_err("Info : OTP bit = 1 (CR1 = 0x%02x, SR1 = 0x%02x)\n", cr1, sr1);
+
+	/* Quad mode check */
+	if ((cr1 & CR1_QUAD) != CR1_QUAD) {
+		pr_err("%s: Can't set CR1.QUAD=1\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int spibsc_setup(struct spi_device *spi)
+{
+	struct spibsc_priv *sbsc = spi_master_get_devdata(spi->master);
+	struct device *dev = sbsc->dev;
+
+	if (8 != spi->bits_per_word) {
+		dev_err(dev, "bits_per_word should be 8\n");
+		return -EIO;
+	}
+
+	/* initilaize spibsc */
+	spibsc_write(sbsc, CMNCR, CMNCR_INIT);
+	spibsc_write(sbsc, DRCR, DRCR_RCF);
+	spibsc_write(sbsc, SSLDR, SSLDR_INIT);
+	spibsc_write(sbsc, SPBCR, SPBCR_INIT);
+
+	dev_dbg(dev, "%s setup\n", spi->modalias);
+
+	if (0 != set_quad_mode(sbsc)) {
+		pr_err("%s: set_quad_mode error\n", __func__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void spibsc_cleanup(struct spi_device *spi)
+{
+	struct spibsc_priv *sbsc = spi_master_get_devdata(spi->master);
+	struct device *dev = sbsc->dev;
+
+	dev_dbg(dev, "%s cleanup\n", spi->modalias);
+}
+
+static int spibsc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct spi_master *master;
+	struct spibsc_priv *sbsc;
+	struct clk *clk;
+	int ret;
+	char clk_name[16];
+
+	/* get base addr */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "invalid resource\n");
+		return -EINVAL;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*sbsc));
+	if (!master) {
+		dev_err(&pdev->dev, "spi_alloc_master error.\n");
+		return -ENOMEM;
+	}
+
+	snprintf(clk_name, sizeof(clk_name), "spibsc%d", pdev->id);
+	clk = clk_get(&pdev->dev, clk_name);
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "cannot get spibsc clock\n");
+		ret = -EINVAL;
+		goto error0;
+	}
+	clk_enable(clk);
+
+	sbsc = spi_master_get_devdata(master);
+	dev_set_drvdata(&pdev->dev, sbsc);
+	sbsc->info = pdev->dev.platform_data;
+
+	/* init sbsc */
+	sbsc->master	= master;
+	sbsc->dev	= &pdev->dev;
+	sbsc->clk	= clk;
+	sbsc->addr	= devm_ioremap(sbsc->dev,
+				       res->start, resource_size(res));
+	if (!sbsc->addr) {
+		dev_err(&pdev->dev, "ioremap error.\n");
+		ret = -ENOMEM;
+		goto error1;
+	}
+
+	master->num_chipselect	= 1;
+	master->bus_num		= sbsc->info->bus_num;
+	master->setup		= spibsc_setup;
+	master->cleanup		= spibsc_cleanup;
+	master->mode_bits	= SPI_CPOL | SPI_CPHA;
+	master->prepare_transfer_hardware	= spibsc_prepare_transfer;
+	master->transfer_one_message		= spibsc_transfer_one_message;
+	master->unprepare_transfer_hardware	= spibsc_unprepare_transfer;
+	ret = spi_register_master(master);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "spi_register_master error.\n");
+		goto error1;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	dev_info(&pdev->dev, "probed\n");
+
+	return 0;
+
+ error1:
+	clk_put(clk);
+ error0:
+	spi_master_put(master);
+
+	return ret;
+}
+
+static int spibsc_remove(struct platform_device *pdev)
+{
+	struct spibsc_priv *sbsc = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	clk_put(sbsc->clk);
+	spi_unregister_master(sbsc->master);
+
+	return 0;
+}
+
+static struct platform_driver spibsc_driver = {
+	.probe = spibsc_probe,
+	.remove = spibsc_remove,
+	.driver = {
+		.name = "spibsc",
+		.owner = THIS_MODULE,
+	},
+};
+module_platform_driver(spibsc_driver);
+
+MODULE_DESCRIPTION("SuperH SPIBSC bus driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("RSO");
+MODULE_ALIAS("platform:sh_spi");
diff --git a/drivers/usb/gadget/r8a66597-udc.c b/drivers/usb/gadget/r8a66597-udc.c
index aff0a67..35ca045 100644
--- a/drivers/usb/gadget/r8a66597-udc.c
+++ b/drivers/usb/gadget/r8a66597-udc.c
@@ -1,7 +1,7 @@
 /*
  * R8A66597 UDC (USB gadget)
  *
- * Copyright (C) 2006-2009 Renesas Solutions Corp.
+ * Copyright (C) 2006-2014 Renesas Solutions Corp.
  *
  * Author : Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
  *
@@ -300,9 +300,10 @@ static inline void pipe_change(struct r8a66597 *r8a66597, u16 pipenum)
 {
 	struct r8a66597_ep *ep = r8a66597->pipenum2ep[pipenum];
 
+#ifndef CONFIG_ARCH_R7S72100
 	if (ep->use_dma)
 		r8a66597_bclr(r8a66597, DREQE, ep->fifosel);
-
+#endif
 	r8a66597_mdfy(r8a66597, pipenum, CURPIPE, ep->fifosel);
 
 	ndelay(450);
@@ -312,8 +313,10 @@ static inline void pipe_change(struct r8a66597 *r8a66597, u16 pipenum)
 	else
 		r8a66597_bset(r8a66597, mbw_value(r8a66597), ep->fifosel);
 
+#ifndef CONFIG_ARCH_R7S72100
 	if (ep->use_dma)
 		r8a66597_bset(r8a66597, DREQE, ep->fifosel);
+#endif
 }
 
 static int pipe_buffer_setting(struct r8a66597 *r8a66597,
@@ -675,7 +678,9 @@ static void sudmac_free_channel(struct r8a66597 *r8a66597,
 
 	usb_gadget_unmap_request(&r8a66597->gadget, &req->req, ep->dma->dir);
 
+#ifndef CONFIG_ARCH_R7S72100
 	r8a66597_bclr(r8a66597, DREQE, ep->fifosel);
+#endif
 	r8a66597_change_curpipe(r8a66597, 0, 0, ep->fifosel);
 
 	ep->dma->used = 0;
@@ -802,10 +807,11 @@ static void start_ep0(struct r8a66597_ep *ep, struct r8a66597_request *req)
 
 static void init_controller(struct r8a66597 *r8a66597)
 {
-	u16 vif = r8a66597->pdata->vif ? LDRV : 0;
 	u16 irq_sense = r8a66597->irq_sense_low ? INTL : 0;
+#ifndef CONFIG_ARCH_R7S72100
+	u16 vif = r8a66597->pdata->vif ? LDRV : 0;
 	u16 endian = r8a66597->pdata->endian ? BIGEND : 0;
-
+#endif
 	if (r8a66597->pdata->on_chip) {
 		if (r8a66597->pdata->buswait)
 			r8a66597_write(r8a66597, r8a66597->pdata->buswait,
@@ -818,13 +824,19 @@ static void init_controller(struct r8a66597 *r8a66597)
 		r8a66597_bclr(r8a66597, DPRPU, SYSCFG0);
 		r8a66597_bset(r8a66597, USBE, SYSCFG0);
 
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_bset(r8a66597, SCKE, SYSCFG0);
+#endif
 
 		r8a66597_bset(r8a66597, irq_sense, INTENB1);
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR,
 				DMA0CFG);
+#endif
 	} else {
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_bset(r8a66597, vif | endian, PINCFG);
+#endif
 		r8a66597_bset(r8a66597, HSE, SYSCFG0);		/* High spd */
 		r8a66597_mdfy(r8a66597, get_xtal_from_pdata(r8a66597->pdata),
 				XTAL, SYSCFG0);
@@ -833,26 +845,43 @@ static void init_controller(struct r8a66597 *r8a66597)
 		r8a66597_bclr(r8a66597, DPRPU, SYSCFG0);
 		r8a66597_bset(r8a66597, USBE, SYSCFG0);
 
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_bset(r8a66597, XCKE, SYSCFG0);
+#endif
+		usleep_range(3000, 3500);
 
-		msleep(3);
-
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_bset(r8a66597, PLLC, SYSCFG0);
 
-		msleep(1);
+		usleep_range(1000, 1500);
 
 		r8a66597_bset(r8a66597, SCKE, SYSCFG0);
 
+#endif
 		r8a66597_bset(r8a66597, irq_sense, INTENB1);
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR,
 			       DMA0CFG);
+#endif
 	}
+#ifdef CONFIG_ARCH_R7S72100
+	msleep(20);
+	r8a66597_bset(r8a66597, UPLLE, SYSCFG0);
+	msleep(20);
+	r8a66597_bset(r8a66597, SUSPM, SUSPMODE0);
+#endif
 }
 
 static void disable_controller(struct r8a66597 *r8a66597)
 {
+#ifdef CONFIG_ARCH_R7S72100
+	r8a66597_bclr(r8a66597, SUSPM, SUSPMODE0);
+	r8a66597_bclr(r8a66597, UPLLE, SYSCFG0);
+#endif
 	if (r8a66597->pdata->on_chip) {
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_bset(r8a66597, SCKE, SYSCFG0);
+#endif
 		r8a66597_bclr(r8a66597, UTST, TESTMODE);
 
 		/* disable interrupts */
@@ -868,21 +897,26 @@ static void disable_controller(struct r8a66597 *r8a66597)
 		r8a66597_write(r8a66597, 0, BEMPSTS);
 
 		r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_bclr(r8a66597, SCKE, SYSCFG0);
+#endif
 
 	} else {
 		r8a66597_bclr(r8a66597, UTST, TESTMODE);
+#ifndef CONFIG_ARCH_R7S72100
 		r8a66597_bclr(r8a66597, SCKE, SYSCFG0);
 		udelay(1);
 		r8a66597_bclr(r8a66597, PLLC, SYSCFG0);
 		udelay(1);
 		udelay(1);
 		r8a66597_bclr(r8a66597, XCKE, SYSCFG0);
+#endif
 	}
 }
 
 static void r8a66597_start_xclock(struct r8a66597 *r8a66597)
 {
+#ifndef CONFIG_ARCH_R7S72100
 	u16 tmp;
 
 	if (!r8a66597->pdata->on_chip) {
@@ -890,6 +924,7 @@ static void r8a66597_start_xclock(struct r8a66597 *r8a66597)
 		if (!(tmp & XCKE))
 			r8a66597_bset(r8a66597, XCKE, SYSCFG0);
 	}
+#endif
 }
 
 static struct r8a66597_request *get_request_from_ep(struct r8a66597_ep *ep)
diff --git a/drivers/usb/gadget/r8a66597-udc.h b/drivers/usb/gadget/r8a66597-udc.h
index 45c4b2d..7bc0290 100644
--- a/drivers/usb/gadget/r8a66597-udc.h
+++ b/drivers/usb/gadget/r8a66597-udc.h
@@ -1,7 +1,7 @@
 /*
  * R8A66597 UDC
  *
- * Copyright (C) 2007-2009 Renesas Solutions Corp.
+ * Copyright (C) 2007-2014 Renesas Solutions Corp.
  *
  * Author : Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
  *
@@ -243,14 +243,16 @@ static inline u16 get_xtal_from_pdata(struct r8a66597_platdata *pdata)
 	case R8A66597_PLATDATA_XTAL_12MHZ:
 		clock = XTAL12;
 		break;
+#ifndef CONFIG_ARCH_R7S72100
 	case R8A66597_PLATDATA_XTAL_24MHZ:
 		clock = XTAL24;
 		break;
+#endif
 	case R8A66597_PLATDATA_XTAL_48MHZ:
 		clock = XTAL48;
 		break;
 	default:
-		printk(KERN_ERR "r8a66597: platdata clock is wrong.\n");
+		pr_err("r8a66597:  platdata clock is wrong.\n");
 		break;
 	}
 
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 110b4b9..5dc72fe 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1,7 +1,7 @@
 /*
  * R8A66597 HCD (Host Controller Driver)
  *
- * Copyright (C) 2006-2007 Renesas Solutions Corp.
+ * Copyright (C) 2006-2013 Renesas Solutions Corp.
  * Portions Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
  * Portions Copyright (C) 2004-2005 David Brownell
  * Portions Copyright (C) 1999 Roman Weissgaerber
@@ -88,6 +88,7 @@ static void set_devadd_reg(struct r8a66597 *r8a66597, u8 r8a66597_address,
 	r8a66597_write(r8a66597, val, devadd_reg);
 }
 
+#ifndef CONFIG_ARCH_R7S72100
 static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
 {
 	u16 tmp;
@@ -145,6 +146,46 @@ static void r8a66597_clock_disable(struct r8a66597 *r8a66597)
 		r8a66597_bclr(r8a66597, USBE, SYSCFG0);
 	}
 }
+#else
+static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
+{
+	u16 tmp;
+	int i = 0;
+
+	if (r8a66597->pdata->on_chip)
+		clk_enable(r8a66597->clk);
+
+	do {
+		r8a66597_write(r8a66597, USBE, SYSCFG0);
+		tmp = r8a66597_read(r8a66597, SYSCFG0);
+		if (i++ > 1000) {
+			printk(KERN_ERR "r8a66597: reg access fail.\n");
+			return -ENXIO;
+		}
+	} while ((tmp & USBE) != USBE);
+	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+
+	if (XTAL48 == get_xtal_from_pdata(r8a66597->pdata))
+		r8a66597_bclr(r8a66597, XTAL, SYSCFG0);
+	else
+		r8a66597_bset(r8a66597, XTAL, SYSCFG0);
+	msleep(20);
+	r8a66597_bset(r8a66597, UPLLE, SYSCFG0);
+	msleep(20);
+	r8a66597_bset(r8a66597, SUSPM, SUSPMODE0);
+	return 0;
+}
+static void r8a66597_clock_disable(struct r8a66597 *r8a66597)
+{
+	r8a66597_bclr(r8a66597, SUSPM, SUSPMODE0);
+	r8a66597_bclr(r8a66597, UPLLE, SYSCFG0);
+	msleep(20);
+	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+	msleep(20);
+	if (r8a66597->pdata->on_chip)
+		clk_disable(r8a66597->clk);
+}
+#endif /* CONFIG_ARCH_R7S72100 */
 
 static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
 {
@@ -154,7 +195,9 @@ static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
 	r8a66597_bset(r8a66597, val, get_syscfg_reg(port));
 	r8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));
 
+#ifndef CONFIG_ARCH_R7S72100
 	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, get_dmacfg_reg(port));
+#endif
 	r8a66597_bclr(r8a66597, DTCHE, get_intenb_reg(port));
 	r8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));
 }
@@ -181,7 +224,9 @@ static void r8a66597_disable_port(struct r8a66597 *r8a66597, int port)
 static int enable_controller(struct r8a66597 *r8a66597)
 {
 	int ret, port;
+#ifndef CONFIG_ARCH_R7S72100
 	u16 vif = r8a66597->pdata->vif ? LDRV : 0;
+#endif
 	u16 irq_sense = r8a66597->irq_sense_low ? INTL : 0;
 	u16 endian = r8a66597->pdata->endian ? BIGEND : 0;
 
@@ -189,7 +234,9 @@ static int enable_controller(struct r8a66597 *r8a66597)
 	if (ret < 0)
 		return ret;
 
+#ifndef CONFIG_ARCH_R7S72100
 	r8a66597_bset(r8a66597, vif & LDRV, PINCFG);
+#endif
 	r8a66597_bset(r8a66597, USBE, SYSCFG0);
 
 	r8a66597_bset(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);
diff --git a/drivers/usb/host/r8a66597.h b/drivers/usb/host/r8a66597.h
index 672cea3..3a1320a 100644
--- a/drivers/usb/host/r8a66597.h
+++ b/drivers/usb/host/r8a66597.h
@@ -1,7 +1,7 @@
 /*
  * R8A66597 HCD (Host Controller Driver)
  *
- * Copyright (C) 2006-2007 Renesas Solutions Corp.
+ * Copyright (C) 2006-2013 Renesas Solutions Corp.
  * Portions Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
  * Portions Copyright (C) 2004-2005 David Brownell
  * Portions Copyright (C) 1999 Roman Weissgaerber
@@ -309,9 +309,11 @@ static inline u16 get_xtal_from_pdata(struct r8a66597_platdata *pdata)
 	case R8A66597_PLATDATA_XTAL_12MHZ:
 		clock = XTAL12;
 		break;
+#ifndef CONFIG_ARCH_R7S72100
 	case R8A66597_PLATDATA_XTAL_24MHZ:
 		clock = XTAL24;
 		break;
+#endif
 	case R8A66597_PLATDATA_XTAL_48MHZ:
 		clock = XTAL48;
 		break;
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index dade5b7..5728a89 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2485,6 +2485,7 @@ config FB_SIMPLE
 	  Configuration re: surface address, size, and format must be provided
 	  through device tree, or plain old platform data.
 
+source "drivers/video/renesas/Kconfig"
 source "drivers/video/omap/Kconfig"
 source "drivers/video/omap2/Kconfig"
 source "drivers/video/exynos/Kconfig"
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index ae17ddf..03ef91f 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -140,6 +140,7 @@ obj-$(CONFIG_SH_MIPI_DSI)	  += sh_mipi_dsi.o
 obj-$(CONFIG_FB_SH_MOBILE_HDMI)	  += sh_mobile_hdmi.o
 obj-$(CONFIG_FB_SH_MOBILE_MERAM)  += sh_mobile_meram.o
 obj-$(CONFIG_FB_SH_MOBILE_LCDC)	  += sh_mobile_lcdcfb.o
+obj-$(CONFIG_FB_VDC5)             += renesas/
 obj-$(CONFIG_FB_OMAP)             += omap/
 obj-y                             += omap2/
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
diff --git a/drivers/video/renesas/Kconfig b/drivers/video/renesas/Kconfig
new file mode 100644
index 0000000..a598f34
--- /dev/null
+++ b/drivers/video/renesas/Kconfig
@@ -0,0 +1,10 @@
+config FB_VDC5
+	tristate "RZ/A1H frame-buffer driver for VDC5 (EXPERIMENTAL)"
+	depends on FB
+	depends on ARCH_R7S72100
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	help
+	  Frame-buffer device for the Renesas RZ/A1H based boards.
diff --git a/drivers/video/renesas/Makefile b/drivers/video/renesas/Makefile
new file mode 100644
index 0000000..f636dad
--- /dev/null
+++ b/drivers/video/renesas/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the Renesas VDC5 framebuffer device driver
+#
+
+obj-$(CONFIG_FB_VDC5) += vdc5fb.o
+
diff --git a/drivers/video/renesas/vdc5fb-regs.h b/drivers/video/renesas/vdc5fb-regs.h
new file mode 100644
index 0000000..4692d0c
--- /dev/null
+++ b/drivers/video/renesas/vdc5fb-regs.h
@@ -0,0 +1,1123 @@
+/*
+ * Copyright (C) 2013-2014 Renesas Solutions Corp.
+ *
+ * Based on drivers/video/ren_vdc4.c
+ * Copyright (c) 2012 Renesas Electronics Europe Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _VDC5FB_REGS_H_
+#define _VDC5FB_REGS_H_
+
+/* REGISTER INDEX */
+enum {
+	/* INPUT CONTROLLER */
+	INP_UPDATE,
+	INP_SEL_CNT,
+	INP_EXT_SYNC_CNT,
+	INP_VSYNC_PH_ADJ,
+	INP_DLY_ADJ,
+
+	/* IMAGE QUALITY ADJUSTMENT BLOCK */
+	IMGCNT_UPDATE,
+	IMGCNT_NR_CNT0,
+	IMGCNT_NR_CNT1,
+	IMGCNT_MTX_MODE,
+	IMGCNT_MTX_YG_ADJ0,
+	IMGCNT_MTX_YG_ADJ1,
+	IMGCNT_MTX_CBB_ADJ0,
+	IMGCNT_MTX_CBB_ADJ1,
+	IMGCNT_MTX_CRR_ADJ0,
+	IMGCNT_MTX_CRR_ADJ1,
+	IMGCNT_DRC_REG,
+
+	/* SCALER 0 */
+	SC0_SCL0_UPDATE,
+	SC0_SCL0_FRC1,
+	SC0_SCL0_FRC2,
+	SC0_SCL0_FRC3,
+	SC0_SCL0_FRC4,
+	SC0_SCL0_FRC5,
+	SC0_SCL0_FRC6,
+	SC0_SCL0_FRC7,
+	SC0_SCL0_FRC9,
+	SC0_SCL0_MON0,
+	SC0_SCL0_INT,
+	SC0_SCL0_DS1,
+	SC0_SCL0_DS2,
+	SC0_SCL0_DS3,
+	SC0_SCL0_DS4,
+	SC0_SCL0_DS5,
+	SC0_SCL0_DS6,
+	SC0_SCL0_DS7,
+	SC0_SCL0_US1,
+	SC0_SCL0_US2,
+	SC0_SCL0_US3,
+	SC0_SCL0_US4,
+	SC0_SCL0_US5,
+	SC0_SCL0_US6,
+	SC0_SCL0_US7,
+	SC0_SCL0_US8,
+	SC0_SCL0_OVR1,
+	SC0_SCL1_UPDATE,
+	SC0_SCL1_WR1,
+	SC0_SCL1_WR2,
+	SC0_SCL1_WR3,
+	SC0_SCL1_WR4,
+	SC0_SCL1_WR5,
+	SC0_SCL1_WR6,
+	SC0_SCL1_WR7,
+	SC0_SCL1_WR8,
+	SC0_SCL1_WR9,
+	SC0_SCL1_WR10,
+	SC0_SCL1_WR11,
+	SC0_SCL1_MON1,
+	SC0_SCL1_PBUF0,
+	SC0_SCL1_PBUF1,
+	SC0_SCL1_PBUF2,
+	SC0_SCL1_PBUF3,
+	SC0_SCL1_PBUF_FLD,
+	SC0_SCL1_PBUF_CNT,
+
+	/* GRAPHICS 0 */
+	GR0_UPDATE,
+	GR0_FLM_RD,
+	GR0_FLM1,
+	GR0_FLM2,
+	GR0_FLM3,
+	GR0_FLM4,
+	GR0_FLM5,
+	GR0_FLM6,
+	GR0_AB1,
+	GR0_AB2,
+	GR0_AB3,
+	GR0_AB7,
+	GR0_AB8,
+	GR0_AB9,
+	GR0_AB10,
+	GR0_AB11,
+	GR0_BASE,
+	GR0_CLUT,
+	GR0_MON,
+
+	/* SCALER 1 */
+	SC1_SCL0_UPDATE,
+	SC1_SCL0_FRC1,
+	SC1_SCL0_FRC2,
+	SC1_SCL0_FRC3,
+	SC1_SCL0_FRC4,
+	SC1_SCL0_FRC5,
+	SC1_SCL0_FRC6,
+	SC1_SCL0_FRC7,
+	SC1_SCL0_FRC9,
+	SC1_SCL0_MON0,
+	SC1_SCL0_INT,
+	SC1_SCL0_DS1,
+	SC1_SCL0_DS2,
+	SC1_SCL0_DS3,
+	SC1_SCL0_DS4,
+	SC1_SCL0_DS5,
+	SC1_SCL0_DS6,
+	SC1_SCL0_DS7,
+	SC1_SCL0_US1,
+	SC1_SCL0_US2,
+	SC1_SCL0_US3,
+	SC1_SCL0_US4,
+	SC1_SCL0_US5,
+	SC1_SCL0_US6,
+	SC1_SCL0_US7,
+	SC1_SCL0_US8,
+	SC1_SCL0_OVR1,
+	SC1_SCL1_UPDATE,
+	SC1_SCL1_WR1,
+	SC1_SCL1_WR2,
+	SC1_SCL1_WR3,
+	SC1_SCL1_WR4,
+	SC1_SCL1_WR5,
+	SC1_SCL1_WR6,
+	SC1_SCL1_WR7,
+	SC1_SCL1_WR8,
+	SC1_SCL1_WR9,
+	SC1_SCL1_WR10,
+	SC1_SCL1_WR11,
+	SC1_SCL1_MON1,
+	SC1_SCL1_PBUF0,
+	SC1_SCL1_PBUF1,
+	SC1_SCL1_PBUF2,
+	SC1_SCL1_PBUF3,
+	SC1_SCL1_PBUF_FLD,
+	SC1_SCL1_PBUF_CNT,
+
+	/* GRAPHICS 1 */
+	GR1_UPDATE,
+	GR1_FLM_RD,
+	GR1_FLM1,
+	GR1_FLM2,
+	GR1_FLM3,
+	GR1_FLM4,
+	GR1_FLM5,
+	GR1_FLM6,
+	GR1_AB1,
+	GR1_AB2,
+	GR1_AB3,
+	GR1_AB4,
+	GR1_AB5,
+	GR1_AB6,
+	GR1_AB7,
+	GR1_AB8,
+	GR1_AB9,
+	GR1_AB10,
+	GR1_AB11,
+	GR1_BASE,
+	GR1_CLUT,
+	GR1_MON,
+
+	/* IMAGE QUALITY IMPROVER 0 */
+	ADJ0_UPDATE,
+	ADJ0_BKSTR_SET,
+	ADJ0_ENH_TIM1,
+	ADJ0_ENH_TIM2,
+	ADJ0_ENH_TIM3,
+	ADJ0_ENH_SHP1,
+	ADJ0_ENH_SHP2,
+	ADJ0_ENH_SHP3,
+	ADJ0_ENH_SHP4,
+	ADJ0_ENH_SHP5,
+	ADJ0_ENH_SHP6,
+	ADJ0_ENH_LTI1,
+	ADJ0_ENH_LTI2,
+	ADJ0_MTX_MODE,
+	ADJ0_MTX_YG_ADJ0,
+	ADJ0_MTX_YG_ADJ1,
+	ADJ0_MTX_CBB_ADJ0,
+	ADJ0_MTX_CBB_ADJ1,
+	ADJ0_MTX_CRR_ADJ0,
+	ADJ0_MTX_CRR_ADJ1,
+
+	/* IMAGE QUALITY IMPROVER 1 */
+	ADJ1_UPDATE,
+	ADJ1_BKSTR_SET,
+	ADJ1_ENH_TIM1,
+	ADJ1_ENH_TIM2,
+	ADJ1_ENH_TIM3,
+	ADJ1_ENH_SHP1,
+	ADJ1_ENH_SHP2,
+	ADJ1_ENH_SHP3,
+	ADJ1_ENH_SHP4,
+	ADJ1_ENH_SHP5,
+	ADJ1_ENH_SHP6,
+	ADJ1_ENH_LTI1,
+	ADJ1_ENH_LTI2,
+	ADJ1_MTX_MODE,
+	ADJ1_MTX_YG_ADJ0,
+	ADJ1_MTX_YG_ADJ1,
+	ADJ1_MTX_CBB_ADJ0,
+	ADJ1_MTX_CBB_ADJ1,
+	ADJ1_MTX_CRR_ADJ0,
+	ADJ1_MTX_CRR_ADJ1,
+
+	/* GRAPHICS 2 */
+	GR2_UPDATE,
+	GR2_FLM_RD,
+	GR2_FLM1,
+	GR2_FLM2,
+	GR2_FLM3,
+	GR2_FLM4,
+	GR2_FLM5,
+	GR2_FLM6,
+	GR2_AB1,
+	GR2_AB2,
+	GR2_AB3,
+	GR2_AB4,
+	GR2_AB5,
+	GR2_AB6,
+	GR2_AB7,
+	GR2_AB8,
+	GR2_AB9,
+	GR2_AB10,
+	GR2_AB11,
+	GR2_BASE,
+	GR2_CLUT,
+	GR2_MON,
+
+	/* GRAPHICS 3 */
+	GR3_UPDATE,
+	GR3_FLM_RD,
+	GR3_FLM1,
+	GR3_FLM2,
+	GR3_FLM3,
+	GR3_FLM4,
+	GR3_FLM5,
+	GR3_FLM6,
+	GR3_AB1,
+	GR3_AB2,
+	GR3_AB3,
+	GR3_AB4,
+	GR3_AB5,
+	GR3_AB6,
+	GR3_AB7,
+	GR3_AB8,
+	GR3_AB9,
+	GR3_AB10,
+	GR3_AB11,
+	GR3_BASE,
+	GR3_CLUT_INT,
+	GR3_MON,
+
+	/* VIN SYNTHESIZER */
+	GR_VIN_UPDATE,
+	GR_VIN_AB1,
+	GR_VIN_AB2,
+	GR_VIN_AB3,
+	GR_VIN_AB4,
+	GR_VIN_AB5,
+	GR_VIN_AB6,
+	GR_VIN_AB7,
+	GR_VIN_BASE,
+	GR_VIN_MON,
+
+	/* OUTPUT IMAGE GENERATOR */
+	OIR_SCL0_UPDATE,
+	OIR_SCL0_FRC1,
+	OIR_SCL0_FRC2,
+	OIR_SCL0_FRC3,
+	OIR_SCL0_FRC4,
+	OIR_SCL0_FRC5,
+	OIR_SCL0_FRC6,
+	OIR_SCL0_FRC7,
+	OIR_SCL0_DS1,
+	OIR_SCL0_DS2,
+	OIR_SCL0_DS3,
+	OIR_SCL0_DS7,
+	OIR_SCL0_US1,
+	OIR_SCL0_US2,
+	OIR_SCL0_US3,
+	OIR_SCL0_US8,
+	OIR_SCL0_OVR1,
+	OIR_SCL1_UPDATE,
+	OIR_SCL1_WR1,
+	OIR_SCL1_WR2,
+	OIR_SCL1_WR3,
+	OIR_SCL1_WR4,
+	OIR_SCL1_WR5,
+	OIR_SCL1_WR6,
+	OIR_SCL1_WR7,
+
+	/* GRAPHICS OIR */
+	GR_OIR_UPDATE,
+	GR_OIR_FLM_RD,
+	GR_OIR_FLM1,
+	GR_OIR_FLM2,
+	GR_OIR_FLM3,
+	GR_OIR_FLM4,
+	GR_OIR_FLM5,
+	GR_OIR_FLM6,
+	GR_OIR_AB1,
+	GR_OIR_AB2,
+	GR_OIR_AB3,
+	GR_OIR_AB7,
+	GR_OIR_AB8,
+	GR_OIR_AB9,
+	GR_OIR_AB10,
+	GR_OIR_AB11,
+	GR_OIR_BASE,
+	GR_OIR_CLUT,
+	GR_OIR_MON,
+
+	/* GAMMA CORRECTION BLOCK */
+	GAM_G_UPDATE,
+	GAM_SW,
+	GAM_G_LUT1,
+	GAM_G_LUT2,
+	GAM_G_LUT3,
+	GAM_G_LUT4,
+	GAM_G_LUT5,
+	GAM_G_LUT6,
+	GAM_G_LUT7,
+	GAM_G_LUT8,
+	GAM_G_LUT9,
+	GAM_G_LUT10,
+	GAM_G_LUT11,
+	GAM_G_LUT12,
+	GAM_G_LUT13,
+	GAM_G_LUT14,
+	GAM_G_LUT15,
+	GAM_G_LUT16,
+	GAM_G_AREA1,
+	GAM_G_AREA2,
+	GAM_G_AREA3,
+	GAM_G_AREA4,
+	GAM_G_AREA5,
+	GAM_G_AREA6,
+	GAM_G_AREA7,
+	GAM_G_AREA8,
+	GAM_B_UPDATE,
+	GAM_B_LUT1,
+	GAM_B_LUT2,
+	GAM_B_LUT3,
+	GAM_B_LUT4,
+	GAM_B_LUT5,
+	GAM_B_LUT6,
+	GAM_B_LUT7,
+	GAM_B_LUT8,
+	GAM_B_LUT9,
+	GAM_B_LUT10,
+	GAM_B_LUT11,
+	GAM_B_LUT12,
+	GAM_B_LUT13,
+	GAM_B_LUT14,
+	GAM_B_LUT15,
+	GAM_B_LUT16,
+	GAM_B_AREA1,
+	GAM_B_AREA2,
+	GAM_B_AREA3,
+	GAM_B_AREA4,
+	GAM_B_AREA5,
+	GAM_B_AREA6,
+	GAM_B_AREA7,
+	GAM_B_AREA8,
+	GAM_R_UPDATE,
+	GAM_R_LUT1,
+	GAM_R_LUT2,
+	GAM_R_LUT3,
+	GAM_R_LUT4,
+	GAM_R_LUT5,
+	GAM_R_LUT6,
+	GAM_R_LUT7,
+	GAM_R_LUT8,
+	GAM_R_LUT9,
+	GAM_R_LUT10,
+	GAM_R_LUT11,
+	GAM_R_LUT12,
+	GAM_R_LUT13,
+	GAM_R_LUT14,
+	GAM_R_LUT15,
+	GAM_R_LUT16,
+	GAM_R_AREA1,
+	GAM_R_AREA2,
+	GAM_R_AREA3,
+	GAM_R_AREA4,
+	GAM_R_AREA5,
+	GAM_R_AREA6,
+	GAM_R_AREA7,
+	GAM_R_AREA8,
+
+	/* TCON BLOCK */
+	TCON_UPDATE,
+	TCON_TIM,
+	TCON_TIM_STVA1,
+	TCON_TIM_STVA2,
+	TCON_TIM_STVB1,
+	TCON_TIM_STVB2,
+	TCON_TIM_STH1,
+	TCON_TIM_STH2,
+	TCON_TIM_STB1,
+	TCON_TIM_STB2,
+	TCON_TIM_CPV1,
+	TCON_TIM_CPV2,
+	TCON_TIM_POLA1,
+	TCON_TIM_POLA2,
+	TCON_TIM_POLB1,
+	TCON_TIM_POLB2,
+	TCON_TIM_DE,
+
+	/* OUTPUT CONTROLLER */
+	OUT_UPDATE,
+	OUT_SET,
+	OUT_BRIGHT1,
+	OUT_BRIGHT2,
+	OUT_CONTRAST,
+	OUT_PDTHA,
+	OUT_CLK_PHASE,
+
+	/* SYSTEM CONTROLLER */
+	SYSCNT_INT1,
+	SYSCNT_INT2,
+	SYSCNT_INT3,
+	SYSCNT_INT4,
+	SYSCNT_INT5,
+	SYSCNT_INT6,
+	SYSCNT_PANEL_CLK,
+	SYSCNT_CLUT,
+
+	VDC5FB_MAX_REGS,
+};
+
+/* IRQ INDEX */
+enum {
+	S0_VI_VSYNC = 0,
+	S0_LO_VSYNC,
+	S0_VSYNCERR,
+	GR3_VLINE,
+	S0_VFIELD,
+	IV1_VBUFERR,
+	IV3_VBUFERR,
+	IV5_VBUFERR,
+	IV6_VBUFERR,
+	S0_WLINE,
+	S1_VI_VSYNC,
+	S1_LO_VSYNC,
+	S1_VSYNCERR,
+	S1_VFIELD,
+	IV2_VBUFERR,
+	IV4_VBUFERR,
+	S1_WLINE,
+	OIR_VI_VSYNC,
+	OIR_LO_VSYNC,
+	OIR_VLINE,
+	OIR_VFIELD,
+	IV7_VBUFERR,
+	IV8_VBUFERR,
+	VDC5FB_MAX_IRQS,
+};
+
+/* REGISTER ADDRESS OFFSET */
+#define	VDC5FB_OFFSET(x)	((x) - VDC5FB_REG_BASE(0))
+static unsigned long vdc5fb_offsets[VDC5FB_MAX_REGS] = {
+	/* INPUT CONTROLLER */
+	[INP_UPDATE]		= VDC5FB_OFFSET(0xFCFF7400),
+	[INP_SEL_CNT]		= VDC5FB_OFFSET(0xFCFF7404),
+	[INP_EXT_SYNC_CNT]	= VDC5FB_OFFSET(0xFCFF7408),
+	[INP_VSYNC_PH_ADJ]	= VDC5FB_OFFSET(0xFCFF740C),
+	[INP_DLY_ADJ]		= VDC5FB_OFFSET(0xFCFF7410),
+
+	/* IMAGE QUALITY ADJUSTMENT BLOCK */
+	[IMGCNT_UPDATE]		= VDC5FB_OFFSET(0xFCFF7480),
+	[IMGCNT_NR_CNT0]	= VDC5FB_OFFSET(0xFCFF7484),
+	[IMGCNT_NR_CNT1]	= VDC5FB_OFFSET(0xFCFF7488),
+	[IMGCNT_MTX_MODE]	= VDC5FB_OFFSET(0xFCFF74A0),
+	[IMGCNT_MTX_YG_ADJ0]	= VDC5FB_OFFSET(0xFCFF74A4),
+	[IMGCNT_MTX_YG_ADJ1]	= VDC5FB_OFFSET(0xFCFF74A8),
+	[IMGCNT_MTX_CBB_ADJ0]	= VDC5FB_OFFSET(0xFCFF74AC),
+	[IMGCNT_MTX_CBB_ADJ1]	= VDC5FB_OFFSET(0xFCFF74B0),
+	[IMGCNT_MTX_CRR_ADJ0]	= VDC5FB_OFFSET(0xFCFF74B4),
+	[IMGCNT_MTX_CRR_ADJ1]	= VDC5FB_OFFSET(0xFCFF74B8),
+	[IMGCNT_DRC_REG]	= VDC5FB_OFFSET(0xFCFF74C0),
+
+	/* SCALER 0 */
+	[SC0_SCL0_UPDATE]	= VDC5FB_OFFSET(0xFCFF7500),
+	[SC0_SCL0_FRC1]		= VDC5FB_OFFSET(0xFCFF7504),
+	[SC0_SCL0_FRC2]		= VDC5FB_OFFSET(0xFCFF7508),
+	[SC0_SCL0_FRC3]		= VDC5FB_OFFSET(0xFCFF750C),
+	[SC0_SCL0_FRC4]		= VDC5FB_OFFSET(0xFCFF7510),
+	[SC0_SCL0_FRC5]		= VDC5FB_OFFSET(0xFCFF7514),
+	[SC0_SCL0_FRC6]		= VDC5FB_OFFSET(0xFCFF7518),
+	[SC0_SCL0_FRC7]		= VDC5FB_OFFSET(0xFCFF751C),
+	[SC0_SCL0_FRC9]		= VDC5FB_OFFSET(0xFCFF7524),
+	[SC0_SCL0_MON0]		= VDC5FB_OFFSET(0xFCFF7528),	/* 16bit */
+	[SC0_SCL0_INT]		= VDC5FB_OFFSET(0xFCFF752A),	/* 16bit */
+	[SC0_SCL0_DS1]		= VDC5FB_OFFSET(0xFCFF752C),
+	[SC0_SCL0_DS2]		= VDC5FB_OFFSET(0xFCFF7530),
+	[SC0_SCL0_DS3]		= VDC5FB_OFFSET(0xFCFF7534),
+	[SC0_SCL0_DS4]		= VDC5FB_OFFSET(0xFCFF7538),
+	[SC0_SCL0_DS5]		= VDC5FB_OFFSET(0xFCFF753C),
+	[SC0_SCL0_DS6]		= VDC5FB_OFFSET(0xFCFF7540),
+	[SC0_SCL0_DS7]		= VDC5FB_OFFSET(0xFCFF7544),
+	[SC0_SCL0_US1]		= VDC5FB_OFFSET(0xFCFF7548),
+	[SC0_SCL0_US2]		= VDC5FB_OFFSET(0xFCFF754C),
+	[SC0_SCL0_US3]		= VDC5FB_OFFSET(0xFCFF7550),
+	[SC0_SCL0_US4]		= VDC5FB_OFFSET(0xFCFF7554),
+	[SC0_SCL0_US5]		= VDC5FB_OFFSET(0xFCFF7558),
+	[SC0_SCL0_US6]		= VDC5FB_OFFSET(0xFCFF755C),
+	[SC0_SCL0_US7]		= VDC5FB_OFFSET(0xFCFF7560),
+	[SC0_SCL0_US8]		= VDC5FB_OFFSET(0xFCFF7564),
+	[SC0_SCL0_OVR1]		= VDC5FB_OFFSET(0xFCFF756C),
+	[SC0_SCL1_UPDATE]	= VDC5FB_OFFSET(0xFCFF7580),
+	[SC0_SCL1_WR1]		= VDC5FB_OFFSET(0xFCFF7588),
+	[SC0_SCL1_WR2]		= VDC5FB_OFFSET(0xFCFF758C),
+	[SC0_SCL1_WR3]		= VDC5FB_OFFSET(0xFCFF7590),
+	[SC0_SCL1_WR4]		= VDC5FB_OFFSET(0xFCFF7594),
+	[SC0_SCL1_WR5]		= VDC5FB_OFFSET(0xFCFF759C),
+	[SC0_SCL1_WR6]		= VDC5FB_OFFSET(0xFCFF75A0),
+	[SC0_SCL1_WR7]		= VDC5FB_OFFSET(0xFCFF75A4),
+	[SC0_SCL1_WR8]		= VDC5FB_OFFSET(0xFCFF75A8),
+	[SC0_SCL1_WR9]		= VDC5FB_OFFSET(0xFCFF75AC),
+	[SC0_SCL1_WR10]		= VDC5FB_OFFSET(0xFCFF75B0),
+	[SC0_SCL1_WR11]		= VDC5FB_OFFSET(0xFCFF75B4),
+	[SC0_SCL1_MON1]		= VDC5FB_OFFSET(0xFCFF75B8),
+	[SC0_SCL1_PBUF0]	= VDC5FB_OFFSET(0xFCFF75BC),
+	[SC0_SCL1_PBUF1]	= VDC5FB_OFFSET(0xFCFF75C0),
+	[SC0_SCL1_PBUF2]	= VDC5FB_OFFSET(0xFCFF75C4),
+	[SC0_SCL1_PBUF3]	= VDC5FB_OFFSET(0xFCFF75C8),
+	[SC0_SCL1_PBUF_FLD]	= VDC5FB_OFFSET(0xFCFF75CC),
+	[SC0_SCL1_PBUF_CNT]	= VDC5FB_OFFSET(0xFCFF75D0),
+
+	/* GRAPHICS 0 */
+	[GR0_UPDATE]		= VDC5FB_OFFSET(0xFCFF7600),
+	[GR0_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7604),
+	[GR0_FLM1]		= VDC5FB_OFFSET(0xFCFF7608),
+	[GR0_FLM2]		= VDC5FB_OFFSET(0xFCFF760C),
+	[GR0_FLM3]		= VDC5FB_OFFSET(0xFCFF7610),
+	[GR0_FLM4]		= VDC5FB_OFFSET(0xFCFF7614),
+	[GR0_FLM5]		= VDC5FB_OFFSET(0xFCFF7618),
+	[GR0_FLM6]		= VDC5FB_OFFSET(0xFCFF761C),
+	[GR0_AB1]		= VDC5FB_OFFSET(0xFCFF7620),
+	[GR0_AB2]		= VDC5FB_OFFSET(0xFCFF7624),
+	[GR0_AB3]		= VDC5FB_OFFSET(0xFCFF7628),
+	[GR0_AB7]		= VDC5FB_OFFSET(0xFCFF7638),
+	[GR0_AB8]		= VDC5FB_OFFSET(0xFCFF763C),
+	[GR0_AB9]		= VDC5FB_OFFSET(0xFCFF7640),
+	[GR0_AB10]		= VDC5FB_OFFSET(0xFCFF7644),
+	[GR0_AB11]		= VDC5FB_OFFSET(0xFCFF7648),
+	[GR0_BASE]		= VDC5FB_OFFSET(0xFCFF764C),
+	[GR0_CLUT]		= VDC5FB_OFFSET(0xFCFF7650),
+	[GR0_MON]		= VDC5FB_OFFSET(0xFCFF7654),
+
+	/* SCALER 1 */
+	[SC1_SCL0_UPDATE]	= VDC5FB_OFFSET(0xFCFF7C00),
+	[SC1_SCL0_FRC1]		= VDC5FB_OFFSET(0xFCFF7C04),
+	[SC1_SCL0_FRC2]		= VDC5FB_OFFSET(0xFCFF7C08),
+	[SC1_SCL0_FRC3]		= VDC5FB_OFFSET(0xFCFF7C0C),
+	[SC1_SCL0_FRC4]		= VDC5FB_OFFSET(0xFCFF7C10),
+	[SC1_SCL0_FRC5]		= VDC5FB_OFFSET(0xFCFF7C14),
+	[SC1_SCL0_FRC6]		= VDC5FB_OFFSET(0xFCFF7C18),
+	[SC1_SCL0_FRC7]		= VDC5FB_OFFSET(0xFCFF7C1C),
+	[SC1_SCL0_FRC9]		= VDC5FB_OFFSET(0xFCFF7C20),
+	[SC1_SCL0_MON0]		= VDC5FB_OFFSET(0xFCFF7C24),
+	[SC1_SCL0_INT]		= VDC5FB_OFFSET(0xFCFF7C28),
+	[SC1_SCL0_DS1]		= VDC5FB_OFFSET(0xFCFF7C2C),
+	[SC1_SCL0_DS2]		= VDC5FB_OFFSET(0xFCFF7C30),
+	[SC1_SCL0_DS3]		= VDC5FB_OFFSET(0xFCFF7C34),
+	[SC1_SCL0_DS4]		= VDC5FB_OFFSET(0xFCFF7C38),
+	[SC1_SCL0_DS5]		= VDC5FB_OFFSET(0xFCFF7C3C),
+	[SC1_SCL0_DS6]		= VDC5FB_OFFSET(0xFCFF7C40),
+	[SC1_SCL0_DS7]		= VDC5FB_OFFSET(0xFCFF7C44),
+	[SC1_SCL0_US1]		= VDC5FB_OFFSET(0xFCFF7C48),
+	[SC1_SCL0_US2]		= VDC5FB_OFFSET(0xFCFF7C4C),
+	[SC1_SCL0_US3]		= VDC5FB_OFFSET(0xFCFF7C50),
+	[SC1_SCL0_US4]		= VDC5FB_OFFSET(0xFCFF7C54),
+	[SC1_SCL0_US5]		= VDC5FB_OFFSET(0xFCFF7C58),
+	[SC1_SCL0_US6]		= VDC5FB_OFFSET(0xFCFF7C5C),
+	[SC1_SCL0_US7]		= VDC5FB_OFFSET(0xFCFF7C60),
+	[SC1_SCL0_US8]		= VDC5FB_OFFSET(0xFCFF7C64),
+	[SC1_SCL0_OVR1]		= VDC5FB_OFFSET(0xFCFF7C6C),
+	[SC1_SCL1_UPDATE]	= VDC5FB_OFFSET(0xFCFF7C80),
+	[SC1_SCL1_WR1]		= VDC5FB_OFFSET(0xFCFF7C88),
+	[SC1_SCL1_WR2]		= VDC5FB_OFFSET(0xFCFF7C8C),
+	[SC1_SCL1_WR3]		= VDC5FB_OFFSET(0xFCFF7C90),
+	[SC1_SCL1_WR4]		= VDC5FB_OFFSET(0xFCFF7C94),
+	[SC1_SCL1_WR5]		= VDC5FB_OFFSET(0xFCFF7C9C),
+	[SC1_SCL1_WR6]		= VDC5FB_OFFSET(0xFCFF7CA0),
+	[SC1_SCL1_WR7]		= VDC5FB_OFFSET(0xFCFF7CA4),
+	[SC1_SCL1_WR8]		= VDC5FB_OFFSET(0xFCFF7CA8),
+	[SC1_SCL1_WR9]		= VDC5FB_OFFSET(0xFCFF7CAC),
+	[SC1_SCL1_WR10]		= VDC5FB_OFFSET(0xFCFF7CB0),
+	[SC1_SCL1_WR11]		= VDC5FB_OFFSET(0xFCFF7CB4),
+	[SC1_SCL1_MON1]		= VDC5FB_OFFSET(0xFCFF7CB8),
+	[SC1_SCL1_PBUF0]	= VDC5FB_OFFSET(0xFCFF7CBC),
+	[SC1_SCL1_PBUF1]	= VDC5FB_OFFSET(0xFCFF7CC0),
+	[SC1_SCL1_PBUF2]	= VDC5FB_OFFSET(0xFCFF7CC4),
+	[SC1_SCL1_PBUF3]	= VDC5FB_OFFSET(0xFCFF7CC9),
+	[SC1_SCL1_PBUF_FLD]	= VDC5FB_OFFSET(0xFCFF7CCC),
+	[SC1_SCL1_PBUF_CNT]	= VDC5FB_OFFSET(0xFCFF7CD0),
+
+	/* GRAPHICS 1 */
+	[GR1_UPDATE]		= VDC5FB_OFFSET(0xFCFF7D00),
+	[GR1_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7D04),
+	[GR1_FLM1]		= VDC5FB_OFFSET(0xFCFF7D08),
+	[GR1_FLM2]		= VDC5FB_OFFSET(0xFCFF7D0C),
+	[GR1_FLM3]		= VDC5FB_OFFSET(0xFCFF7D10),
+	[GR1_FLM4]		= VDC5FB_OFFSET(0xFCFF7D14),
+	[GR1_FLM5]		= VDC5FB_OFFSET(0xFCFF7D18),
+	[GR1_FLM6]		= VDC5FB_OFFSET(0xFCFF7D1C),
+	[GR1_AB1]		= VDC5FB_OFFSET(0xFCFF7D20),
+	[GR1_AB2]		= VDC5FB_OFFSET(0xFCFF7D24),
+	[GR1_AB3]		= VDC5FB_OFFSET(0xFCFF7D28),
+	[GR1_AB4]		= VDC5FB_OFFSET(0xFCFF7D2C),
+	[GR1_AB5]		= VDC5FB_OFFSET(0xFCFF7D30),
+	[GR1_AB6]		= VDC5FB_OFFSET(0xFCFF7D34),
+	[GR1_AB7]		= VDC5FB_OFFSET(0xFCFF7D38),
+	[GR1_AB8]		= VDC5FB_OFFSET(0xFCFF7D3C),
+	[GR1_AB9]		= VDC5FB_OFFSET(0xFCFF7D40),
+	[GR1_AB10]		= VDC5FB_OFFSET(0xFCFF7D44),
+	[GR1_AB11]		= VDC5FB_OFFSET(0xFCFF7D48),
+	[GR1_BASE]		= VDC5FB_OFFSET(0xFCFF7D4C),
+	[GR1_CLUT]		= VDC5FB_OFFSET(0xFCFF7D50),
+	[GR1_MON]		= VDC5FB_OFFSET(0xFCFF7D54),
+
+	/* IMAGE QUALITY IMPROVER 0 */
+	[ADJ0_UPDATE]		= VDC5FB_OFFSET(0xFCFF7680),
+	[ADJ0_BKSTR_SET]	= VDC5FB_OFFSET(0xFCFF7684),
+	[ADJ0_ENH_TIM1]		= VDC5FB_OFFSET(0xFCFF7688),
+	[ADJ0_ENH_TIM2]		= VDC5FB_OFFSET(0xFCFF768C),
+	[ADJ0_ENH_TIM3]		= VDC5FB_OFFSET(0xFCFF7690),
+	[ADJ0_ENH_SHP1]		= VDC5FB_OFFSET(0xFCFF7694),
+	[ADJ0_ENH_SHP2]		= VDC5FB_OFFSET(0xFCFF7698),
+	[ADJ0_ENH_SHP3]		= VDC5FB_OFFSET(0xFCFF769C),
+	[ADJ0_ENH_SHP4]		= VDC5FB_OFFSET(0xFCFF76A0),
+	[ADJ0_ENH_SHP5]		= VDC5FB_OFFSET(0xFCFF76A4),
+	[ADJ0_ENH_SHP6]		= VDC5FB_OFFSET(0xFCFF76A8),
+	[ADJ0_ENH_LTI1]		= VDC5FB_OFFSET(0xFCFF76AC),
+	[ADJ0_ENH_LTI2]		= VDC5FB_OFFSET(0xFCFF76B0),
+	[ADJ0_MTX_MODE]		= VDC5FB_OFFSET(0xFCFF76B4),
+	[ADJ0_MTX_YG_ADJ0]	= VDC5FB_OFFSET(0xFCFF76B8),
+	[ADJ0_MTX_YG_ADJ1]	= VDC5FB_OFFSET(0xFCFF76BC),
+	[ADJ0_MTX_CBB_ADJ0]	= VDC5FB_OFFSET(0xFCFF76C0),
+	[ADJ0_MTX_CBB_ADJ1]	= VDC5FB_OFFSET(0xFCFF76C4),
+	[ADJ0_MTX_CRR_ADJ0]	= VDC5FB_OFFSET(0xFCFF76C8),
+	[ADJ0_MTX_CRR_ADJ1]	= VDC5FB_OFFSET(0xFCFF76CC),
+
+	/* IMAGE QUALITY IMPROVER 1 */
+	[ADJ1_UPDATE]		= VDC5FB_OFFSET(0xFCFF7D80),
+	[ADJ1_BKSTR_SET]	= VDC5FB_OFFSET(0xFCFF7D84),
+	[ADJ1_ENH_TIM1]		= VDC5FB_OFFSET(0xFCFF7D88),
+	[ADJ1_ENH_TIM2]		= VDC5FB_OFFSET(0xFCFF7D8C),
+	[ADJ1_ENH_TIM3]		= VDC5FB_OFFSET(0xFCFF7D90),
+	[ADJ1_ENH_SHP1]		= VDC5FB_OFFSET(0xFCFF7D94),
+	[ADJ1_ENH_SHP2]		= VDC5FB_OFFSET(0xFCFF7D98),
+	[ADJ1_ENH_SHP3]		= VDC5FB_OFFSET(0xFCFF7D9C),
+	[ADJ1_ENH_SHP4]		= VDC5FB_OFFSET(0xFCFF7DA0),
+	[ADJ1_ENH_SHP5]		= VDC5FB_OFFSET(0xFCFF7DA4),
+	[ADJ1_ENH_SHP6]		= VDC5FB_OFFSET(0xFCFF7DA8),
+	[ADJ1_ENH_LTI1]		= VDC5FB_OFFSET(0xFCFF7DA8),
+	[ADJ1_ENH_LTI2]		= VDC5FB_OFFSET(0xFCFF7DB0),
+	[ADJ1_MTX_MODE]		= VDC5FB_OFFSET(0xFCFF7DB4),
+	[ADJ1_MTX_YG_ADJ0]	= VDC5FB_OFFSET(0xFCFF7DB8),
+	[ADJ1_MTX_YG_ADJ1]	= VDC5FB_OFFSET(0xFCFF7DBC),
+	[ADJ1_MTX_CBB_ADJ0]	= VDC5FB_OFFSET(0xFCFF7DC0),
+	[ADJ1_MTX_CBB_ADJ1]	= VDC5FB_OFFSET(0xFCFF7CC4),
+	[ADJ1_MTX_CRR_ADJ0]	= VDC5FB_OFFSET(0xFCFF7DC8),
+	[ADJ1_MTX_CRR_ADJ1]	= VDC5FB_OFFSET(0xFCFF7DCC),
+
+	/* GRAPHICS 2 */
+	[GR2_UPDATE]		= VDC5FB_OFFSET(0xFCFF7700),
+	[GR2_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7704),
+	[GR2_FLM1]		= VDC5FB_OFFSET(0xFCFF7708),
+	[GR2_FLM2]		= VDC5FB_OFFSET(0xFCFF770C),
+	[GR2_FLM3]		= VDC5FB_OFFSET(0xFCFF7710),
+	[GR2_FLM4]		= VDC5FB_OFFSET(0xFCFF7714),
+	[GR2_FLM5]		= VDC5FB_OFFSET(0xFCFF7718),
+	[GR2_FLM6]		= VDC5FB_OFFSET(0xFCFF771C),
+	[GR2_AB1]		= VDC5FB_OFFSET(0xFCFF7720),
+	[GR2_AB2]		= VDC5FB_OFFSET(0xFCFF7724),
+	[GR2_AB3]		= VDC5FB_OFFSET(0xFCFF7728),
+	[GR2_AB4]		= VDC5FB_OFFSET(0xFCFF772C),
+	[GR2_AB5]		= VDC5FB_OFFSET(0xFCFF7730),
+	[GR2_AB6]		= VDC5FB_OFFSET(0xFCFF7734),
+	[GR2_AB7]		= VDC5FB_OFFSET(0xFCFF7738),
+	[GR2_AB8]		= VDC5FB_OFFSET(0xFCFF773C),
+	[GR2_AB9]		= VDC5FB_OFFSET(0xFCFF7740),
+	[GR2_AB10]		= VDC5FB_OFFSET(0xFCFF7744),
+	[GR2_AB11]		= VDC5FB_OFFSET(0xFCFF7748),
+	[GR2_BASE]		= VDC5FB_OFFSET(0xFCFF774C),
+	[GR2_CLUT]		= VDC5FB_OFFSET(0xFCFF7750),
+	[GR2_MON]		= VDC5FB_OFFSET(0xFCFF7754),
+
+	/* GRAPHICS 3 */
+	[GR3_UPDATE]		= VDC5FB_OFFSET(0xFCFF7780),
+	[GR3_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7784),
+	[GR3_FLM1]		= VDC5FB_OFFSET(0xFCFF7788),
+	[GR3_FLM2]		= VDC5FB_OFFSET(0xFCFF778C),
+	[GR3_FLM3]		= VDC5FB_OFFSET(0xFCFF7790),
+	[GR3_FLM4]		= VDC5FB_OFFSET(0xFCFF7794),
+	[GR3_FLM5]		= VDC5FB_OFFSET(0xFCFF7798),
+	[GR3_FLM6]		= VDC5FB_OFFSET(0xFCFF779C),
+	[GR3_AB1]		= VDC5FB_OFFSET(0xFCFF77A0),
+	[GR3_AB2]		= VDC5FB_OFFSET(0xFCFF77A4),
+	[GR3_AB3]		= VDC5FB_OFFSET(0xFCFF77A8),
+	[GR3_AB4]		= VDC5FB_OFFSET(0xFCFF77AC),
+	[GR3_AB5]		= VDC5FB_OFFSET(0xFCFF77B0),
+	[GR3_AB6]		= VDC5FB_OFFSET(0xFCFF77B4),
+	[GR3_AB7]		= VDC5FB_OFFSET(0xFCFF77B8),
+	[GR3_AB8]		= VDC5FB_OFFSET(0xFCFF77BC),
+	[GR3_AB9]		= VDC5FB_OFFSET(0xFCFF77C0),
+	[GR3_AB10]		= VDC5FB_OFFSET(0xFCFF77C4),
+	[GR3_AB11]		= VDC5FB_OFFSET(0xFCFF77C8),
+	[GR3_BASE]		= VDC5FB_OFFSET(0xFCFF77CC),
+	[GR3_CLUT_INT]		= VDC5FB_OFFSET(0xFCFF77D0),
+	[GR3_MON]		= VDC5FB_OFFSET(0xFCFF77D4),
+
+	/* VIN SYNTHESIZER */
+	[GR_VIN_UPDATE]		= VDC5FB_OFFSET(0xFCFF7E00),
+	[GR_VIN_AB1]		= VDC5FB_OFFSET(0xFCFF7E20),
+	[GR_VIN_AB2]		= VDC5FB_OFFSET(0xFCFF7E24),
+	[GR_VIN_AB3]		= VDC5FB_OFFSET(0xFCFF7E28),
+	[GR_VIN_AB4]		= VDC5FB_OFFSET(0xFCFF7E2C),
+	[GR_VIN_AB5]		= VDC5FB_OFFSET(0xFCFF7E30),
+	[GR_VIN_AB6]		= VDC5FB_OFFSET(0xFCFF7E34),
+	[GR_VIN_AB7]		= VDC5FB_OFFSET(0xFCFF7E38),
+	[GR_VIN_BASE]		= VDC5FB_OFFSET(0xFCFF7E4C),
+	[GR_VIN_MON]		= VDC5FB_OFFSET(0xFCFF7E54),
+
+	/* OUTPUT IMAGE GENERATOR */
+	[OIR_SCL0_UPDATE]	= VDC5FB_OFFSET(0xFCFF7E80),
+	[OIR_SCL0_FRC1]		= VDC5FB_OFFSET(0xFCFF7E84),
+	[OIR_SCL0_FRC2]		= VDC5FB_OFFSET(0xFCFF7E88),
+	[OIR_SCL0_FRC3]		= VDC5FB_OFFSET(0xFCFF7E8C),
+	[OIR_SCL0_FRC4]		= VDC5FB_OFFSET(0xFCFF7E90),
+	[OIR_SCL0_FRC5]		= VDC5FB_OFFSET(0xFCFF7E94),
+	[OIR_SCL0_FRC6]		= VDC5FB_OFFSET(0xFCFF7E98),
+	[OIR_SCL0_FRC7]		= VDC5FB_OFFSET(0xFCFF7E9C),
+	[OIR_SCL0_DS1]		= VDC5FB_OFFSET(0xFCFF7EAC),
+	[OIR_SCL0_DS2]		= VDC5FB_OFFSET(0xFCFF7EB0),
+	[OIR_SCL0_DS3]		= VDC5FB_OFFSET(0xFCFF7EB4),
+	[OIR_SCL0_DS7]		= VDC5FB_OFFSET(0xFCFF7EC4),
+	[OIR_SCL0_US1]		= VDC5FB_OFFSET(0xFCFF7EC8),
+	[OIR_SCL0_US2]		= VDC5FB_OFFSET(0xFCFF7ECC),
+	[OIR_SCL0_US3]		= VDC5FB_OFFSET(0xFCFF7ED0),
+	[OIR_SCL0_US8]		= VDC5FB_OFFSET(0xFCFF7EE4),
+	[OIR_SCL0_OVR1]		= VDC5FB_OFFSET(0xFCFF7EEC),
+	[OIR_SCL1_UPDATE]	= VDC5FB_OFFSET(0xFCFF7F00),
+	[OIR_SCL1_WR1]		= VDC5FB_OFFSET(0xFCFF7F08),
+	[OIR_SCL1_WR2]		= VDC5FB_OFFSET(0xFCFF7F0C),
+	[OIR_SCL1_WR3]		= VDC5FB_OFFSET(0xFCFF7F10),
+	[OIR_SCL1_WR4]		= VDC5FB_OFFSET(0xFCFF7F14),
+	[OIR_SCL1_WR5]		= VDC5FB_OFFSET(0xFCFF7F1C),
+	[OIR_SCL1_WR6]		= VDC5FB_OFFSET(0xFCFF7F20),
+	[OIR_SCL1_WR7]		= VDC5FB_OFFSET(0xFCFF7F24),
+
+	/* GRAPHICS OIR */
+	[GR_OIR_UPDATE]		= VDC5FB_OFFSET(0xFCFF7F80),
+	[GR_OIR_FLM_RD]		= VDC5FB_OFFSET(0xFCFF7F84),
+	[GR_OIR_FLM1]		= VDC5FB_OFFSET(0xFCFF7F88),
+	[GR_OIR_FLM2]		= VDC5FB_OFFSET(0xFCFF7F8C),
+	[GR_OIR_FLM3]		= VDC5FB_OFFSET(0xFCFF7F90),
+	[GR_OIR_FLM4]		= VDC5FB_OFFSET(0xFCFF7F94),
+	[GR_OIR_FLM5]		= VDC5FB_OFFSET(0xFCFF7F98),
+	[GR_OIR_FLM6]		= VDC5FB_OFFSET(0xFCFF7F9C),
+	[GR_OIR_AB1]		= VDC5FB_OFFSET(0xFCFF7FA0),
+	[GR_OIR_AB2]		= VDC5FB_OFFSET(0xFCFF7FA4),
+	[GR_OIR_AB3]		= VDC5FB_OFFSET(0xFCFF7FA8),
+	[GR_OIR_AB7]		= VDC5FB_OFFSET(0xFCFF7FB8),
+	[GR_OIR_AB8]		= VDC5FB_OFFSET(0xFCFF7FBC),
+	[GR_OIR_AB9]		= VDC5FB_OFFSET(0xFCFF7FC0),
+	[GR_OIR_AB10]		= VDC5FB_OFFSET(0xFCFF7FC4),
+	[GR_OIR_AB11]		= VDC5FB_OFFSET(0xFCFF7FC8),
+	[GR_OIR_BASE]		= VDC5FB_OFFSET(0xFCFF7FCC),
+	[GR_OIR_CLUT]		= VDC5FB_OFFSET(0xFCFF7FD0),
+	[GR_OIR_MON]		= VDC5FB_OFFSET(0xFCFF7FD4),
+
+	/* GAMMA CORRECTION BLOCK */
+	[GAM_G_UPDATE]		= VDC5FB_OFFSET(0xFCFF7800),
+	[GAM_SW]		= VDC5FB_OFFSET(0xFCFF7804),
+	[GAM_G_LUT1]		= VDC5FB_OFFSET(0xFCFF7808),
+	[GAM_G_LUT2]		= VDC5FB_OFFSET(0xFCFF780C),
+	[GAM_G_LUT3]		= VDC5FB_OFFSET(0xFCFF7810),
+	[GAM_G_LUT4]		= VDC5FB_OFFSET(0xFCFF7814),
+	[GAM_G_LUT5]		= VDC5FB_OFFSET(0xFCFF7818),
+	[GAM_G_LUT6]		= VDC5FB_OFFSET(0xFCFF781C),
+	[GAM_G_LUT7]		= VDC5FB_OFFSET(0xFCFF7820),
+	[GAM_G_LUT8]		= VDC5FB_OFFSET(0xFCFF7824),
+	[GAM_G_LUT9]		= VDC5FB_OFFSET(0xFCFF7828),
+	[GAM_G_LUT10]		= VDC5FB_OFFSET(0xFCFF782C),
+	[GAM_G_LUT11]		= VDC5FB_OFFSET(0xFCFF7830),
+	[GAM_G_LUT12]		= VDC5FB_OFFSET(0xFCFF7834),
+	[GAM_G_LUT13]		= VDC5FB_OFFSET(0xFCFF7838),
+	[GAM_G_LUT14]		= VDC5FB_OFFSET(0xFCFF783C),
+	[GAM_G_LUT15]		= VDC5FB_OFFSET(0xFCFF7840),
+	[GAM_G_LUT16]		= VDC5FB_OFFSET(0xFCFF7844),
+	[GAM_G_AREA1]		= VDC5FB_OFFSET(0xFCFF7848),
+	[GAM_G_AREA2]		= VDC5FB_OFFSET(0xFCFF784C),
+	[GAM_G_AREA3]		= VDC5FB_OFFSET(0xFCFF7850),
+	[GAM_G_AREA4]		= VDC5FB_OFFSET(0xFCFF7854),
+	[GAM_G_AREA5]		= VDC5FB_OFFSET(0xFCFF7858),
+	[GAM_G_AREA6]		= VDC5FB_OFFSET(0xFCFF785C),
+	[GAM_G_AREA7]		= VDC5FB_OFFSET(0xFCFF7860),
+	[GAM_G_AREA8]		= VDC5FB_OFFSET(0xFCFF7864),
+	[GAM_B_UPDATE]		= VDC5FB_OFFSET(0xFCFF7880),
+	[GAM_B_LUT1]		= VDC5FB_OFFSET(0xFCFF7888),
+	[GAM_B_LUT2]		= VDC5FB_OFFSET(0xFCFF788C),
+	[GAM_B_LUT3]		= VDC5FB_OFFSET(0xFCFF7890),
+	[GAM_B_LUT4]		= VDC5FB_OFFSET(0xFCFF7894),
+	[GAM_B_LUT5]		= VDC5FB_OFFSET(0xFCFF7898),
+	[GAM_B_LUT6]		= VDC5FB_OFFSET(0xFCFF789C),
+	[GAM_B_LUT7]		= VDC5FB_OFFSET(0xFCFF78A0),
+	[GAM_B_LUT8]		= VDC5FB_OFFSET(0xFCFF78A4),
+	[GAM_B_LUT9]		= VDC5FB_OFFSET(0xFCFF78A8),
+	[GAM_B_LUT10]		= VDC5FB_OFFSET(0xFCFF78AC),
+	[GAM_B_LUT11]		= VDC5FB_OFFSET(0xFCFF78B0),
+	[GAM_B_LUT12]		= VDC5FB_OFFSET(0xFCFF78B4),
+	[GAM_B_LUT13]		= VDC5FB_OFFSET(0xFCFF78B8),
+	[GAM_B_LUT14]		= VDC5FB_OFFSET(0xFCFF78BC),
+	[GAM_B_LUT15]		= VDC5FB_OFFSET(0xFCFF78C0),
+	[GAM_B_LUT16]		= VDC5FB_OFFSET(0xFCFF78C4),
+	[GAM_B_AREA1]		= VDC5FB_OFFSET(0xFCFF78C8),
+	[GAM_B_AREA2]		= VDC5FB_OFFSET(0xFCFF78CC),
+	[GAM_B_AREA3]		= VDC5FB_OFFSET(0xFCFF78D0),
+	[GAM_B_AREA4]		= VDC5FB_OFFSET(0xFCFF78D4),
+	[GAM_B_AREA5]		= VDC5FB_OFFSET(0xFCFF78D8),
+	[GAM_B_AREA6]		= VDC5FB_OFFSET(0xFCFF78DC),
+	[GAM_B_AREA7]		= VDC5FB_OFFSET(0xFCFF78E0),
+	[GAM_B_AREA8]		= VDC5FB_OFFSET(0xFCFF78E4),
+	[GAM_R_UPDATE]		= VDC5FB_OFFSET(0xFCFF7900),
+	[GAM_R_LUT1]		= VDC5FB_OFFSET(0xFCFF7908),
+	[GAM_R_LUT2]		= VDC5FB_OFFSET(0xFCFF790C),
+	[GAM_R_LUT3]		= VDC5FB_OFFSET(0xFCFF7910),
+	[GAM_R_LUT4]		= VDC5FB_OFFSET(0xFCFF7914),
+	[GAM_R_LUT5]		= VDC5FB_OFFSET(0xFCFF7918),
+	[GAM_R_LUT6]		= VDC5FB_OFFSET(0xFCFF791C),
+	[GAM_R_LUT7]		= VDC5FB_OFFSET(0xFCFF7920),
+	[GAM_R_LUT8]		= VDC5FB_OFFSET(0xFCFF7924),
+	[GAM_R_LUT9]		= VDC5FB_OFFSET(0xFCFF7928),
+	[GAM_R_LUT10]		= VDC5FB_OFFSET(0xFCFF792C),
+	[GAM_R_LUT11]		= VDC5FB_OFFSET(0xFCFF7930),
+	[GAM_R_LUT12]		= VDC5FB_OFFSET(0xFCFF7934),
+	[GAM_R_LUT13]		= VDC5FB_OFFSET(0xFCFF7938),
+	[GAM_R_LUT14]		= VDC5FB_OFFSET(0xFCFF793C),
+	[GAM_R_LUT15]		= VDC5FB_OFFSET(0xFCFF7940),
+	[GAM_R_LUT16]		= VDC5FB_OFFSET(0xFCFF7944),
+	[GAM_R_AREA1]		= VDC5FB_OFFSET(0xFCFF7948),
+	[GAM_R_AREA2]		= VDC5FB_OFFSET(0xFCFF794C),
+	[GAM_R_AREA3]		= VDC5FB_OFFSET(0xFCFF7950),
+	[GAM_R_AREA4]		= VDC5FB_OFFSET(0xFCFF7954),
+	[GAM_R_AREA5]		= VDC5FB_OFFSET(0xFCFF7958),
+	[GAM_R_AREA6]		= VDC5FB_OFFSET(0xFCFF795C),
+	[GAM_R_AREA7]		= VDC5FB_OFFSET(0xFCFF7960),
+	[GAM_R_AREA8]		= VDC5FB_OFFSET(0xFCFF7964),
+
+	/* TCON BLOCK */
+	[TCON_UPDATE]		= VDC5FB_OFFSET(0xFCFF7980),
+	[TCON_TIM]		= VDC5FB_OFFSET(0xFCFF7984),
+	[TCON_TIM_STVA1]	= VDC5FB_OFFSET(0xFCFF7988),
+	[TCON_TIM_STVA2]	= VDC5FB_OFFSET(0xFCFF798C),
+	[TCON_TIM_STVB1]	= VDC5FB_OFFSET(0xFCFF7990),
+	[TCON_TIM_STVB2]	= VDC5FB_OFFSET(0xFCFF7994),
+	[TCON_TIM_STH1]		= VDC5FB_OFFSET(0xFCFF7998),
+	[TCON_TIM_STH2]		= VDC5FB_OFFSET(0xFCFF799C),
+	[TCON_TIM_STB1]		= VDC5FB_OFFSET(0xFCFF79A0),
+	[TCON_TIM_STB2]		= VDC5FB_OFFSET(0xFCFF79A4),
+	[TCON_TIM_CPV1]		= VDC5FB_OFFSET(0xFCFF79A8),
+	[TCON_TIM_CPV2]		= VDC5FB_OFFSET(0xFCFF79AC),
+	[TCON_TIM_POLA1]	= VDC5FB_OFFSET(0xFCFF79B0),
+	[TCON_TIM_POLA2]	= VDC5FB_OFFSET(0xFCFF79B4),
+	[TCON_TIM_POLB1]	= VDC5FB_OFFSET(0xFCFF79B8),
+	[TCON_TIM_POLB2]	= VDC5FB_OFFSET(0xFCFF79BC),
+	[TCON_TIM_DE]		= VDC5FB_OFFSET(0xFCFF79C0),
+
+	/* OUTPUT CONTROLLER */
+	[OUT_UPDATE]		= VDC5FB_OFFSET(0xFCFF7A00),
+	[OUT_SET]		= VDC5FB_OFFSET(0xFCFF7A04),
+	[OUT_BRIGHT1]		= VDC5FB_OFFSET(0xFCFF7A08),
+	[OUT_BRIGHT2]		= VDC5FB_OFFSET(0xFCFF7A0C),
+	[OUT_CONTRAST]		= VDC5FB_OFFSET(0xFCFF7A10),
+	[OUT_PDTHA]		= VDC5FB_OFFSET(0xFCFF7A14),
+	[OUT_CLK_PHASE]		= VDC5FB_OFFSET(0xFCFF7A24),
+
+	/* SYSTEM CONTROLLER */
+	[SYSCNT_INT1]		= VDC5FB_OFFSET(0xFCFF7A80),
+	[SYSCNT_INT2]		= VDC5FB_OFFSET(0xFCFF7A84),
+	[SYSCNT_INT3]		= VDC5FB_OFFSET(0xFCFF7A88),
+	[SYSCNT_INT4]		= VDC5FB_OFFSET(0xFCFF7A8C),
+	[SYSCNT_INT5]		= VDC5FB_OFFSET(0xFCFF7A90),
+	[SYSCNT_INT6]		= VDC5FB_OFFSET(0xFCFF7A94),
+	[SYSCNT_PANEL_CLK]	= VDC5FB_OFFSET(0xFCFF7A98), /* 16-bit */
+	[SYSCNT_CLUT]		= VDC5FB_OFFSET(0xFCFF7A9A), /* 16-bit */
+};
+
+/* INTERRUPT NAME */
+static const char *irq_names[VDC5FB_MAX_IRQS] = {
+	[S0_VI_VSYNC]		= "s0_vi_vsync",
+	[S0_LO_VSYNC]		= "s0_lo_vsync",
+	[S0_VSYNCERR]		= "s0_vsyncerr",
+	[GR3_VLINE]		= "gr3_vline",
+	[S0_VFIELD]		= "s0_vfield",
+	[IV1_VBUFERR]		= "iv1_vbuferr",
+	[IV3_VBUFERR]		= "iv3_vbuferr",
+	[IV5_VBUFERR]		= "iv5_vbuferr",
+	[IV6_VBUFERR]		= "iv6_vbuferr",
+	[S0_WLINE]		= "s0_wline",
+	[S1_VI_VSYNC]		= "s1_vi_vsync",
+	[S1_LO_VSYNC]		= "s1_lo_vsync",
+	[S1_VSYNCERR]		= "s1_vsyncerr",
+	[S1_VFIELD]		= "s1_vfield",
+	[IV2_VBUFERR]		= "iv2_vbuferr",
+	[IV4_VBUFERR]		= "iv4_vbuferr",
+	[S1_WLINE]		= "s1_wline",
+	[OIR_VI_VSYNC]		= "oir_vi_vsync",
+	[OIR_LO_VSYNC]		= "oir_lo_vsync",
+	[OIR_VLINE]		= "oir_vline",
+	[OIR_VFIELD]		= "oir_vfield",
+	[IV7_VBUFERR]		= "iv7_vbuferr",
+	[IV8_VBUFERR]		= "iv8_vbuferr",
+};
+
+/************************************************************************/
+/* REGISTER BITS */
+
+#define	RGB888(r, g, b)		\
+	((((r) & 0xffu) << 16) | (((g) & 0xffu) << 8) | ((b) & 0xffu))
+#define	GBR888(g, b, r)		\
+	((((g) & 0xffu) << 16) | (((b) & 0xffu) << 8) | ((r) & 0xffu))
+#define	AGBR(a, g, b, r)		\
+	((((a) & 0xffu) << 24) | (((g) & 0xffu) << 16) \
+	| (((b) & 0xffu) << 8) | ((r) & 0xffu))
+
+/* SYSCNT_PANEL_CLK */
+#define	PANEL_DCDR(x)		(((x) & 0x3fu) << 0)
+#define PANEL_ICKEN		(1u << 8)
+#define PANEL_OCKSEL(x)		(((x) & 0x3u) << 10)
+#define PANEL_ICKSEL(x)         (((x) & 0x3u) << 12)
+
+/* SCx_SCL0_FRC1, OIR_SCL0_FRC1 (x=0,1) */
+#define	SC_RES_VMASK_ON		(1u << 0)
+#define	SC_RES_VMASK(x)		(((x) & 0xffffu) << 16)
+/* SCx_SCL0_FRC2, OIR_SCL0_FRC2 */
+#define	SC_RES_VLACK_ON		(1u << 0)
+#define	SC_RES_VLACK(x)		(((x) & 0xffffu) << 16)
+/* SCx_SCL0_FRC3, OIR_SCL0_FRC3 */
+#define	SC_RES_VS_SEL		(1u << 0)
+#define	SC_RES_VS_IN_SEL	(1u << 8)		/* SC0, SC1 only */
+#define	OIR_RES_EN		(1u << 16)		/* OIR only */
+/* SCx_SCL0_FRC4, OIR_SCL0_FRC4 */
+#define	SC_RES_FH(x)		(((x) & 0x7ffu) << 0)
+#define	SC_RES_FV(x)		(((x) & 0x7ffu) << 16)
+/* SCx_SCL0_FRC5, OIR_SCL0_FRC5 */
+#define	SC_RES_VSDLY(x)		(((x) & 0xffu) << 0)
+#define	SC_RES_FLD_DLY_SEL	(1u << 8)		/* SC0, SC1 only */
+/* SCx_SCL0_FRC6, OIR_SCL0_FRC6 */
+#define	SC_RES_F_VW(x)		(((x) & 0x7ffu) << 0)
+#define	SC_RES_F_VS(x)		(((x) & 0x7ffu) << 16)
+/* SCx_SCL0_FRC7, OIR_SCL0_FRC7 */
+#define	SC_RES_F_HW(x)		(((x) & 0x7ffu) << 0)
+#define	SC_RES_F_HS(x)		(((x) & 0x7ffu) << 16)
+/* SCx_SCL0_OVR1, OIR_SCL0_OVR1 */
+#define	D_SC_RES_BK_COL		RGB888(0, 0, 0)
+/* SCx_SCL0_US8, OIR_SCL0_US8 */
+#define	SC_RES_IBUS_SYNC_SEL	(1u << 4)
+
+/* GRx_FLM_RD, GR_OIR_FLM_RD (x=0,1,2,3) */
+#define	GR_R_ENB		(1u << 0)
+/* GRx_FLM1, GR_OIR_FLM1 */
+#define	GR_BST_MD		(1u << 0)
+#define	GR_OIR_IMR_FLM_INV	(1u << 4)		/* GR_OIR only */
+#define	GR_FLM_SEL(x)		(((x) & 0x3u) << 8)
+#define	GR_LN_OFF_DIR		(1u << 16)
+/* GRx_FLM3, GR_OIR_FLM3 */
+#define	GR_FLM_NUM(x)		(((x) & 0x3ffu) << 0)
+#define	GR_LN_OFF(x)		(((x) & 0x7fffu) << 16)
+/* GRx_FLM4, GR_OIR_FLM4 */
+#define	GR_FLM_OFF(x)		(((x) & 0x7fffffu) << 0)
+/* GRx_FLM5, GR_OIR_FLM5 */
+#define	GR_FLM_LOOP(x)		(((x) & 0x7ffu) << 0)
+#define	GR_FLM_LNUM(x)		(((x) & 0x7ffu) << 16)
+/* GRx_FLM6, GR_OIR_FLM6 */
+#define	GR_RDSWA(x)		(((x) & 0x7u) << 10)
+#define	GR_HW(x)		(((x) & 0x3ff) << 16)
+#define	GR_FORMAT(x)		(((x) & 0xfu) << 28)
+#define	D_GR_FLM6_RGB565	(GR_RDSWA(6) | GR_FORMAT(0))
+#define	D_GR_FLM6_RGB888	(GR_RDSWA(4) | GR_FORMAT(1))
+#define	D_GR_FLM6_ARGB8888	(GR_RDSWA(4) | GR_FORMAT(4))
+#define	D_GR_FLM6_RGBA8888	(GR_RDSWA(4) | GR_FORMAT(11))
+/* GRx_AB1, GR_VIN_AB1, GR_OIR_AB1 */
+#define	GR_DISP_SEL(x)		(((x) & 0x3u) << 0)
+#define	GR_VIN_SCL_UND_SEL	(1u << 2)		/* GR_VIN only */
+#define	GR1_CUS_CON_ON		(1u << 28)		/* GR1 only */
+#define	GR_AB1_MASK		0xeffffff4u
+/* GRx_AB2, GR_VIN_AB2, GR_OIR_AB2 */
+#define	GR_GRC_VW(x)		(((x) & 0x7ffu) << 0)
+#define	GR_GRC_VS(x)		(((x) & 0x7ffu) << 16)
+/* GRx_AB3, GR_VIN_AB3, GR_OIR_AB3 */
+#define	GR_GRC_HW(x)		(((x) & 0x7ffu) << 0)
+#define	GR_GRC_HS(x)		(((x) & 0x7ffu) << 16)
+/* GRx_AB8, GR_VIN_AB8, GR_OIR_AB8 */
+/* GRx_AB9, GR_VIN_AB9, GR_OIR_AB9 */
+/* GRx_AB10, GR_VIN_AB10, GR_OIR_AB10 */
+/* GRx_AB11, GR_VIN_AB11, GR_OIR_AB11 */
+#define	D_GR_AB8		AGBR(0, 0, 0, 0)
+#define	D_GR_AB9		AGBR(0xffu, 0, 0, 0)
+#define	D_GR_AB10		AGBR(0xffu, 0, 0, 0)
+#define	D_GR_AB11		AGBR(0xffu, 0, 0, 0)
+/* GR0_BASE */
+#define	D_GR_BASE		GBR888(0, 0, 0)
+
+/* OUT_CLK_PHASE */
+#define	D_OUT_CLK_PHASE		0
+/* OUT_BRIGHT1, OUT_BRIGHT2 */
+#define	PBRT_G(x)		(((x) & 0x3ffu) << 0)
+#define	PBRT_B(x)		(((x) & 0x3ffu) << 16)
+#define	PBRT_R(x)		(((x) & 0x3ffu) << 0)
+/* OUT_CONTRAST */
+#define	CONT_R(x)		(((x) & 0xffu) << 0)
+#define	CONT_B(x)		(((x) & 0xffu) << 8)
+#define	CONT_G(x)		(((x) & 0xffu) << 16)
+/* OUT_PDTHA */
+#define	PDTHA_FORMAT(x)		(((x) & 0x3u) << 16)
+#define	D_OUT_PDTHA		0x00003021u
+/* OUT_SET */
+#define	OUT_FORMAT(x)		(((x) & 0x3u) << 12)
+#define	D_OUT_SET		0x001f0000u
+
+/* TCON_TIM */
+#define	TCON_OFFSET(x)          (((x) & 0x7ffu) << 0)
+#define	TCON_HALF(x)            (((x) & 0x7ffu) << 16)
+/* TCON_TIM_xxxx */
+#define	TCON_VW(x)		(((x) & 0x7ffu) << 0)
+#define	TCON_VS(x)		(((x) & 0x7ffu) << 16)
+#define	TCON_SEL(x)		(((x) & 0x7u) << 0)
+#define	TCON_INV		(0x1u << 4)
+#define	TCON_HW(x)		(((x) & 0x7ffu) << 0)
+#define	TCON_HS(x)		(((x) & 0x7ffu) << 16)
+#define	TCON_SEL(x)		(((x) & 0x7u) << 0)
+#define	TCON_INV		(0x1u << 4)
+#define	TCON_HS_SEL		(0x1u << 8)
+#define	TCON_MD(x)		(((x) & 0x3u) << 12)
+#define	TCON_DE_INV		(0x1u << 0)
+
+/* INP_UPDATE */
+#define	INP_IMG_UPDATE		(1u << 0)
+#define	INP_EXT_UPDATE		(1u << 4)
+/* IMGCNT_UPDATE */
+#define	IMGCNT_VEN		(1u << 0)
+/* SCx_SCLx_UPDATE, GRx_UPADTE, OIR_SCLx_UPDATE (x=0,1) */
+#define	SC_SCL_VEN_A		(1u << 0)
+#define	SC_SCL_VEN_B		(1u << 4)
+#define	SC_SCL_UPDATE		(1u << 8)
+#define	SC_SCL_VEN_C		(1u << 12)	/* not OIR_SCL1_UPDATE */
+#define	SC_SCL_VEN_D		(1u << 13)	/* not OIR_SCL1_UPDATE */
+/* ADJx_UPDATE */
+#define	ADJ_VEN			(1u << 0)
+/* GRx_UPDATE, GR_OIR_UPDATE (x=2,3) */
+#define	GR_IBUS_VEN		(1u << 0)
+#define	GR_P_VEN		(1u << 4)
+#define	GR_UPDATE		(1u << 8)
+/* GAM_x_UPDATE (x=G,B,R) */
+#define	GAM_VEN			(1u << 0)
+/* TCON_UPDATE */
+#define	TCON_VEN		(1u << 0)
+/* OUT_UPDATE */
+#define	OUTCNT_VEN		(1u << 0)
+
+/************************************************************************/
+/* READ / WRITE VDC5 REGISTERS */
+
+static void vdc5fb_write(struct vdc5fb_priv *priv, int reg, u32 data)
+{
+	if ((SYSCNT_PANEL_CLK == reg) || (SYSCNT_CLUT == reg))
+		iowrite16((u16)data, (priv->base + vdc5fb_offsets[reg]));
+	else
+		iowrite32((u32)data, (priv->base + vdc5fb_offsets[reg]));
+}
+
+static unsigned long vdc5fb_read(struct vdc5fb_priv *priv, int reg)
+{
+	if ((SYSCNT_PANEL_CLK == reg) || (SYSCNT_CLUT == reg))
+		return ioread16(priv->base + vdc5fb_offsets[reg]);
+	else
+		return ioread32(priv->base + vdc5fb_offsets[reg]);
+}
+
+static void vdc5fb_setbits(struct vdc5fb_priv *priv, int reg, u32 bits)
+{
+	u32 tmp;
+
+	tmp = vdc5fb_read(priv, reg);
+	tmp |= bits;
+	vdc5fb_write(priv, reg, tmp);
+}
+
+/************************************************************************/
+
+#endif /* _VDC5FB_REGS_H_ */
diff --git a/drivers/video/renesas/vdc5fb.c b/drivers/video/renesas/vdc5fb.c
new file mode 100644
index 0000000..75defbf
--- /dev/null
+++ b/drivers/video/renesas/vdc5fb.c
@@ -0,0 +1,1419 @@
+/*
+ * Copyright (C) 2013-2014 Renesas Solutions Corp.
+ *
+ * Based on drivers/video/ren_vdc4.c
+ * Copyright (c) 2012 Renesas Electronics Europe Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/clk.h>
+#include <linux/sh_clk.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/uaccess.h>
+#include <asm/div64.h>
+#include <video/vdc5fb.h>
+
+/************************************************************************/
+
+#define PALETTE_NR 16
+
+#define	PIX_FORMAT_RGB565	0
+#define	PIX_FORMAT_RGB888	1
+#define	PIX_FORMAT_ARGB8888	4
+#define	PIX_FORMAT_RGBA8888	11
+
+struct vdc5fb_priv {
+	struct platform_device *pdev;
+	struct vdc5fb_pdata *pdata;
+	const char *dev_name;
+	struct fb_videomode *videomode;	/* current */
+	/* clock */
+	struct clk *clk;
+	struct clk *dot_clk;
+	struct clk *lvds_clk;
+	/* framebuffers */
+	void __iomem *base;
+	unsigned long fbsize;
+	dma_addr_t dma_handle;
+	unsigned long flm_off;
+	unsigned long flm_num;
+	int fb_nofree;
+	/* irq */
+	struct {
+		int start;		/* start irq number */
+		int end;		/* end irq number, inclusive */
+		u32 mask[3];		/* curremnt irq mask */
+		char longname[VDC5FB_IRQ_SIZE][32];	/* ire name */
+	} irq;
+	/* display */
+	struct fb_info *info;
+	unsigned long dc;		/* dot clock in Hz */
+	unsigned int dcdr;		/* dot clock divisor */
+	unsigned int rr;		/* refresh rate in Hz */
+	unsigned int res_fv;		/* vsync period (in fh) */
+	unsigned int res_fh;		/* hsync period (in dc) */
+	u32 pseudo_palette[PALETTE_NR];
+};
+
+/************************************************************************/
+/* Workplace for vdc5-regs.h */
+#include "vdc5fb-regs.h"
+
+/************************************************************************/
+
+static int vdc5fb_init_syscnt(struct vdc5fb_priv *priv);
+static int vdc5fb_init_sync(struct vdc5fb_priv *priv);
+static int vdc5fb_init_scalers(struct vdc5fb_priv *priv);
+static int vdc5fb_init_graphics(struct vdc5fb_priv *priv);
+static int vdc5fb_init_outcnt(struct vdc5fb_priv *priv);
+static int vdc5fb_init_tcon(struct vdc5fb_priv *priv);
+static int vdc5fb_remove(struct platform_device *pdev);
+
+/************************************************************************/
+
+static inline struct vdc5fb_pdata *priv_to_pdata(struct vdc5fb_priv *priv)
+{
+	return (struct vdc5fb_pdata *)(priv->pdev->dev.platform_data);
+}
+
+/************************************************************************/
+/* INTERUPT HANDLING */
+
+static irqreturn_t vdc5fb_irq(int irq, void *data)
+{
+	struct vdc5fb_priv *priv = (struct vdc5fb_priv *)data;
+
+	irq = irq - priv->irq.start;
+	switch (irq) {
+	case S0_VI_VSYNC:	/* INT0 */
+	case S0_LO_VSYNC:	/* INT1 */
+	case S0_VSYNCERR:	/* INT2 */
+	case GR3_VLINE:		/* INT3 */
+	case S0_VFIELD:		/* INT4 */
+	case IV1_VBUFERR:	/* INT5 */
+	case IV3_VBUFERR:	/* INT6 */
+	case IV5_VBUFERR:	/* INT7 */
+		break;
+	case IV6_VBUFERR:	/* INT8 */
+	case S0_WLINE:		/* INT9 */
+	case S1_VI_VSYNC:	/* INT10 */
+	case S1_LO_VSYNC:	/* INT11 */
+	case S1_VSYNCERR:	/* INT12 */
+	case S1_VFIELD:		/* INT13 */
+	case IV2_VBUFERR:	/* INT14 */
+	case IV4_VBUFERR:	/* INT15 */
+		break;
+	case S1_WLINE:		/* INT16 */
+	case OIR_VI_VSYNC:	/* INT17 */
+	case OIR_LO_VSYNC:	/* INT18 */
+	case OIR_VLINE:		/* INT19 */
+	case OIR_VFIELD:	/* INT20 */
+	case IV7_VBUFERR:	/* INT21 */
+	case IV8_VBUFERR:	/* INT22 */
+		break;
+	default:
+		dev_err(&priv->pdev->dev, "unexpected irq (%d+%d)\n",
+			priv->irq.start, irq);
+		break;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int vdc5fb_init_irqs(struct vdc5fb_priv *priv)
+{
+	int error = -EINVAL;
+	struct platform_device *pdev;
+	struct resource *res;
+	int irq;
+
+	pdev = priv->pdev;
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res)
+		return error;
+
+	priv->irq.start = res->start;
+	priv->irq.end = res->end;
+	BUG_ON((priv->irq.end - priv->irq.start + 1) != VDC5FB_MAX_IRQS);
+
+	for (irq = 0; irq < VDC5FB_MAX_IRQS; irq++) {
+		snprintf(priv->irq.longname[irq],
+			sizeof(priv->irq.longname[0]), "%s: %s",
+			priv->dev_name, irq_names[irq]);
+		error = request_irq((priv->irq.start + irq),
+			vdc5fb_irq, 0, priv->irq.longname[irq], priv);
+		if (error < 0) {
+			while (--irq >= 0)
+				free_irq(priv->irq.start + irq, priv);
+			return error;
+		}
+	}
+
+	return 0;
+}
+
+static void vdc5fb_deinit_irqs(struct vdc5fb_priv *priv)
+{
+	int irq;
+
+	for (irq = priv->irq.start; irq <= priv->irq.end; irq++)
+		free_irq(irq, priv);
+}
+
+/************************************************************************/
+/* CLOCK HANDLING */
+
+static int vdc5fb_init_clocks(struct vdc5fb_priv *priv)
+{
+	static const char clkname_p1clk[] = "peripheral_clk";
+					/* TODO: should be global */
+	static const char clkname_lvds[] = "lvds";
+					/* TODO: should be global */
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	struct platform_device *pdev = priv->pdev;
+
+	priv->clk = clk_get(&pdev->dev, priv->dev_name);
+	if (IS_ERR(priv->clk)) {
+		dev_err(&pdev->dev, "cannot get clock \"%s\"\n",
+			priv->dev_name);
+		return PTR_ERR(priv->clk);
+	}
+
+	priv->dot_clk = clk_get(&pdev->dev, clkname_p1clk);
+	if (IS_ERR(priv->dot_clk)) {
+		dev_err(&pdev->dev, "cannot get clock \"%s\"\n", clkname_p1clk);
+		clk_put(priv->clk);
+		return PTR_ERR(priv->dot_clk);
+	}
+
+	if (pdata->use_lvds) {
+		priv->lvds_clk = clk_get(&pdev->dev, clkname_lvds);
+		if (IS_ERR(priv->lvds_clk)) {
+			dev_err(&pdev->dev, "cannot get clock \"%s\"\n",
+				clkname_lvds);
+			clk_put(priv->clk);
+			clk_put(priv->dot_clk);
+			return PTR_ERR(priv->lvds_clk);
+		}
+	}
+
+	return 0;
+}
+
+static void vdc5fb_deinit_clocks(struct vdc5fb_priv *priv)
+{
+	if (priv->lvds_clk)
+		clk_put(priv->lvds_clk);
+	if (priv->dot_clk)
+		clk_put(priv->dot_clk);
+	if (priv->clk)
+		clk_put(priv->clk);
+}
+
+/************************************************************************/
+
+static void vdc5fb_clear_fb(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	char *start;
+	size_t size;
+
+	start = (char *)priv->info->screen_base;
+	size = pdata->videomode->xres * pdata->videomode->yres
+		* (pdata->bpp / 8);
+
+	/* CODE: WRITE ENABLE SRAM */
+	iowrite8(0xff, IOMEM(0xFCFE0400));
+	iowrite8(0xff, IOMEM(0xFCFE0404));
+	iowrite8(0x0f, IOMEM(0xFCFE0408));
+
+	memset(start, 0x0, size);
+}
+
+static int vdc5fb_update_regs(struct vdc5fb_priv *priv,
+	int reg, uint32_t bits, int wait)
+{
+	uint32_t tmp;
+	long timeout;
+
+	tmp = vdc5fb_read(priv, reg);
+	tmp |= bits;
+	vdc5fb_write(priv, reg, tmp);
+
+	if (wait) {
+		timeout = 50;
+		do {
+			tmp = vdc5fb_read(priv, reg);
+			if ((tmp & bits) == 0)
+				return 0;
+			udelay(1000);
+		} while (--timeout > 0);
+	/* wait for max. 50 ms... */
+	}
+	dev_err(&priv->pdev->dev, "update_regs timeout at %d in %s\n",
+		__LINE__, __func__);
+	return -1;
+}
+
+/************************************************************************/
+
+static int vdc5fb_set_panel_clock(struct vdc5fb_priv *priv,
+	struct fb_videomode *mode)
+{
+	static const unsigned char dcdr_list[13] = {
+		1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 16, 24, 32,
+	};
+	uint64_t desired64 = 1000000000000;
+	unsigned long desired;
+	unsigned long source;
+	unsigned long used;
+	int n;
+
+	source = clk_get_rate(priv->dot_clk);
+	BUG_ON(source == 0);
+
+	(void)do_div(desired64, mode->pixclock);
+	desired = (unsigned long)desired64;
+	for (n = 0; n < ARRAY_SIZE(dcdr_list); n++) {
+		used = source / dcdr_list[n];
+		if (used <= desired) {
+			priv->dcdr = dcdr_list[n];
+			priv->dc = used;
+			return 0;
+		}
+	}
+	return -1;
+}
+
+/************************************************************************/
+
+static int vdc5fb_init_syscnt(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	u32 tmp;
+
+	/* Ignore all irqs here */
+	priv->irq.mask[0] = 0;
+	priv->irq.mask[1] = 0;
+	priv->irq.mask[2] = 0;
+	vdc5fb_write(priv, SYSCNT_INT4, priv->irq.mask[0]);
+	vdc5fb_write(priv, SYSCNT_INT5, priv->irq.mask[1]);
+	vdc5fb_write(priv, SYSCNT_INT6, priv->irq.mask[2]);
+
+	/* Clear all pending irqs */
+	vdc5fb_write(priv, SYSCNT_INT1, 0);
+	vdc5fb_write(priv, SYSCNT_INT2, 0);
+	vdc5fb_write(priv, SYSCNT_INT3, 0);
+
+	/* Setup panel clock */
+	tmp = PANEL_DCDR(priv->dcdr);
+	tmp |= PANEL_ICKEN;
+	tmp |= PANEL_OCKSEL(0);
+	tmp |= PANEL_ICKSEL(pdata->panel_icksel);
+	vdc5fb_write(priv, SYSCNT_PANEL_CLK, tmp);
+
+	return 0;
+}
+
+static int vdc5fb_init_sync(struct vdc5fb_priv *priv)
+{
+	struct fb_videomode *mode = priv->videomode;
+	u32 tmp;
+
+	/* (TODO) Freq. vsync masking and missing vsync
+	 * compensation are not supported.
+	 */
+	vdc5fb_write(priv, SC0_SCL0_FRC1, 0);
+	vdc5fb_write(priv, SC0_SCL0_FRC2, 0);
+	vdc5fb_write(priv, SC1_SCL0_FRC1, 0);
+	vdc5fb_write(priv, SC1_SCL0_FRC2, 0);
+	vdc5fb_write(priv, OIR_SCL0_FRC1, 0);
+	vdc5fb_write(priv, OIR_SCL0_FRC2, 0);
+
+	/* Set the same free-running hsync/vsync period to
+	 * all scalers (sc0, sc1 and oir). The hsync/vsync
+	 * from scaler 0 is used by all scalers.
+	 * (TODO) External input vsync is not supported.
+	 */
+	tmp = SC_RES_FH(priv->res_fh);
+	tmp |= SC_RES_FV(priv->res_fv);
+	vdc5fb_write(priv, SC0_SCL0_FRC4, tmp);
+	vdc5fb_write(priv, SC1_SCL0_FRC4, tmp);
+	vdc5fb_write(priv, OIR_SCL0_FRC4, tmp);
+
+	tmp = (SC_RES_FLD_DLY_SEL | SC_RES_VSDLY(1));
+	vdc5fb_write(priv, SC0_SCL0_FRC5, tmp);
+	vdc5fb_write(priv, SC1_SCL0_FRC5, tmp);
+	tmp = SC_RES_VSDLY(1);
+	vdc5fb_write(priv, OIR_SCL0_FRC5, tmp);
+
+	vdc5fb_write(priv, SC0_SCL0_FRC3, SC_RES_VS_SEL);
+	vdc5fb_write(priv, SC1_SCL0_FRC3, (SC_RES_VS_SEL | SC_RES_VS_IN_SEL));
+	vdc5fb_write(priv, OIR_SCL0_FRC3, 0);
+	/* Note that OIR is not enabled here */
+
+	/* Set full-screen size */
+	tmp = SC_RES_F_VW(mode->yres);
+	tmp |= SC_RES_F_VS(mode->vsync_len + mode->upper_margin);
+	vdc5fb_write(priv, SC0_SCL0_FRC6, tmp);
+	vdc5fb_write(priv, SC1_SCL0_FRC6, tmp);
+	vdc5fb_write(priv, OIR_SCL0_FRC6, tmp);
+	tmp = SC_RES_F_HW(mode->xres);
+	tmp |= SC_RES_F_HS(mode->hsync_len + mode->left_margin);
+	vdc5fb_write(priv, SC0_SCL0_FRC7, tmp);
+	vdc5fb_write(priv, SC1_SCL0_FRC7, tmp);
+	vdc5fb_write(priv, OIR_SCL0_FRC7, tmp);
+
+	/* Cascade on */
+	vdc5fb_setbits(priv, GR1_AB1, GR1_CUS_CON_ON);
+	/* Set GR0 as current, GR1 as underlaying */
+	vdc5fb_setbits(priv, GR_VIN_AB1, GR_VIN_SCL_UND_SEL);
+
+	/* Do update here. */
+	tmp = (SC_SCL_UPDATE | SC_SCL_VEN_B);
+	vdc5fb_update_regs(priv, SC0_SCL0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, SC1_SCL0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, OIR_SCL0_UPDATE, tmp, 1);
+	tmp = (GR_UPDATE | GR_P_VEN);
+	vdc5fb_update_regs(priv, GR1_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GR_VIN_UPDATE, tmp, 1);
+
+	return 0;
+}
+
+static int vdc5fb_init_scalers(struct vdc5fb_priv *priv)
+{
+	struct fb_videomode *mode = priv->videomode;
+	u32 tmp;
+
+	/* Disable scaler 0 */
+	vdc5fb_write(priv, SC0_SCL0_DS1, 0);
+	vdc5fb_write(priv, SC0_SCL0_US1, 0);
+	vdc5fb_write(priv, SC0_SCL0_OVR1, D_SC_RES_BK_COL);
+
+	/* Disable scaler 1 */
+	vdc5fb_write(priv, SC1_SCL0_DS1, 0);
+	vdc5fb_write(priv, SC1_SCL0_US1, 0);
+	vdc5fb_write(priv, SC1_SCL0_OVR1, D_SC_RES_BK_COL);
+
+	/* Enable and setup OIR scaler */
+	vdc5fb_write(priv, OIR_SCL0_FRC3, OIR_RES_EN);
+	vdc5fb_update_regs(priv, OIR_SCL0_UPDATE, SC_SCL_UPDATE, 1);
+
+	vdc5fb_write(priv, OIR_SCL0_DS1, 0);
+	vdc5fb_write(priv, OIR_SCL0_US1, 0);
+	vdc5fb_write(priv, OIR_SCL0_OVR1, D_SC_RES_BK_COL);
+
+	tmp = (mode->vsync_len + mode->upper_margin - 1) << 16;
+	tmp |= mode->yres;
+	vdc5fb_write(priv, OIR_SCL0_DS2, tmp);
+	vdc5fb_write(priv, OIR_SCL0_US2, tmp);
+
+	tmp = (mode->hsync_len + mode->left_margin) << 16;
+	tmp |= mode->xres;
+	vdc5fb_write(priv, OIR_SCL0_DS3, tmp);
+	vdc5fb_write(priv, OIR_SCL0_US3, tmp);
+
+	tmp = mode->yres << 16;
+	tmp |= mode->xres;
+	vdc5fb_write(priv, OIR_SCL0_DS7, tmp);
+
+	tmp = SC_RES_IBUS_SYNC_SEL;
+	vdc5fb_write(priv, OIR_SCL0_US8, tmp);
+
+	return 0;
+}
+
+static int vdc5fb_init_graphics(struct vdc5fb_priv *priv)
+{
+	struct fb_videomode *mode = priv->videomode;
+	u32 tmp;
+
+	/* Graphics 0 (Scaler 0) */
+	vdc5fb_write(priv, GR0_FLM_RD, 0);
+	tmp = vdc5fb_read(priv, GR0_AB1);
+	tmp &= GR_AB1_MASK;
+	tmp |= GR_DISP_SEL(0);		/* background */
+	vdc5fb_write(priv, GR0_AB1, tmp);
+	vdc5fb_write(priv, GR0_BASE, D_GR_BASE);
+
+	/* Graphics 1 (Scaler 1) */
+	vdc5fb_write(priv, GR1_FLM_RD, 0);
+	tmp = vdc5fb_read(priv, GR1_AB1);
+	tmp &= GR_AB1_MASK;
+	tmp |= GR_DISP_SEL(0);		/* background */
+	vdc5fb_write(priv, GR1_AB1, tmp);
+	vdc5fb_write(priv, GR1_BASE, D_GR_BASE);
+
+	/* Graphics 2 (Image Synthsizer) */
+	vdc5fb_write(priv, GR2_FLM_RD, 0);
+	vdc5fb_write(priv, GR2_AB1, GR_DISP_SEL(0));
+	vdc5fb_write(priv, GR3_BASE, D_GR_BASE);
+
+	/* Graphics 3 (Image Synthsizer) */
+	vdc5fb_write(priv, GR3_FLM_RD, 0);
+	vdc5fb_write(priv, GR3_AB1, GR_DISP_SEL(0));
+	vdc5fb_write(priv, GR2_BASE, D_GR_BASE);
+
+	/* Graphics VIN (Image Synthsizer) */
+	tmp = vdc5fb_read(priv, GR_VIN_AB1);
+	tmp &= GR_AB1_MASK;
+	tmp |= GR_DISP_SEL(0);		/* background */
+	vdc5fb_write(priv, GR_VIN_AB1, tmp);
+	vdc5fb_write(priv, GR_VIN_BASE, D_GR_BASE);
+
+	/* Graphics OIR */
+	vdc5fb_write(priv, GR_OIR_FLM_RD, GR_R_ENB);
+	vdc5fb_write(priv, GR_OIR_FLM1, GR_FLM_SEL(1));
+	vdc5fb_write(priv, GR_OIR_FLM2, priv->dma_handle);
+	tmp = GR_FLM_NUM(priv->flm_num);
+	tmp |= GR_LN_OFF(mode->xres * (priv->info->var.bits_per_pixel / 8));
+	vdc5fb_write(priv, GR_OIR_FLM3, tmp);
+	tmp = GR_FLM_OFF(priv->flm_off);
+	vdc5fb_write(priv, GR_OIR_FLM4, tmp);
+	tmp = GR_FLM_LOOP(mode->yres - 1);
+	tmp |= GR_FLM_LNUM(mode->yres - 1);
+	vdc5fb_write(priv, GR_OIR_FLM5, tmp);
+	if (priv->info->var.bits_per_pixel == 16)
+		tmp = D_GR_FLM6_RGB565;		/* RGB565 LE, 78563412 */
+	else
+		tmp = D_GR_FLM6_ARGB8888;	/* ARGB8888 LE, 56781234 */
+	tmp |= GR_HW(mode->xres - 1);
+	vdc5fb_write(priv, GR_OIR_FLM6, tmp);
+
+	tmp = vdc5fb_read(priv, GR_OIR_AB1);
+	tmp &= GR_AB1_MASK;
+	tmp |= GR_DISP_SEL(2);		/* current graphics */
+	vdc5fb_write(priv, GR_OIR_AB1, tmp);
+
+	tmp = GR_GRC_VW(mode->yres);
+	tmp |= GR_GRC_VS(mode->vsync_len + mode->upper_margin);
+	vdc5fb_write(priv, GR_OIR_AB2, tmp);
+
+	tmp = GR_GRC_HW(mode->xres);
+	tmp |= GR_GRC_HS(mode->hsync_len + mode->left_margin);
+	vdc5fb_write(priv, GR_OIR_AB3, tmp);
+
+	vdc5fb_write(priv, GR_OIR_AB7, 0);
+	vdc5fb_write(priv, GR_OIR_AB8, D_GR_AB8);
+	vdc5fb_write(priv, GR_OIR_AB9, D_GR_AB9);
+	vdc5fb_write(priv, GR_OIR_AB10, D_GR_AB10);
+	vdc5fb_write(priv, GR_OIR_AB11, D_GR_AB11);
+
+	vdc5fb_write(priv, GR_OIR_BASE, D_GR_BASE);
+
+	return 0;
+}
+
+static int vdc5fb_init_outcnt(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	u32 tmp;
+
+	vdc5fb_write(priv, OUT_CLK_PHASE, D_OUT_CLK_PHASE);
+	vdc5fb_write(priv, OUT_BRIGHT1, PBRT_G(512));
+	vdc5fb_write(priv, OUT_BRIGHT2, (PBRT_B(512) | PBRT_R(512)));
+	tmp = (CONT_G(128) | CONT_B(128) | CONT_R(128));
+	vdc5fb_write(priv, OUT_CONTRAST, tmp);
+
+	vdc5fb_write(priv, GAM_SW, 0);
+
+	tmp = D_OUT_PDTHA;
+	tmp |= PDTHA_FORMAT(0);
+	vdc5fb_write(priv, OUT_PDTHA, tmp);
+
+	tmp = D_OUT_SET;
+	tmp |= OUT_FORMAT(pdata->out_format);
+	vdc5fb_write(priv, OUT_SET, tmp);
+
+	return 0;
+}
+
+static int vdc5fb_init_tcon(struct vdc5fb_priv *priv)
+{
+	static const unsigned char tcon_sel[LCD_MAX_TCON]
+		= { 0, 1, 2, 7, 4, 5, 6, };
+	struct fb_videomode *mode = priv->videomode;
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	u32 vs_s, vs_w, ve_s, ve_w;
+	u32 hs_s, hs_w, he_s, he_w;
+	u32 tmp1, tmp2;
+
+	tmp1 = TCON_OFFSET(0);
+	tmp1 |= TCON_HALF(priv->res_fh / 2);
+	vdc5fb_write(priv, TCON_TIM, tmp1);
+	tmp2 = 0;
+#if 0
+	tmp2 = TCON_DE_INV;
+#endif
+	vdc5fb_write(priv, TCON_TIM_DE, tmp2);
+
+	vs_s = (2 * 0);
+	vs_w = (2 * mode->vsync_len);
+	ve_s = (2 * (mode->vsync_len + mode->upper_margin));
+	ve_w = (2 * mode->yres);
+
+	tmp1 = TCON_VW(vs_w);
+	tmp1 |= TCON_VS(vs_s);
+	vdc5fb_write(priv, TCON_TIM_STVA1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON0] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON0]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON0]);
+	if (!(mode->sync & FB_SYNC_VERT_HIGH_ACT))
+		tmp2 |= TCON_INV;
+	vdc5fb_write(priv, TCON_TIM_STVA2, tmp2);
+
+	tmp1 = TCON_VW(ve_w);
+	tmp1 |= TCON_VS(ve_s);
+	vdc5fb_write(priv, TCON_TIM_STVB1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON1] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON1]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON1]);
+#if 0
+	tmp2 |= TCON_INV;
+#endif
+	vdc5fb_write(priv, TCON_TIM_STVB2, tmp2);
+
+	hs_s = 0;
+	hs_w = mode->hsync_len;
+	he_s = (mode->hsync_len + mode->left_margin);
+	he_w = mode->xres;
+
+	tmp1 = TCON_HW(hs_w);
+	tmp1 |= TCON_HS(hs_s);
+	vdc5fb_write(priv, TCON_TIM_STH1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON2] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON2]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON2]);
+	if (!(mode->sync & FB_SYNC_HOR_HIGH_ACT))
+		tmp2 |= TCON_INV;
+#if 0
+	tmp2 |= TCON_HS_SEL;
+#endif
+	vdc5fb_write(priv, TCON_TIM_STH2, tmp2);
+
+	tmp1 = TCON_HW(he_w);
+	tmp1 |= TCON_HS(he_s);
+	vdc5fb_write(priv, TCON_TIM_STB1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON3] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON3]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON3]);
+#if 0
+	tmp2 |= TCON_INV;
+	tmp2 |= TCON_HS_SEL;
+#endif
+	vdc5fb_write(priv, TCON_TIM_STB2, tmp2);
+
+	tmp1 = TCON_HW(hs_w);
+	tmp1 |= TCON_HS(hs_s);
+	vdc5fb_write(priv, TCON_TIM_CPV1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON4] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON4]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON4]);
+#if 0
+	tmp2 |= TCON_INV;
+	tmp2 |= TCON_HS_SEL;
+#endif
+	vdc5fb_write(priv, TCON_TIM_CPV2, tmp2);
+
+	tmp1 = TCON_HW(he_w);
+	tmp1 |= TCON_HS(he_s);
+	vdc5fb_write(priv, TCON_TIM_POLA1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON5] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON5]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON5]);
+#if 0
+	tmp2 |= TCON_HS_SEL;
+	tmp2 |= TCON_INV;
+	tmp2 |= TCON_MD;
+#endif
+	vdc5fb_write(priv, TCON_TIM_POLA2, tmp2);
+
+	tmp1 = TCON_HW(he_w);
+	tmp1 |= TCON_HS(he_s);
+	vdc5fb_write(priv, TCON_TIM_POLB1, tmp1);
+	if (pdata->tcon_sel[LCD_TCON6] == TCON_SEL_UNUSED)
+		tmp2 = TCON_SEL(tcon_sel[LCD_TCON6]);
+	else
+		tmp2 = TCON_SEL(pdata->tcon_sel[LCD_TCON6]);
+#if 0
+	tmp2 |= TCON_INV;
+	tmp2 |= TCON_HS_SEL;
+	tmp2 |= TCON_MD;
+#endif
+	vdc5fb_write(priv, TCON_TIM_POLB2, tmp2);
+
+	return 0;
+}
+
+static int vdc5fb_update_all(struct vdc5fb_priv *priv)
+{
+	u32 tmp;
+
+	tmp = IMGCNT_VEN;
+	vdc5fb_update_regs(priv, IMGCNT_UPDATE, tmp, 1);
+
+	tmp = (SC_SCL_VEN_A | SC_SCL_VEN_B | SC_SCL_UPDATE
+		| SC_SCL_VEN_C | SC_SCL_VEN_D);
+	vdc5fb_update_regs(priv, SC0_SCL0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, SC0_SCL1_UPDATE, tmp, 1);
+
+	tmp = (GR_IBUS_VEN | GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GR1_UPDATE, tmp, 1);
+
+	tmp = ADJ_VEN;
+	vdc5fb_write(priv, ADJ0_UPDATE, tmp);
+	vdc5fb_write(priv, ADJ1_UPDATE, tmp);
+
+	tmp = (GR_IBUS_VEN | GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR2_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GR3_UPDATE, tmp, 1);
+
+	tmp = (GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR_VIN_UPDATE, tmp, 1);
+
+	tmp = (SC_SCL_VEN_A | SC_SCL_VEN_B | SC_SCL_UPDATE
+		| SC_SCL_VEN_C | SC_SCL_VEN_D);
+	vdc5fb_update_regs(priv, OIR_SCL0_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, OIR_SCL1_UPDATE, tmp, 1);
+
+	tmp = (GR_IBUS_VEN | GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR_OIR_UPDATE, tmp, 1);
+
+	tmp = OUTCNT_VEN;
+	vdc5fb_update_regs(priv, OUT_UPDATE, tmp, 1);
+	tmp = GAM_VEN;
+	vdc5fb_update_regs(priv, GAM_G_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GAM_B_UPDATE, tmp, 1);
+	vdc5fb_update_regs(priv, GAM_R_UPDATE, tmp, 1);
+	tmp = TCON_VEN;
+	vdc5fb_update_regs(priv, TCON_UPDATE, tmp, 1);
+
+	return 0;
+}
+
+static void vdc5fb_set_videomode(struct vdc5fb_priv *priv,
+	struct fb_videomode *new, int bits_per_pixel)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	struct fb_videomode *mode = pdata->videomode;
+	u32 tmp;
+
+	if (new)
+		mode = new;
+	priv->videomode = mode;
+
+	if (priv->info->screen_base)	/* sanity check */
+		vdc5fb_clear_fb(priv);
+
+	if (vdc5fb_set_panel_clock(priv, mode) < 0)
+		dev_err(&priv->pdev->dev, "cannot get dcdr\n");
+
+	dev_info(&priv->pdev->dev,
+		"%s: [%s] dotclock %lu.%03u MHz, dcdr %u\n",
+		priv->dev_name, pdata->name,
+		(priv->dc / 1000000),
+		(unsigned int)((priv->dc % 1000000) / 1000),
+		priv->dcdr);
+
+	priv->res_fh = mode->hsync_len + mode->left_margin + mode->xres
+		+ mode->right_margin;
+	priv->res_fv = mode->vsync_len + mode->upper_margin + mode->yres
+		+ mode->lower_margin;
+	priv->rr = (priv->dc / (priv->res_fh * priv->res_fv));
+
+	tmp =  mode->xres * mode->yres * (bits_per_pixel / 8);
+	priv->flm_off = tmp & ~0xfff;	/* page align */
+	if (tmp & 0xfff)
+		priv->flm_off += 0x1000;
+	priv->flm_num = 0;
+
+	vdc5fb_init_syscnt(priv);
+	vdc5fb_init_sync(priv);
+	vdc5fb_init_scalers(priv);
+	vdc5fb_init_graphics(priv);
+	vdc5fb_init_outcnt(priv);
+	vdc5fb_init_tcon(priv);
+
+	vdc5fb_update_all(priv);
+
+	vdc5fb_clear_fb(priv);
+}
+
+/************************************************************************/
+
+static int vdc5fb_put_bright(struct vdc5fb_priv *priv,
+	struct fbio_bright *param)
+{
+	uint32_t tmp;
+
+	tmp = PBRT_G(param->pbrt_g);
+	vdc5fb_write(priv, OUT_BRIGHT1, tmp);
+	tmp = PBRT_B(param->pbrt_b);
+	tmp |= PBRT_R(param->pbrt_r);
+	vdc5fb_write(priv, OUT_BRIGHT2, tmp);
+	vdc5fb_update_regs(priv, OUT_UPDATE, OUTCNT_VEN, 1);
+
+	return 0;
+}
+
+static int vdc5fb_get_bright(struct vdc5fb_priv *priv,
+	struct fbio_bright *param)
+{
+	uint32_t tmp;
+
+	tmp = vdc5fb_read(priv, OUT_BRIGHT1);
+	param->pbrt_g = (tmp & 0x3ffu);
+	tmp = vdc5fb_read(priv, OUT_BRIGHT2);
+	param->pbrt_b = ((tmp >> 16) & 0x3ffu);
+	param->pbrt_r = (tmp & 0x3ffu);
+
+	return 0;
+}
+
+static int vdc5fb_put_contrast(struct vdc5fb_priv *priv,
+	struct fbio_contrast *param)
+{
+	uint32_t tmp;
+
+	tmp = CONT_G(param->cont_g);
+	tmp |= CONT_B(param->cont_b);
+	tmp |= CONT_R(param->cont_r);
+	vdc5fb_write(priv, OUT_CONTRAST, tmp);
+	vdc5fb_update_regs(priv, OUT_UPDATE, OUTCNT_VEN, 1);
+
+	return 0;
+}
+
+static int vdc5fb_get_contrast(struct vdc5fb_priv *priv,
+	struct fbio_contrast *param)
+{
+	uint32_t tmp;
+
+	tmp = vdc5fb_read(priv, OUT_CONTRAST);
+	param->cont_g = ((tmp >> 16) & 0xffu);
+	param->cont_b = ((tmp >> 8) & 0xffu);
+	param->cont_r = (tmp & 0xffu);
+
+	return 0;
+}
+
+static int vdc5fb_put_frame(struct vdc5fb_priv *priv,
+	struct fbio_frame *param)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	uint32_t tmp;
+
+	if (param->fr_num >= pdata->flm_max)
+		return -EINVAL;
+
+	tmp = vdc5fb_read(priv, GR_OIR_FLM3);
+	tmp &= ~0x3ffu;
+	tmp |= GR_FLM_NUM(param->fr_num);
+	vdc5fb_write(priv, GR_OIR_FLM3, tmp);
+	vdc5fb_update_regs(priv, GR_OIR_UPDATE, GR_IBUS_VEN, 1);
+
+	return 0;
+}
+
+static int vdc5fb_get_frame(struct vdc5fb_priv *priv,
+	struct fbio_frame *param)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	uint32_t tmp;
+
+	tmp = vdc5fb_read(priv, GR_OIR_FLM3);
+	param->fr_max = pdata->flm_max;
+	param->fr_num = (tmp & 0x3ffu);
+
+	return 0;
+}
+
+/************************************************************************/
+
+static int vdc5fb_setcolreg(u_int regno,
+	u_int red, u_int green, u_int blue,
+	u_int transp, struct fb_info *info)
+{
+	u32 *palette = info->pseudo_palette;
+
+	if (regno >= PALETTE_NR)
+		return -EINVAL;
+
+	/* only FB_VISUAL_TRUECOLOR supported */
+	red    >>= 16 - info->var.red.length;
+	green  >>= 16 - info->var.green.length;
+	blue   >>= 16 - info->var.blue.length;
+	transp >>= 16 - info->var.transp.length;
+
+	palette[regno] = (red << info->var.red.offset) |
+		(green << info->var.green.offset) |
+		(blue << info->var.blue.offset) |
+		(transp << info->var.transp.offset);
+
+	return 0;
+}
+
+static int vdc5fb_ioctl(struct fb_info *info, unsigned int cmd,
+	unsigned long arg)
+{
+	struct vdc5fb_priv *priv = (struct vdc5fb_priv *)info->par;
+
+	switch (cmd) {
+	case FBIOGET_VSCREENINFO:	/* 0x00 */
+	case FBIOGET_FSCREENINFO:	/* 0x02 */
+		/* done by framework */
+		break;
+	case FBIOPUT_VSCREENINFO:	/* 0x01 */
+		break;
+
+	case FBIOPAN_DISPLAY:		/* 0x06 */
+		break;
+
+	case FBIOGETCMAP:		/* 0x04 */
+	case FBIOPUTCMAP:		/* 0x05 */
+	case FBIO_CURSOR:		/* 0x08 */
+	case FBIOGET_CON2FBMAP:		/* 0x0F */
+	case FBIOPUT_CON2FBMAP:		/* 0x10 */
+	case FBIOBLANK:			/* 0x11 */
+	/* Done by higher, NG */
+		break;
+
+	case FBIOGET_VBLANK:		/* 0x12 */
+	case FBIO_ALLOC:		/* 0x13 */
+	case FBIO_FREE:			/* 0x14 */
+	case FBIOGET_GLYPH:		/* 0x15 */
+	case FBIOGET_HWCINFO:		/* 0x16 */
+	case FBIOPUT_MODEINFO:		/* 0x17 */
+	case FBIOGET_DISPINFO:		/* 0x18 */
+	case FBIO_WAITFORVSYNC:		/* 0x20 */
+	/* Done by higher, NG (not supported) */
+	/* vdc5fb_ioctl is also called */
+		return -EINVAL;
+		break;
+
+	default:
+	/* 0x03, 0x07, 0x09-0x0E, 0x19-0x1F, 0x21- (unknown) */
+	/* vdc5fb_ioctl is called */
+		return -EINVAL;
+		break;
+
+	case FBIOPUT_BRIGHT:
+		{
+			struct fbio_bright bright;
+
+			if (copy_from_user(&bright, (void __user *)arg,
+				sizeof(bright)))
+				return -EFAULT;
+			if (bright.pbrt_r > 1023)
+				bright.pbrt_r = 1023;
+			if (bright.pbrt_g > 1023)
+				bright.pbrt_g = 1023;
+			if (bright.pbrt_b > 1023)
+				bright.pbrt_b = 1023;
+			return vdc5fb_put_bright(priv, &bright);
+		}
+	case FBIOGET_BRIGHT:
+		{
+			struct fbio_bright bright;
+			int ret;
+
+			ret = vdc5fb_get_bright(priv, &bright);
+			if (ret < 0)
+				return ret;
+			if (copy_to_user((void __user *)arg, &bright,
+				sizeof(bright)))
+				return -EFAULT;
+			return 0;
+		}
+
+	case FBIOPUT_CONTRAST:
+		{
+			struct fbio_contrast contrast;
+
+			if (copy_from_user(&contrast, (void __user *)arg,
+				sizeof(contrast)))
+				return -EFAULT;
+			if (contrast.cont_r > 255)
+				contrast.cont_r = 255;
+			if (contrast.cont_g > 255)
+				contrast.cont_g = 255;
+			if (contrast.cont_b > 255)
+				contrast.cont_b = 255;
+			return vdc5fb_put_contrast(priv, &contrast);
+		}
+	case FBIOGET_CONTRAST:
+		{
+			struct fbio_contrast contrast;
+			int ret;
+
+			ret = vdc5fb_get_contrast(priv, &contrast);
+			if (ret < 0)
+				return ret;
+			if (copy_to_user((void __user *)arg, &contrast,
+				sizeof(contrast)))
+				return -EFAULT;
+			return 0;
+		}
+	case FBIOPUT_FRAME:
+		{
+			struct fbio_frame frame;
+
+			if (copy_from_user(&frame, (void __user *)arg,
+				sizeof(frame)))
+				return -EFAULT;
+			return vdc5fb_put_frame(priv, &frame);
+		}
+	case FBIOGET_FRAME:
+		{
+			struct fbio_frame frame;
+			int ret;
+
+			ret = vdc5fb_get_frame(priv, &frame);
+			if (ret < 0)
+				return ret;
+			if (copy_to_user((void __user *)arg, &frame,
+				sizeof(frame)))
+				return -EFAULT;
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+static struct fb_fix_screeninfo vdc5fb_fix = {
+	.id		= "vdc5fb",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_TRUECOLOR,
+	.accel		= FB_ACCEL_NONE,
+};
+
+static int vdc5fb_check_var(struct fb_var_screeninfo *var,
+	struct fb_info *info)
+{
+/*	struct fb_fix_screeninfo *fix = &info->fix;	*/
+	struct vdc5fb_priv *priv = info->par;
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+
+	if (var->xres != pdata->videomode->xres)
+		return -EINVAL;
+	if (var->xres_virtual != pdata->videomode->xres)
+		return -EINVAL;
+	if (var->yres != pdata->videomode->yres)
+		return -EINVAL;
+	return 0;
+}
+
+static int vdc5fb_set_par(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct vdc5fb_priv *priv = info->par;
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	struct fb_videomode mode;
+
+/*	pm_runtime_get_sync();	*/
+
+	memcpy(&mode, pdata->videomode, sizeof(mode));
+	mode.name = NULL;
+	mode.refresh = 0;
+/*	mode.xres = var->xres;		*/
+/*	mode.yres = var->yres;		*/
+	mode.pixclock = var->pixclock;
+	mode.left_margin = var->left_margin;
+	mode.right_margin = var->right_margin;
+	mode.upper_margin = var->upper_margin;
+	mode.lower_margin = var->lower_margin;
+	mode.hsync_len = var->hsync_len;
+	mode.vsync_len = var->vsync_len;
+	mode.sync = var->sync;
+/*	mode.vmode = var->vmode;	*/
+	mode.flag = 0;
+
+	vdc5fb_set_videomode(priv, &mode, var->bits_per_pixel);
+
+/*	pm_runtime_put_sync();	*/
+	return 0;
+}
+
+static int vdc5fb_pan_display(struct fb_var_screeninfo *var,
+	struct fb_info *info)
+{
+	struct vdc5fb_priv *priv = info->par;
+	unsigned long start, end;
+	u32 tmp;
+/*	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);	*/
+
+/*	pm_runtime_get_sync();	*/
+
+	start = var->yoffset * info->fix.line_length;
+	start += var->xoffset * (info->var.bits_per_pixel >> 3);
+	end = start + info->var.yres * info->fix.line_length;
+
+	if (end > priv->fbsize)
+		return -EINVAL;
+
+	vdc5fb_write(priv, GR_OIR_FLM2, priv->dma_handle + start);
+	tmp = (GR_IBUS_VEN | GR_P_VEN | GR_UPDATE);
+	vdc5fb_update_regs(priv, GR_OIR_UPDATE, tmp, 1);
+
+/*	pm_runtime_put_sync();	*/
+	return 0;
+}
+
+static struct fb_ops vdc5fb_ops = {
+	.owner          = THIS_MODULE,
+	.fb_read        = fb_sys_read,
+	.fb_write       = fb_sys_write,
+	.fb_check_var	= vdc5fb_check_var,
+	.fb_set_par	= vdc5fb_set_par,
+	.fb_setcolreg	= vdc5fb_setcolreg,
+	.fb_fillrect	= sys_fillrect,
+	.fb_copyarea	= sys_copyarea,
+	.fb_imageblit	= sys_imageblit,
+	.fb_pan_display	= vdc5fb_pan_display,
+	.fb_ioctl	= vdc5fb_ioctl,
+};
+
+static int vdc5fb_set_bpp(struct fb_var_screeninfo *var, int bpp)
+{
+	switch (bpp) {
+	case 16: /* RGB 565 */
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 32: /* ARGB 8888 */
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->red.offset = 16;
+		var->red.length = 8;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		break;
+	default:
+		return -EINVAL;
+	}
+	var->bits_per_pixel = bpp;
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+	return 0;
+}
+
+static int vdc5fb_start(struct vdc5fb_priv *priv)
+{
+	struct vdc5fb_pdata *pdata = priv_to_pdata(priv);
+	int error;
+
+	if (pdata->pinmux) {
+		if (pdata->pinmux(priv->pdev) < 0) {
+			dev_err(&priv->pdev->dev, "cannot setup pinmux\n");
+			return -EIO;
+		}
+	}
+
+	error = clk_enable(priv->clk);
+	if (error < 0)
+		return error;
+
+	if (priv->dot_clk) {
+		error = clk_enable(priv->dot_clk);
+		if (error < 0)
+			return error;
+	}
+
+	return error;
+}
+
+static void vdc5fb_stop(struct vdc5fb_priv *priv)
+{
+	if (priv->dot_clk)
+		clk_disable(priv->dot_clk);
+	clk_disable(priv->clk);
+}
+
+static int vdc5fb_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	vdc5fb_stop(platform_get_drvdata(pdev));
+	return 0;
+}
+
+static int vdc5fb_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return vdc5fb_start(platform_get_drvdata(pdev));
+}
+
+static const struct dev_pm_ops vdc5fb_dev_pm_ops = {
+	.suspend = vdc5fb_suspend,
+	.resume = vdc5fb_resume,
+};
+
+static int vdc5fb_probe(struct platform_device *pdev)
+{
+	int error = -EINVAL;
+	struct vdc5fb_priv *priv = NULL;
+	struct vdc5fb_pdata *pdata;
+	struct fb_info *info;
+	struct resource *res;
+	void *buf;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "cannot allocate private data\n");
+		error = -ENOMEM;
+		goto err0;
+	}
+	platform_set_drvdata(pdev, priv);
+	priv->pdev = pdev;
+	priv->dev_name = dev_name(&pdev->dev);
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "cannot get platform data\n");
+		goto err1;
+	}
+	priv->pdata = pdata;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "cannot get resources (reg)\n");
+		goto err1;
+	}
+	priv->base = ioremap_nocache(res->start, resource_size(res));
+	priv->fbsize = resource_size(res);
+	if (!priv->base) {
+		dev_err(&pdev->dev, "cannot ioremap (reg)\n");
+		goto err1;
+	}
+
+	error = vdc5fb_init_clocks(priv);
+	if (error) {
+		dev_err(&pdev->dev, "cannot init clocks\n");
+		goto err1;
+	}
+
+	error = vdc5fb_init_irqs(priv);
+	if (error < 0) {
+		dev_err(&pdev->dev, "cannot init irqs\n");
+		goto err1;
+	}
+
+	info = framebuffer_alloc(0, &pdev->dev);
+	if (!info) {
+		dev_err(&pdev->dev, "cannot allocate fb_info\n");
+		goto err1;
+	}
+	priv->info = info;
+
+	info->fbops = &vdc5fb_ops;
+	INIT_LIST_HEAD(&info->modelist);
+	fb_add_videomode(pdata->videomode, &info->modelist);
+
+	info->var.xres = info->var.xres_virtual = pdata->videomode->xres;
+	info->var.yres = info->var.yres_virtual = pdata->videomode->yres;
+	info->var.width = pdata->panel_width;
+	info->var.height = pdata->panel_height;
+	info->var.activate = FB_ACTIVATE_NOW;
+	info->pseudo_palette = priv->pseudo_palette;
+	error = vdc5fb_set_bpp(&info->var, pdata->bpp);
+	if (error) {
+		dev_err(&pdev->dev, "cannot set bpp\n");
+		goto err2;
+	}
+
+	info->fix = vdc5fb_fix;
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+	info->fix.type_aux = 0;
+	info->fix.line_length = info->var.xres * (info->var.bits_per_pixel / 8);
+	info->fix.smem_len = info->fix.line_length * info->var.yres;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&pdev->dev, "cannot get resources (fb)\n");
+		goto err2;
+	}
+	if (res->start) {
+		if ((res->end - res->start + 1) < info->fix.smem_len)
+			goto err2;
+		priv->dma_handle = res->start;
+		buf = ioremap_nocache(res->start,
+			(res->end - res->start + 1));
+		priv->fb_nofree = 1;
+	} else {
+		buf = dma_alloc_writecombine(&pdev->dev, info->fix.smem_len,
+			&priv->dma_handle, GFP_KERNEL);
+		priv->fb_nofree = 0;
+		if (!buf) {
+			dev_err(&pdev->dev, "cannot allocate buffer\n");
+			goto err2;
+		}
+	}
+	info->flags = FBINFO_FLAG_DEFAULT;
+
+	error = fb_alloc_cmap(&info->cmap, PALETTE_NR, 0);
+	if (error < 0) {
+		dev_err(&pdev->dev, "cannot allocate cmap\n");
+		goto err3;
+	}
+
+	info->fix.smem_start = priv->dma_handle;
+	info->screen_base = buf;
+	info->device = &pdev->dev;
+	info->par = priv;
+
+	info->var.xres_virtual = info->var.xres;
+	info->var.yres_virtual = info->var.yres;
+	info->var.xoffset = 0;
+	info->var.yoffset = 0;
+	info->var.pixclock = pdata->videomode->pixclock;
+	info->var.sync = 0;
+	info->var.grayscale = 0;
+	info->var.accel_flags = 0;
+	info->var.left_margin = pdata->videomode->left_margin;
+	info->var.right_margin = pdata->videomode->right_margin;
+	info->var.upper_margin = pdata->videomode->upper_margin;
+	info->var.lower_margin = pdata->videomode->lower_margin;
+	info->var.hsync_len = pdata->videomode->hsync_len;
+	info->var.vsync_len = pdata->videomode->vsync_len;
+
+	error = vdc5fb_start(priv);
+	if (error) {
+		dev_err(&pdev->dev, "cannot start hardware\n");
+		goto err4;
+	}
+
+	error = register_framebuffer(info);
+	if (error < 0)
+		goto err5;
+
+	dev_info(info->dev,
+		"registered %s as %ux%u @ %u Hz, %d bpp.\n",
+		priv->dev_name,
+		info->var.xres,
+		info->var.yres,
+		priv->rr,
+		info->var.bits_per_pixel);
+
+	return 0;
+
+err5:
+	unregister_framebuffer(priv->info);
+err4:
+	vdc5fb_stop(priv);
+err3:
+	fb_dealloc_cmap(&info->cmap);
+	if (priv->fb_nofree)
+		iounmap(priv->base);
+	else
+		dma_free_writecombine(&pdev->dev, info->fix.smem_len,
+			info->screen_base, info->fix.smem_start);
+err2:
+	fb_destroy_modelist(&info->modelist);
+	framebuffer_release(info);
+	vdc5fb_deinit_irqs(priv);
+	vdc5fb_deinit_clocks(priv);
+err1:
+	kfree(priv);
+err0:
+	return error;
+}
+
+static int vdc5fb_remove(struct platform_device *pdev)
+{
+	struct vdc5fb_priv *priv = platform_get_drvdata(pdev);
+	struct fb_info *info;
+
+	if (priv->info->dev)
+		unregister_framebuffer(priv->info);
+
+	vdc5fb_stop(priv);
+
+	info = priv->info;
+
+	fb_dealloc_cmap(&info->cmap);
+	if (priv->fb_nofree)
+		iounmap(priv->base);
+	else
+		dma_free_writecombine(&pdev->dev, info->fix.smem_len,
+			info->screen_base, info->fix.smem_start);
+
+	fb_destroy_modelist(&info->modelist);
+	framebuffer_release(info);
+	vdc5fb_deinit_irqs(priv);
+	vdc5fb_deinit_clocks(priv);
+
+	kfree(priv);
+
+	return 0;
+}
+
+static struct platform_driver vdc5fb_driver = {
+	.driver		= {
+		.name		= "vdc5fb",
+		.owner		= THIS_MODULE,
+		.pm		= &vdc5fb_dev_pm_ops,
+	},
+	.probe		= vdc5fb_probe,
+	.remove		= vdc5fb_remove,
+};
+
+static int __init vdc5fb_init(void)
+{
+	return platform_driver_register(&vdc5fb_driver);
+}
+
+static void __exit vdc5fb_exit(void)
+{
+	platform_driver_unregister(&vdc5fb_driver);
+}
+
+module_init(vdc5fb_init);
+module_exit(vdc5fb_exit);
+
+MODULE_DESCRIPTION("Renesas VDC5 Framebuffer driver");
+MODULE_AUTHOR("Phil Edworthy <phil.edworthy@renesas.com>");
+MODULE_LICENSE("GPL v2");
+
diff --git a/include/clocksource/sh_ostm.h b/include/clocksource/sh_ostm.h
new file mode 100644
index 0000000..f61ce1e
--- /dev/null
+++ b/include/clocksource/sh_ostm.h
@@ -0,0 +1,35 @@
+/*
+ * RZ/A1 Timer Driver - OSTM
+ *
+ * Copyright (C) 2014 Renesas Solutions Corp.
+ *
+ * Based on include/linux/sh_timer.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _RZA1_OSTM_H_
+#define _RZA1_OSTM_H_
+
+struct rza1_ostm_pdata {
+	struct {
+		char *name;
+		unsigned long rating;
+	} clksrc;
+	struct {
+		char *name;
+		unsigned long rating;
+	} clkevt;
+};
+
+#endif /* _RZA1_OSTM_H_ */
diff --git a/include/linux/i2c-riic.h b/include/linux/i2c-riic.h
new file mode 100644
index 0000000..9d144b3
--- /dev/null
+++ b/include/linux/i2c-riic.h
@@ -0,0 +1,31 @@
+/*
+ * i2c-riic.h
+ * Copyright (c) 2014 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _LINUX_I2C_RIIC_H
+#define _LINUX_I2C_RIIC_H
+
+/**
+ * struct riic_i2c_platform_data - Platform data of Renesas I2C Driver
+ * @bus_rate:		Frequency of bus clock in Hz
+ *
+ */
+struct riic_platform_data {
+	u32	bus_rate;
+};
+
+#endif /* _LINUX_I2C_RIIC_H */
diff --git a/include/linux/i2c/riic_rza1.h b/include/linux/i2c/riic_rza1.h
new file mode 100644
index 0000000..e2010bc
--- /dev/null
+++ b/include/linux/i2c/riic_rza1.h
@@ -0,0 +1,42 @@
+/*
+ * RIIC bus driver
+ *
+ * Copyright (C) 2011-2013  Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _RIIC_H_
+#define _RIIC_H_
+
+struct riic_platform_data {
+	int	clock;		/* i2c clock (kHZ) */
+};
+
+struct riic_core_packet {
+	unsigned short slave_address;
+	void *data;
+	int len;
+	int buf_idx;
+	unsigned char rw;
+#define RIIC_CORE_RW_MASTER_TRANSMIT	0
+#define RIIC_CORE_RW_MASTER_RECEIVE	1
+#define RIIC_CORE_RW_SLAVE_TRANSMIT	2
+#define RIIC_CORE_RW_SLAVE_RECEIVE	3
+
+	unsigned done:1;
+};
+
+#endif
diff --git a/include/linux/platform_data/dma-rza1.h b/include/linux/platform_data/dma-rza1.h
new file mode 100644
index 0000000..61f0a74
--- /dev/null
+++ b/include/linux/platform_data/dma-rza1.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_RZA1_DMA_H__
+#define __ASM_ARCH_RZA1_DMA_H__
+
+#include <linux/scatterlist.h>
+#include <linux/device.h>
+#include <linux/dmaengine.h>
+
+/* DMA slave IDs */
+enum {
+	RZA1DMA_SLAVE_PCM_MEM_SSI0 = 1,	/* DMA0		MEM->(DMA0)->SSI0 */
+	RZA1DMA_SLAVE_PCM_MEM_SRC1,		/* DMA1		MEM->(DMA1)->FFD0_1->SRC1->SSI0 */
+	RZA1DMA_SLAVE_PCM_SSI0_MEM,		/* DMA2		SSI0->(DMA2)->MEM */
+	RZA1DMA_SLAVE_PCM_SRC0_MEM,		/* DMA3		SSI0->SRC0->FFU0_0->(DMA3)->MEM */
+	RZA1DMA_SLAVE_PCM_MAX,
+	RZA1DMA_SLAVE_SDHI0_TX,
+	RZA1DMA_SLAVE_SDHI0_RX,
+	RZA1DMA_SLAVE_SDHI1_TX,
+	RZA1DMA_SLAVE_SDHI1_RX,
+	RZA1DMA_SLAVE_MMCIF_TX,
+	RZA1DMA_SLAVE_MMCIF_RX,
+};
+
+struct chcfg_reg {
+	u32	reqd:1;
+	u32	loen:1;
+	u32	hien:1;
+	u32	lvl:1;
+	u32	am:3;
+	u32	sds:4;
+	u32	dds:4;
+	u32	tm:1;
+};
+
+struct dmars_reg {
+	u32	rid:2;
+	u32	mid:7;
+};
+
+/*
+ * Drivers, using this library are expected to embed struct shdma_dev,
+ * struct shdma_chan, struct shdma_desc, and struct shdma_slave
+ * in their respective device, channel, descriptor and slave objects.
+ */
+
+struct rza1dma_slave {
+	int slave_id;
+};
+
+/* Used by slave DMA clients to request DMA to/from a specific peripheral */
+struct rza1_dma_slave {
+	struct rza1dma_slave	rza1dma_slaveid;	/* Set by the platform */
+};
+
+struct rza1_dma_slave_config {
+	int			slave_id;
+	dma_addr_t		addr;
+	struct chcfg_reg	chcfg;
+	struct dmars_reg	dmars;
+};
+
+struct rza1_dma_pdata {
+	const struct rza1_dma_slave_config *slave;
+	int slave_num;
+	int channel_num;
+};
+
+bool rza1dma_chan_filter(struct dma_chan *chan, void *arg);
+#endif
diff --git a/include/linux/platform_data/sh_adc.h b/include/linux/platform_data/sh_adc.h
new file mode 100644
index 0000000..47158aa
--- /dev/null
+++ b/include/linux/platform_data/sh_adc.h
@@ -0,0 +1,29 @@
+/*
+ * SH ADC platform data
+ *
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#ifndef __LINUX_PLATFORM_DATA_SH_ADC_H__
+#define __LINUX_PLATFORM_DATA_SH_ADC_H__
+
+struct sh_adc_data {
+	u8	num_channels;
+	u8	mtu2_ch;
+};
+
+#endif /* __LINUX_PLATFORM_DATA_SH_ADC_H__ */
+
diff --git a/include/linux/spi/sh_spibsc.h b/include/linux/spi/sh_spibsc.h
new file mode 100644
index 0000000..9536612
--- /dev/null
+++ b/include/linux/spi/sh_spibsc.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef SH_SPIBSC_H
+#define SH_SPIBSC_H
+
+struct sh_spibsc_info {
+	int bus_num;
+};
+
+#endif
diff --git a/include/linux/usb/r8a66597.h b/include/linux/usb/r8a66597.h
index 55805f9..5b7e957 100644
--- a/include/linux/usb/r8a66597.h
+++ b/include/linux/usb/r8a66597.h
@@ -1,7 +1,7 @@
 /*
  * R8A66597 driver platform data
  *
- * Copyright (C) 2009  Renesas Solutions Corp.
+ * Copyright (C) 2009-2013  Renesas Solutions Corp.
  *
  * Author : Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
  *
@@ -132,7 +132,11 @@ struct r8a66597_platdata {
 #define DEVADD8		0xE0
 #define DEVADD9		0xE2
 #define DEVADDA		0xE4
+#ifdef CONFIG_ARCH_R7S72100
+#define SUSPMODE0	0x102
+#endif
 
+#ifndef CONFIG_ARCH_R7S72100
 /* System Configuration Control Register */
 #define	XTAL		0xC000	/* b15-14: Crystal selection */
 #define	  XTAL48	 0x8000	  /* 48MHz */
@@ -477,5 +481,331 @@ struct r8a66597_platdata {
 #define CH1ENDC		0x0002 /* b2: Ch1 DMA Transfer End Int Stat Clear */
 #define CH0ENDC		0x0001 /* b1: Ch0 DMA Transfer End Int Stat Clear */
 
+#else
+
+/* System Configuration Control Register */
+#define	HSE		0x0080	/* b7: Hi-speed enable */
+#define	DCFM		0x0040	/* b6: Controller function select  */
+#define	DRPD		0x0020	/* b5: D+/- pull down control */
+#define	DPRPU		0x0010	/* b4: D+ pull up control */
+#define	XTAL		0x0004	/* b2: Crystal selection */
+#define	  XTAL12	 0x0004	  /* 12MHz */
+#define	  XTAL48	 0x0000	  /* 48MHz */
+#define	UPLLE		0x0002	/* b1: internal PLL control */
+#define	USBE		0x0001	/* b0: USB module operation enable */
+
+/* System Configuration Status Register */
+#define	OVCBIT		0x8000	/* b15-14: Over-current bit */
+#define	OVCMON		0xC000	/* b15-14: Over-current monitor */
+#define	SOFEA		0x0020	/* b5: SOF monitor */
+#define	IDMON		0x0004	/* b3: ID-pin monitor */
+#define	LNST		0x0003	/* b1-0: D+, D- line status */
+#define	  SE1		 0x0003	  /* SE1 */
+#define	  FS_KSTS	 0x0002	  /* Full-Speed K State */
+#define	  FS_JSTS	 0x0001	  /* Full-Speed J State */
+#define	  LS_JSTS	 0x0002	  /* Low-Speed J State */
+#define	  LS_KSTS	 0x0001	  /* Low-Speed K State */
+#define	  SE0		 0x0000	  /* SE0 */
+
+/* Device State Control Register */
+#define	EXTLP0		0x0400	/* b10: External port */
+#define	VBOUT		0x0200	/* b9: VBUS output */
+#define	WKUP		0x0100	/* b8: Remote wakeup */
+#define	RWUPE		0x0080	/* b7: Remote wakeup sense */
+#define	USBRST		0x0040	/* b6: USB reset enable */
+#define	RESUME		0x0020	/* b5: Resume enable */
+#define	UACT		0x0010	/* b4: USB bus enable */
+#define	RHST		0x0007	/* b1-0: Reset handshake status */
+#define	  HSPROC	 0x0004	  /* HS handshake is processing */
+#define	  HSMODE	 0x0003	  /* Hi-Speed mode */
+#define	  FSMODE	 0x0002	  /* Full-Speed mode */
+#define	  LSMODE	 0x0001	  /* Low-Speed mode */
+#define	  UNDECID	 0x0000	  /* Undecided */
+
+/* Test Mode Register */
+#define	UTST			0x000F	/* b3-0: Test select */
+#define	  H_TST_PACKET		 0x000C	  /* HOST TEST Packet */
+#define	  H_TST_SE0_NAK		 0x000B	  /* HOST TEST SE0 NAK */
+#define	  H_TST_K		 0x000A	  /* HOST TEST K */
+#define	  H_TST_J		 0x0009	  /* HOST TEST J */
+#define	  H_TST_NORMAL		 0x0000	  /* HOST Normal Mode */
+#define	  P_TST_PACKET		 0x0004	  /* PERI TEST Packet */
+#define	  P_TST_SE0_NAK		 0x0003	  /* PERI TEST SE0 NAK */
+#define	  P_TST_K		 0x0002	  /* PERI TEST K */
+#define	  P_TST_J		 0x0001	  /* PERI TEST J */
+#define	  P_TST_NORMAL		 0x0000	  /* PERI Normal Mode */
+
+/* DMAx Pin Configuration Register */
+#define	DENDE			0x0010	/* b4: Tend enable */
+
+/* CFIFO/DxFIFO Port Select Register */
+#define	RCNT		0x8000	/* b15: Read count mode */
+#define	REW		0x4000	/* b14: Buffer rewind */
+#define	  MBW_8		 0x0000	  /*  8bit */
+#define	  MBW_16	 0x0400	  /* 16bit */
+#define	  MBW_32	 0x0800   /* 32bit */
+#define	BIGEND		0x0100	/* b8: Big endian mode */
+#define	  BYTE_LITTLE	 0x0000		/* little dendian */
+#define	  BYTE_BIG	 0x0100		/* big endifan */
+#define	ISEL		0x0020	/* b5: DCP FIFO port direction select */
+#define	CURPIPE		0x000F	/* b2-0: PIPE select */
+
+/* CFIFO/DxFIFO Port Control Register */
+#define	BVAL		0x8000	/* b15: Buffer valid flag */
+#define	BCLR		0x4000	/* b14: Buffer clear */
+#define	FRDY		0x2000	/* b13: FIFO ready */
+#define	DTLN		0x0FFF	/* b11-0: FIFO received data length */
+
+/* Interrupt Enable Register 0 */
+#define	VBSE	0x8000	/* b15: VBUS interrupt */
+#define	RSME	0x4000	/* b14: Resume interrupt */
+#define	SOFE	0x2000	/* b13: Frame update interrupt */
+#define	DVSE	0x1000	/* b12: Device state transition interrupt */
+#define	CTRE	0x0800	/* b11: Control transfer stage transition interrupt */
+#define	BEMPE	0x0400	/* b10: Buffer empty interrupt */
+#define	NRDYE	0x0200	/* b9: Buffer not ready interrupt */
+#define	BRDYE	0x0100	/* b8: Buffer ready interrupt */
+
+/* Interrupt Enable Register 1 */
+#define	OVRCRE		0x8000	/* b15: Over-current interrupt */
+#define	BCHGE		0x4000	/* b14: USB us chenge interrupt */
+#define	DTCHE		0x1000	/* b12: Detach sense interrupt */
+#define	ATTCHE		0x0800	/* b11: Attach sense interrupt */
+#define	EOFERRE		0x0040	/* b6: EOF error interrupt */
+#define	SIGNE		0x0020	/* b5: SETUP IGNORE interrupt */
+#define	SACKE		0x0010	/* b4: SETUP ACK interrupt */
+
+/* BRDY Interrupt Enable/Status Register */
+#define	BRDY9		0x0200	/* b9: PIPE9 */
+#define	BRDY8		0x0100	/* b8: PIPE8 */
+#define	BRDY7		0x0080	/* b7: PIPE7 */
+#define	BRDY6		0x0040	/* b6: PIPE6 */
+#define	BRDY5		0x0020	/* b5: PIPE5 */
+#define	BRDY4		0x0010	/* b4: PIPE4 */
+#define	BRDY3		0x0008	/* b3: PIPE3 */
+#define	BRDY2		0x0004	/* b2: PIPE2 */
+#define	BRDY1		0x0002	/* b1: PIPE1 */
+#define	BRDY0		0x0001	/* b1: PIPE0 */
+
+/* NRDY Interrupt Enable/Status Register */
+#define	NRDY9		0x0200	/* b9: PIPE9 */
+#define	NRDY8		0x0100	/* b8: PIPE8 */
+#define	NRDY7		0x0080	/* b7: PIPE7 */
+#define	NRDY6		0x0040	/* b6: PIPE6 */
+#define	NRDY5		0x0020	/* b5: PIPE5 */
+#define	NRDY4		0x0010	/* b4: PIPE4 */
+#define	NRDY3		0x0008	/* b3: PIPE3 */
+#define	NRDY2		0x0004	/* b2: PIPE2 */
+#define	NRDY1		0x0002	/* b1: PIPE1 */
+#define	NRDY0		0x0001	/* b1: PIPE0 */
+
+/* BEMP Interrupt Enable/Status Register */
+#define	BEMP9		0x0200	/* b9: PIPE9 */
+#define	BEMP8		0x0100	/* b8: PIPE8 */
+#define	BEMP7		0x0080	/* b7: PIPE7 */
+#define	BEMP6		0x0040	/* b6: PIPE6 */
+#define	BEMP5		0x0020	/* b5: PIPE5 */
+#define	BEMP4		0x0010	/* b4: PIPE4 */
+#define	BEMP3		0x0008	/* b3: PIPE3 */
+#define	BEMP2		0x0004	/* b2: PIPE2 */
+#define	BEMP1		0x0002	/* b1: PIPE1 */
+#define	BEMP0		0x0001	/* b0: PIPE0 */
+
+/* SOF Pin Configuration Register */
+#define	TRNENSEL	0x0100	/* b8: Select transaction enable period */
+#define	BRDYM		0x0040	/* b6: BRDY clear timing */
+#define	INTL		0x0020	/* b5: Interrupt sense select */
+#define	EDGESTS		0x0010	/* b4:  */
+#define	SOFMODE		0x000C	/* b3-2: SOF pin select */
+#define	  SOF_125US	 0x0008	  /* SOF OUT 125us Frame Signal */
+#define	  SOF_1MS	 0x0004	  /* SOF OUT 1ms Frame Signal */
+#define	  SOF_DISABLE	 0x0000	  /* SOF OUT Disable */
+
+/* Interrupt Status Register 0 */
+#define	VBINT	0x8000	/* b15: VBUS interrupt */
+#define	RESM	0x4000	/* b14: Resume interrupt */
+#define	SOFR	0x2000	/* b13: SOF frame update interrupt */
+#define	DVST	0x1000	/* b12: Device state transition interrupt */
+#define	CTRT	0x0800	/* b11: Control transfer stage transition interrupt */
+#define	BEMP	0x0400	/* b10: Buffer empty interrupt */
+#define	NRDY	0x0200	/* b9: Buffer not ready interrupt */
+#define	BRDY	0x0100	/* b8: Buffer ready interrupt */
+#define	VBSTS	0x0080	/* b7: VBUS input port */
+#define	DVSQ	0x0070	/* b6-4: Device state */
+#define	  DS_SPD_CNFG	 0x0070	  /* Suspend Configured */
+#define	  DS_SPD_ADDR	 0x0060	  /* Suspend Address */
+#define	  DS_SPD_DFLT	 0x0050	  /* Suspend Default */
+#define	  DS_SPD_POWR	 0x0040	  /* Suspend Powered */
+#define	  DS_SUSP	 0x0040	  /* Suspend */
+#define	  DS_CNFG	 0x0030	  /* Configured */
+#define	  DS_ADDS	 0x0020	  /* Address */
+#define	  DS_DFLT	 0x0010	  /* Default */
+#define	  DS_POWR	 0x0000	  /* Powered */
+#define	DVSQS		0x0030	/* b5-4: Device state */
+#define	VALID		0x0008	/* b3: Setup packet detected flag */
+#define	CTSQ		0x0007	/* b2-0: Control transfer stage */
+#define	  CS_SQER	 0x0006	  /* Sequence error */
+#define	  CS_WRND	 0x0005	  /* Control write nodata status stage */
+#define	  CS_WRSS	 0x0004	  /* Control write status stage */
+#define	  CS_WRDS	 0x0003	  /* Control write data stage */
+#define	  CS_RDSS	 0x0002	  /* Control read status stage */
+#define	  CS_RDDS	 0x0001	  /* Control read data stage */
+#define	  CS_IDST	 0x0000	  /* Idle or setup stage */
+
+/* Interrupt Status Register 1 */
+#define	OVRCR		0x8000	/* b15: Over-current interrupt */
+#define	BCHG		0x4000	/* b14: USB bus chenge interrupt */
+#define	DTCH		0x1000	/* b12: Detach sense interrupt */
+#define	ATTCH		0x0800	/* b11: Attach sense interrupt */
+#define	EOFERR		0x0040	/* b6: EOF-error interrupt */
+#define	SIGN		0x0020	/* b5: Setup ignore interrupt */
+#define	SACK		0x0010	/* b4: Setup acknowledge interrupt */
+
+/* Frame Number Register */
+#define	OVRN		0x8000	/* b15: Overrun error */
+#define	CRCE		0x4000	/* b14: Received data error */
+#define	FRNM		0x07FF	/* b10-0: Frame number */
+
+/* Micro Frame Number Register */
+#define	UFRNM		0x0007	/* b2-0: Micro frame number */
+
+/* Default Control Pipe Maxpacket Size Register */
+/* Pipe Maxpacket Size Register */
+#define	DEVSEL	0xF000	/* b15-14: Device address select */
+#define	MAXP	0x007F	/* b6-0: Maxpacket size of default control pipe */
+
+/* Default Control Pipe Control Register */
+#define	BSTS		0x8000	/* b15: Buffer status */
+#define	SUREQ		0x4000	/* b14: Send USB request  */
+#define	CSCLR		0x2000	/* b13: complete-split status clear */
+#define	CSSTS		0x1000	/* b12: complete-split status */
+#define	SUREQCLR	0x0800	/* b11: stop setup request */
+#define	SQCLR		0x0100	/* b8: Sequence toggle bit clear */
+#define	SQSET		0x0080	/* b7: Sequence toggle bit set */
+#define	SQMON		0x0040	/* b6: Sequence toggle bit monitor */
+#define	PBUSY		0x0020	/* b5: pipe busy */
+#define	PINGE		0x0010	/* b4: ping enable */
+#define	CCPL		0x0004	/* b2: Enable control transfer complete */
+#define	PID		0x0003	/* b1-0: Response PID */
+#define	  PID_STALL11	 0x0003	  /* STALL */
+#define	  PID_STALL	 0x0002	  /* STALL */
+#define	  PID_BUF	 0x0001	  /* BUF */
+#define	  PID_NAK	 0x0000	  /* NAK */
+
+/* Pipe Window Select Register */
+#define	PIPENM		0x0007	/* b2-0: Pipe select */
+
+/* Pipe Configuration Register */
+#define	R8A66597_TYP	0xC000	/* b15-14: Transfer type */
+#define	  R8A66597_ISO	 0xC000		  /* Isochronous */
+#define	  R8A66597_INT	 0x8000		  /* Interrupt */
+#define	  R8A66597_BULK	 0x4000		  /* Bulk */
+#define	R8A66597_BFRE	0x0400	/* b10: Buffer ready interrupt mode select */
+#define	R8A66597_DBLB	0x0200	/* b9: Double buffer mode select */
+#define	R8A66597_CNTMD	0x0100	/* b8: Continuous transfer mode select */
+#define	R8A66597_SHTNAK	0x0080	/* b7: Transfer end NAK */
+#define	R8A66597_DIR	0x0010	/* b4: Transfer direction select */
+#define	R8A66597_EPNUM	0x000F	/* b3-0: Eendpoint number select */
+
+/* Pipe Buffer Configuration Register */
+#define	BUFSIZE		0x7C00	/* b14-10: Pipe buffer size */
+#define	BUFNMB		0x007F	/* b6-0: Pipe buffer number */
+#define	PIPE0BUF	256
+#define	PIPEXBUF	64
+
+/* Pipe Maxpacket Size Register */
+#define	MXPS		0x07FF	/* b10-0: Maxpacket size */
+
+/* Pipe Cycle Configuration Register */
+#define	IFIS	0x1000	/* b12: Isochronous in-buffer flush mode select */
+#define	IITV	0x0007	/* b2-0: Isochronous interval */
+
+/* Pipex Control Register */
+#define	BSTS	0x8000	/* b15: Buffer status */
+#define	INBUFM	0x4000	/* b14: IN buffer monitor (Only for PIPE1 to 5) */
+#define	CSCLR	0x2000	/* b13: complete-split status clear */
+#define	CSSTS	0x1000	/* b12: complete-split status */
+#define	ATREPM	0x0400	/* b10: Auto repeat mode */
+#define	ACLRM	0x0200	/* b9: Out buffer auto clear mode */
+#define	SQCLR	0x0100	/* b8: Sequence toggle bit clear */
+#define	SQSET	0x0080	/* b7: Sequence toggle bit set */
+#define	SQMON	0x0040	/* b6: Sequence toggle bit monitor */
+#define	PBUSY	0x0020	/* b5: pipe busy */
+#define	PID	0x0003	/* b1-0: Response PID */
+
+/* PIPExTRE */
+#define	TRENB		0x0200	/* b9: Transaction counter enable */
+#define	TRCLR		0x0100	/* b8: Transaction counter clear */
+
+/* PIPExTRN */
+#define	TRNCNT		0xFFFF	/* b15-0: Transaction counter */
+
+/* DEVADDx */
+#define	UPPHUB		0x7800
+#define	HUBPORT		0x0700
+#define	USBSPD		0x00C0
+#define	RTPORT		0x0001
+
+/* SUDMAC registers */
+#define CH0CFG		0x00
+#define CH1CFG		0x04
+#define CH0BA		0x10
+#define CH1BA		0x14
+#define CH0BBC		0x18
+#define CH1BBC		0x1C
+#define CH0CA		0x20
+#define CH1CA		0x24
+#define CH0CBC		0x28
+#define CH1CBC		0x2C
+#define CH0DEN		0x30
+#define CH1DEN		0x34
+#define DSTSCLR		0x38
+#define DBUFCTRL	0x3C
+#define DINTCTRL	0x40
+#define DINTSTS		0x44
+#define DINTSTSCLR	0x48
+#define CH0SHCTRL	0x50
+#define CH1SHCTRL	0x54
+
+/* SUDMAC Configuration Registers */
+#define SENDBUFM	0x1000 /* b12: Transmit Buffer Mode */
+#define RCVENDM		0x0100 /* b8: Receive Data Transfer End Mode */
+#define LBA_WAIT	0x0030 /* b5-4: Local Bus Access Wait */
+
+/* DMA Enable Registers */
+#define DEN		0x0001 /* b1: DMA Transfer Enable */
+
+/* DMA Status Clear Register */
+#define CH1STCLR	0x0002 /* b2: Ch1 DMA Status Clear */
+#define CH0STCLR	0x0001 /* b1: Ch0 DMA Status Clear */
+
+/* DMA Buffer Control Register */
+#define CH1BUFW		0x0200 /* b9: Ch1 DMA Buffer Data Transfer Enable */
+#define CH0BUFW		0x0100 /* b8: Ch0 DMA Buffer Data Transfer Enable */
+#define CH1BUFS		0x0002 /* b2: Ch1 DMA Buffer Data Status */
+#define CH0BUFS		0x0001 /* b1: Ch0 DMA Buffer Data Status */
+
+/* DMA Interrupt Control Register */
+#define CH1ERRE		0x0200 /* b9: Ch1 SHwy Res Err Detect Int Enable */
+#define CH0ERRE		0x0100 /* b8: Ch0 SHwy Res Err Detect Int Enable */
+#define CH1ENDE		0x0002 /* b2: Ch1 DMA Transfer End Int Enable */
+#define CH0ENDE		0x0001 /* b1: Ch0 DMA Transfer End Int Enable */
+
+/* DMA Interrupt Status Register */
+#define CH1ERRS		0x0200 /* b9: Ch1 SHwy Res Err Detect Int Status */
+#define CH0ERRS		0x0100 /* b8: Ch0 SHwy Res Err Detect Int Status */
+#define CH1ENDS		0x0002 /* b2: Ch1 DMA Transfer End Int Status */
+#define CH0ENDS		0x0001 /* b1: Ch0 DMA Transfer End Int Status */
+
+/* DMA Interrupt Status Clear Register */
+#define CH1ERRC		0x0200 /* b9: Ch1 SHwy Res Err Detect Int Stat Clear */
+#define CH0ERRC		0x0100 /* b8: Ch0 SHwy Res Err Detect Int Stat Clear */
+#define CH1ENDC		0x0002 /* b2: Ch1 DMA Transfer End Int Stat Clear */
+#define CH0ENDC		0x0001 /* b1: Ch0 DMA Transfer End Int Stat Clear */
+
+/* Suspend Mode Register */
+#define SUSPM		0x4000 /* b14: Suspend */
+#endif /* CONFIG_ARCH_R7S72100 */
+
 #endif /* __LINUX_USB_R8A66597_H */
 
diff --git a/include/sound/sh_scux.h b/include/sound/sh_scux.h
new file mode 100644
index 0000000..f54c879
--- /dev/null
+++ b/include/sound/sh_scux.h
@@ -0,0 +1,1352 @@
+/*
+ * include/sound/sh_scux.h
+ *     This file is header file for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef SH_SCUX_H
+#define SH_SCUX_H
+
+#include <linux/dmaengine.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <sound/soc.h>
+
+/************************************************************************
+	ALSA
+************************************************************************/
+/* buffer information */
+#define SCU_BUFFER_BYTES_MAX	(32 * 1024)
+#define SCU_PERIOD_BYTES_MIN	512
+#define SCU_PERIOD_BYTES_MAX	8192
+#define SCU_PERIODS_MIN		(SCU_BUFFER_BYTES_MAX / SCU_PERIOD_BYTES_MAX)
+#define SCU_PERIODS_MAX		(SCU_BUFFER_BYTES_MAX / SCU_PERIOD_BYTES_MIN)
+
+/* scux dapm route playback route */
+#define	W_SSI0			0x00000001
+#define	W_SRC1			0x00000002
+#define	W_DVC1			0x00000004
+#define RP_MEM_SSI0		W_SSI0
+#define RP_MEM_SRC1_SSI0	(W_SSI0 | W_SRC1)
+#define RP_MEM_SRC1_DVC1_SSI0	(W_SSI0 | W_SRC1 | W_DVC1)
+/* scux dapm route capture route */
+#define	W_SSI0_CAP		0x00010000
+#define	W_SRC0			0x00020000
+#define	RC_SSI0_MEM		W_SSI0_CAP
+#define RC_SSI0_SRC0_MEM	(W_SSI0_CAP | W_SRC0)
+/* dma direction */
+#define	DMA_DIR(d)	((d == 0) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)
+
+/* IP channel */
+#define	MAXCH_SSIF	6
+#define	MAXCH_SRC	2
+#define	MAXCH_DVU	4
+#define MAXCH_DMA	5 /* DMA slave IDs .ex:RP_MEM_SRC1_DVC1_SSI0 */
+
+/* dai Control */
+#define CTRL_PLAYBACK	0
+#define CTRL_CAPTURE	1
+
+/* clock */
+#define AUDIO_X1	22579200	/* 22.5792Mhz */
+
+/*  rate  */
+#define	RATE_MAX	0x7fffffff
+
+/*  volume  */
+#define	VOLUME_MAX_DVC	0x007fffff
+#define	VOLUME_DEFAULT	0x00100000
+
+/* SRC channel */
+enum {
+	SRC0,
+	SRC1,
+	SRC2,
+	SRC3,
+};
+#define	SCUX_2SRC0_0			(0)
+#define	SCUX_2SRC0_1			(1)
+
+/* SRC_BSDSR */
+#define	SRC_BSD012349_BUFDATA_1_6	(0x180 << 16)
+#define	SRC_BSD012349_BUFDATA_1_4	(0x100 << 16)
+#define	SRC_BSD012349_BUFDATA_1_3	(0x0c0 << 16)
+#define	SRC_BSD012349_BUFDATA_1_2	(0x080 << 16)
+#define	SRC_BSD012349_BUFDATA_2_3	(0x060 << 16)
+#define	SRC_BSD012349_BUFDATA_1_1	(0x040 << 16)
+#define	SRC_BSD5678_BUFDATA_1_6		(0x240 << 16)
+#define	SRC_BSD5678_BUFDATA_1_4		(0x180 << 16)
+#define	SRC_BSD5678_BUFDATA_1_3		(0x120 << 16)
+#define	SRC_BSD5678_BUFDATA_1_2		(0x0c0 << 16)
+#define	SRC_BSD5678_BUFDATA_2_3		(0x090 << 16)
+#define	SRC_BSD5678_BUFDATA_1_1		(0x060 << 16)
+
+/* SRC_BSISR */
+#define	SRC_BSI_IJECPREC		(0x10 << 16)
+#define	SRC_BSI_IJECSIZE_1_6		0x60
+#define	SRC_BSI_IJECSIZE_1_4		0x40
+#define	SRC_BSI_IJECSIZE_1_3		0x30
+#define	SRC_BSI_IJECSIZE_1_2		0x20
+#define	SRC_BSI_IJECSIZE_2_3		0x20
+#define	SRC_BSI_IJECSIZE_1_1		0x20
+
+/* BUFIJEC bit */
+#define BUFIJEC_LOW_DELAY_OFF		(0uL)
+#define BUFIJEC_LOW_DELAY_ON		(5uL)
+#define	BFSSR_BIT_BUFDATA_16BYTE	(16<<16)
+
+/* DVC channel */
+enum {
+	DVC0,
+	DVC1,
+};
+
+/* SSI channel */
+enum {
+	SSI0,
+	SSI1,
+	SSI2,
+	SSI3,
+	SSI4,
+	SSI5,
+	SSI6,
+	SSI7,
+	SSI8,
+	SSI9,
+};
+
+/* SSI input/output */
+#define	SSI_OUT		0
+#define	SSI_IN		1
+
+/* SSI mode */
+enum {
+	SSI_MASTER,
+	SSI_SLAVE,
+};
+
+/* SSI dependant/independat transfer */
+enum {
+	SSI_DEPENDANT,
+	SSI_INDEPENDANT,
+};
+
+/************************************************************************
+	structure
+************************************************************************/
+struct scu_pcm_callback {
+	void (*init_ssi)(int, int, int, int, int);
+	void (*init_src)(int, unsigned int, unsigned int);
+	void (*init_dvc)(int);
+	void (*deinit_ssi)(int, int, int, int);
+	void (*deinit_src)(int);
+	void (*deinit_dvc)(int);
+};
+struct scu_route_info {
+	int p_route;		/* playback route */
+	int c_route;		/* capture route */
+	/* snd_kcontrol */
+	int route_ssi[MAXCH_SSIF];
+	int route_src[MAXCH_SRC];
+	int route_mix[1];
+	int route_dvc[MAXCH_DVU];
+	/* playback callback */
+	struct scu_pcm_callback pcb;
+	/* capture callback */
+	struct scu_pcm_callback ccb;
+};
+
+struct scu_clock_info {
+	struct clk *adg_clk;
+	struct clk *scu_clk;
+	struct clk *src0_clk;
+	struct clk *src1_clk;
+	struct clk *dvc0_clk;
+	struct clk *dvc1_clk;
+	struct clk *ssiu_clk;
+	struct clk *ssi0_clk;
+	struct clk *ssi1_clk;
+};
+
+struct scu_config {
+	int label;
+	int value;
+};
+
+struct scu_platform_data {
+	int ssi_master;
+	int ssi_slave;
+	struct scu_config *ssi_ch;
+	int ssi_ch_num;
+	struct scu_config *src_ch;
+	int src_ch_num;
+	struct scu_config *dvc_ch;
+	int dvc_ch_num;
+	int dma_slave_maxnum;
+	struct scu_config *audma_slave;
+	int audma_slave_num;
+	struct scu_config *ssi_depend;
+	int ssi_depend_num;
+	struct scu_config *ssi_mode;
+	int ssi_mode_num;
+	struct scu_config *src_mode;
+	int src_mode_num;
+};
+
+struct scu_pcm_info {
+	int flag_first;			/* for PCM 1st process */
+	int flag_start;			/* for DMA control */
+	unsigned int buf_offset;	/* for buffer control */
+	unsigned int tran_size;		/* total size of transferred frame */
+	unsigned int period_piece;	/* piece of period to transfer */
+	unsigned int tran_period_piece;	/* transferred piece of period */
+	spinlock_t pcm_lock;		/* for trigger process */
+	struct dma_chan **de_chan;
+	struct rza1_dma_slave *de_param;
+	struct work_struct work;
+	struct workqueue_struct *workq;
+	struct scu_route_info *routeinfo;
+	struct snd_pcm_substream *ss;
+	struct scu_platform_data *pdata;
+};
+
+/************************************************************************
+	inline function
+************************************************************************/
+static inline int scu_find_data(int val, struct scu_config *data, int size)
+{
+	int i;
+	struct scu_config *data_p = data;
+
+	for (i = 0; i < size; data_p++, i++) {
+		if (val == data_p->label)
+			return data_p->value;
+	}
+
+	return -1;
+}
+/******************************************************************************
+ ==== SCUX ====
+******************************************************************************/
+enum scux_ch {
+	SCUX_CH_0,
+	SCUX_CH_1,
+	SCUX_CH_2,
+	SCUX_CH_3,
+	NUM_SCUX_CH,	/* 4ch */
+};
+/******************************************************************************
+ ==== SCUX register value list ====
+******************************************************************************/
+/* IPCIR Register Value */
+#define IPCIR_INIT_ON		(1uL)	/* Set INIT of IPC */
+
+/* IPSLR Register Value */
+#define IPSLR_SSIF_IPC_ASYNC	(1uL)
+#define IPSLR_FFD_IPC_ASYNC	(3uL)
+#define IPSLR_FFD_IPC_SYNC	(4uL)
+
+/* OPCIR Register Value */
+#define OPCIR_INIT_ON		(1uL)	/* Set INIT of OPC */
+
+/* OPSLR Register Value */
+#define OPSLR_ASYNC_OPC_DVU	(1uL)
+#define OPSLR_ASYNC_OPC_FFU	(3uL)
+#define OPSLR_SYNC_OPC_FFU	(4uL)
+
+/* FFDIR Register Value */
+#define FFDIR_INIT_OFF		(0uL)	/* Set INIT of FFD */
+#define FFDIR_INIT_ON		(1uL)	/* Set INIT of FFD */
+
+/* FDAIR Register Value */
+#define FDAIR_AUDIO_CH_NONE	(0uL)
+#define FDAIR_AUDIO_CH_1	(1uL)
+#define FDAIR_AUDIO_CH_2	(2uL)
+#define FDAIR_AUDIO_CH_4	(4uL)
+#define FDAIR_AUDIO_CH_6	(6uL)
+#define FDAIR_AUDIO_CH_8	(8uL)
+
+/* DRQSR Register Value */
+#define DRQSR_REQ_SIZE_256	(0uL)	/* 256data (FFU0_0 and FFU0_1 Only) */
+#define DRQSR_REQ_SIZE_128	(1uL)	/* 128data (FFU0_0 and FFU0_1 Only) */
+#define DRQSR_REQ_SIZE_64	(2uL)	/* 64data   */
+#define DRQSR_REQ_SIZE_32	(3uL)	/* 32data   */
+#define DRQSR_REQ_SIZE_16	(4uL)	/* 16data   */
+#define DRQSR_REQ_SIZE_8	(5uL)	/* 8data    */
+#define DRQSR_REQ_SIZE_4	(6uL)	/* 4data    */
+#define DRQSR_REQ_SIZE_2	(7uL)	/* 2data    */
+#define DRQSR_REQ_SIZE_1	(8uL)	/* 1data    */
+
+/* FFDPR Register Value */
+#define FFDPR_NO_PASS_SELECT	(0uL)
+#define FFDPR_CIM_FFD_IPC_ASYNC	(1uL)
+#define FFDPR_CIM_FFD_IPC_SYNC	(2uL)
+
+/* FFDBR Register Value */
+#define FFDBR_HALT_ON		(0uL)
+#define FFDBR_BOOT_ON		(1uL)
+
+/* DEVMR Register Value */
+/* Configure SCUX
+DEVMR_FFD0_n - FFD0_n FIFO Download Event Mask Register(n=0,1,2,3)
+b31   DEVMUF - FFD Underflow Mask - Interrupt enabled
+b30   DEVMOF - FFD Overflow Mask - Interrupt enabled
+b29   DEVMOL - FFD Overlap Mask - Interrupt enabled
+b28   DEVMIUF - FFD Initialization Underflow Mask - Interrupt enabled
+b15   DEVMRQ - FFD Request Packet Mask - Interrupt disabled
+Other Reserved - The write value should always be 0 */
+/* Initial value of DEVMR_FFD0_n Register */
+#define DEVMR_VALUE         (0xF0000000uL)
+
+/* DEVCR Register Value */
+/* Request ON bits make 0, Other bits make 1 */
+#define DEVCR_REG_MASK      (0xF0008000uL)
+
+/* FFUIR Register Value */
+#define FFUIR_INIT_OFF		(0uL)		/* Set INIT of FFU */
+#define FFUIR_INIT_ON		(1uL)		/* Set INIT of FFU */
+
+/* FUAIR Register Value */
+#define FUAIR_AUDIO_CH_NONE	(0uL)
+#define FUAIR_AUDIO_CH_1	(1uL)
+#define FUAIR_AUDIO_CH_2	(2uL)
+#define FUAIR_AUDIO_CH_4	(4uL)
+#define FUAIR_AUDIO_CH_6	(6uL)
+#define FUAIR_AUDIO_CH_8	(8uL)
+
+/* URQSR Register Value */
+/*URQSR_FFU0_n - FFU0_n FIFO Upload Request Size Register(n=0,1,2,3)
+b3:b0 SIZE - Request size data - Set parameter
+Other Reserved - The write value should always be 0 */
+#define URQSR_CH0CH1_REQ_SIZE_256	(0uL)	/* 256data (FFU0_0,0_1 Only) */
+#define URQSR_CH0CH1_REQ_SIZE_128	(1uL)	/* 128data (FFU0_0,0_1 Only) */
+#define URQSR_CH0CH1_REQ_SIZE_64	(2uL)	/* 64data   */
+#define URQSR_CH0CH1_REQ_SIZE_32	(3uL)	/* 32data   */
+#define URQSR_CH0CH1_REQ_SIZE_16	(4uL)	/* 16data   */
+#define URQSR_CH0CH1_REQ_SIZE_8		(5uL)	/* 8data    */
+#define URQSR_CH0CH1_REQ_SIZE_4		(6uL)	/* 4data    */
+#define URQSR_CH0CH1_REQ_SIZE_2		(7uL)	/* 2data    */
+#define URQSR_CH0CH1_REQ_SIZE_1		(8uL)	/* 1data    */
+/* In the case of SCUX Channel 2 or 3, a value of 64 data is 0.*/
+#define URQSR_CH2CH3_REQ_SIZE_64	(0uL)	/* 64data   */
+#define URQSR_CH2CH3_REQ_SIZE_32	(1uL)	/* 32data   */
+#define URQSR_CH2CH3_REQ_SIZE_16	(2uL)	/* 16data   */
+#define URQSR_CH2CH3_REQ_SIZE_8		(3uL)	/* 8data    */
+#define URQSR_CH2CH3_REQ_SIZE_4		(4uL)	/* 4data    */
+#define URQSR_CH2CH3_REQ_SIZE_2		(5uL)	/* 2data    */
+#define URQSR_CH2CH3_REQ_SIZE_1		(6uL)	/* 1data    */
+
+/* FFUPR Register Value */
+#define FFUPR_NO_PASS_SELECT	(0uL)
+#define FFUPR_CIM_FFU_OPC_ASYNC	(1uL)
+#define FFUPR_CIM_FFU_OPC_SYNC	(2uL)
+
+/* UEVMR Register Value */
+/* Initial value of UEVMR_FFU0_n Register */
+#define UEVMR_VALUE         (0xE0000000uL)
+
+/* UEVCR Register Value */
+#define UEVCR_REG_MASK		(0xE0008000uL)
+#define UEVCR_BIT_UEVCUF	(0x80000000uL)
+#define UEVCR_BIT_UEVCOF	(0x40000000uL)
+#define UEVCR_BIT_UEVCOL	(0x20000000uL)
+#define UEVCR_BIT_UEVCRQ	(0x00008000uL)
+
+/* SRCIR Register Value */
+#define INIT_OFF		(0uL)	/* Clear INIT of SRC */
+#define SRCIR_INIT_ON		(1uL)	/* Set INIT of SRC */
+
+/* SRC_ADINR */
+#define	SRCADIN_OTBL_24BIT	(0<<16)
+#define	SRCADIN_OTBL_22BIT	(2<<16)
+#define	SRCADIN_OTBL_20BIT	(4<<16)
+#define	SRCADIN_OTBL_18BIT	(6<<16)
+#define	SRCADIN_OTBL_16BIT	(8<<16)
+#define	SRCADIN_OTBL_8BIT	(16<<16)
+#define	SRCADIN_CHNUM_0		(0<<0)
+#define	SRCADIN_CHNUM_1		(1<<0)
+#define	SRCADIN_CHNUM_2		(2<<0)
+#define	SRCADIN_CHNUM_4		(4<<0)
+#define	SRCADIN_CHNUM_6		(6<<0)
+#define	SRCADIN_CHNUM_8		(8<<0)
+
+/* SADIR Register Value */
+/* bit 3-0 */
+#define SADIR_AUDIO_CH_NONE	(0uL)
+#define SADIR_AUDIO_CH_1	(1uL)
+#define SADIR_AUDIO_CH_2	(2uL)
+#define SADIR_AUDIO_CH_4	(4uL)
+#define SADIR_AUDIO_CH_6	(6uL)
+#define SADIR_AUDIO_CH_8	(8uL)
+/*bit 20-16*/
+#define SADIR_OTBL_24BIT	(0<<16)
+#define SADIR_OTBL_16BIT	(8<<16)
+
+/* SRCBR Register Value */
+/*SRCBRp_2SRC0_m - 2SRC0_m Bypass Register p(m=0,1 p=0,1)
+b0    BYPASS - Bypass Mode - Set parameter
+Other Reserved - The write value should always be 0 */
+#define SRCBR_BYPASS_OFF	(0uL)
+#define SRCBR_BYPASS_ON		(1uL)
+
+/* IFSCR Register Value */
+/* IFSCRp_2SRC0_m - 2SRC0_m IFS Control Register p(m=0,1 p=0,1)
+b0    INTIFSEN - INTIFS value setting enable - Initial value enabled
+Other Reserved - The write value should always be 0 */
+/* Value of IFSCRp_2SRC0_m Register */
+#define IFSCR_VALUE		(1uL)
+
+
+/* IFSVR Register Value */
+#define IFSVR_INTIFS_NOIFSVR	(0uL)
+#define NUM_OUTPUT_FS		(7uL)
+#define NUM_INPUT_FS		(12uL)
+#define	SRC_IFS_FSO		(0x00400000uL)	/* 2^22 */
+#define	SRC_IFS_8KHZ		(8000uL)
+#define	SRC_IFS_11KHZ		(11025uL)
+#define	SRC_IFS_12KHZ		(12000uL)
+#define	SRC_IFS_16KHZ		(16000uL)
+#define	SRC_IFS_22KHZ		(22050uL)
+#define	SRC_IFS_24KHZ		(24000uL)
+#define	SRC_IFS_32KHZ		(32000uL)
+#define	SRC_IFS_44KHZ		(44100uL)
+#define	SRC_IFS_48KHZ		(48000uL)
+#define INTIFS_IN44K_OUT8K	0x160cccc;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT11K	0x1000000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT12K	0x0EB3333;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT16K	0x0b06666;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT22K	0x0802531;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT24K	0x0759999;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT32K	0x0583333;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT44K	0x0400000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT48K	0x03acccc;	/* IFSVRp_2SRC0_0 INTIFS */
+
+#define INTIFS_IN8K_OUT44K	0x00b9c27;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN11K_OUT44K	0x0100000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN12K_OUT44K	0x0116a3b;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN16K_OUT44K	0x017384e;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN22K_OUT44K	0x0200000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN24K_OUT44K	0x022d476;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN32K_OUT44K	0x02e709d;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT44K	0x0400000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN48K_OUT44K	0x045a8ec;	/* IFSVRp_2SRC0_0 INTIFS */
+
+/* SRCCR Register Value */
+/* SRCCRp_2SRC0_m - 2SRC0_m Control Register p(m=0,1 p=0,1)
+b20     WATMD - Wait Time Control of SRC - Set parameter
+b12     BUFMD - Low Delay Control by Buffer Size of SRC - Set parameter
+b0      SRCMD - Select SRC Mode of SRCI - Set parameter
+b16,8,4 Reserved - These bits should be set to 1
+Other   Reserved - The write value should always be 0 */
+#define	SRC_CR_BIT16		(1<<16)
+#define	SRC_CR_BIT12		(1<<12)
+#define	SRC_CR_LOW_DELAY_NON	(0<<12)
+#define	SRC_CR_BIT8		(1<<8)
+#define	SRC_CR_BIT4		(1<<4)
+#define	SRC_CR_SYNC		(1<<0)
+#define	SRC_CR_ASYNC		(0<<0)
+
+/* MNFSR Register Value */
+/*MNFSRp_2SRC0_m - 2SRC0_m Minimum FS Setting Register p(m=0,1 p=0,1)
+b27:b0 MINFS - Set the minimum FS ratio - Set parameter
+Other  Reserved - The write value should always be 0 */
+/* value of min_fs_ratio */
+#define MIN_FS_RATIO_90			(90)	/* 90% */
+#define MIN_FS_RATIO_98			(98)	/* 98% */
+#define MIN_FS_RATIO_100		(100)	/* 100 */
+#define MIN_FS_RATIO_DECIMAL_DIGITS	(24uL)	/* digits of min_fs_ratio */
+
+/* BFSSR Register Value */
+/* BFSSRp_2SRC0_m - 2SRC0_m Buffer Size Setting Register p(m=0,1 p=0,1)
+b25:b16 BUFDATA - Set the buffer size of 1 channel in DATA RAM - Set parameter
+b3:b0   BUFIJEC - Set the buffer size of 1 channel in IJEC RAM -
+	Sets 0x5 for low delay mode
+Other   Reserved - The write value should always be 0 */
+/* Sets 0x80 for low delay mode.1 */
+#define BFSSR_BUFDATA_MODE1 (0x80uL << 16)
+/* Sets 0x40 for low delay mode.2 */
+#define BFSSR_BUFDATA_MODE2 (0x40uL << 16)
+#define BFSSR_BUFIN_LOW_DELAY_OFF	(0uL)
+#define BFSSR_BUFIN_LOW_DELAY_ON	(5uL)	/* Sets 0x5 for low delay mode*/
+
+/* SC2SR Register Value */
+/* ALL Bit is ReadOnly */
+#define BFSSR_SRCWSTS			(1<<31) /* 1:Reached to wait time */
+#define BFSSR_SC2MUTE			(1<<30) /* 1:Output data of sampling
+						   rate conversion is stable. */
+#define BFSSR_SRCWSTS_REST		(0<<28) /* 00:SRC is resetting */
+#define BFSSR_SRCWSTS_INIT		(1<<28) /* 01:SRC is initialized */
+#define BFSSR_SRCWSTS_OPER		(2<<28) /* 10:SRC is operating */
+
+/* WATSR Register Value */
+/*WATSRp_2SRC0_m - 2SRC0_m Wait Time Setting Register p(m=0,1 p=0,1)
+b23:b0 WTIME - wait time - Set parameter
+Other  Reserved - The write value should always be 0 */
+/* SCUX SRC wait time */
+#define SCUX_MIN_WAIT		(0x00000000L)
+#define SCUX_MAX_WAIT		(0x00FFFFFFL)
+#define SCUX_NO_WAIT		(-1L)
+
+/* SEVMR Register Value */
+/* SEVMRp_2SRC0_m - 2SRC0_m Event Mask Register p(m=0,1 p=0,1)
+b31 EVMUF - Sampling Rate Converter Underflow Mask - Interrupt enabled
+b30 EVMOF - Sampling Rate Converter Overflow Mask - Interrupt enabled
+b14 EVMWAIT - Sampling Rate Converter Wait Time Mask - Interrupt enabled
+Other  Reserved - The write value should always be 0 */
+/* Value of SEVMRp_2SRC0_m Register */
+#define SEVMR_VALUE           (0xc0004000uL)
+
+/* SEVCR Register Value */
+#define SEVCR_REG_MASK		(0xC0004000uL)
+#define SEVCR_EVCUF		(0x80000000uL)
+#define SEVCR_EVCOF		(0x40000000uL)
+#define SEVCR_EVCWAIT		(0x00004000uL)
+
+/* SRCIRR Register Value */
+#define SRCIRR_INIT_ON		(1uL)		/* Set INIT of SRC */
+
+/* DVUIR Register Value */
+#define DVUIR_INIT_ON		(1uL)		/* Set INIT of DVU */
+
+/* VADIR Register Value */
+/* VADIR_DVU0_n - DVU0_n Audio Information Register(n=0,1,2,3)
+b20:b16 OTBL - Bit Length of Output Audio Data - Set parameter
+b3:b0   CHNUM - Channel Number - Set parameter
+Other   Reserved - The write value should always be 0 */
+/*bit 20-16*/
+#define VADIR_OTBL_24BIT	(0<<16)
+#define VADIR_OTBL_16BIT	(8<<16)
+/* bit 3-0 */
+#define VADIR_CHNUM_CH_NONE	(0uL)
+#define VADIR_CHNUM_CH_1	(1uL)
+#define VADIR_CHNUM_CH_2	(2uL)
+#define VADIR_CHNUM_CH_4	(4uL)
+#define VADIR_CHNUM_CH_6	(6uL)
+#define VADIR_CHNUM_CH_8	(8uL)
+
+/* DVUBR Register Value */
+#define DVUBR_BYPASS_OFF	(0uL)
+#define DVUBR_BYPASS_ON		(1uL)
+
+/* DVUCR Register Value */
+#define	DVUCR_VVMD_SLEEP	(0<<8)
+#define	DVUCR_VVMD_USE		(1<<8)
+#define	DVUCR_VRMD_SLEEP	(0<<4)
+#define	DVUCR_VRMD_USE		(1<<4)
+#define	DVUCR_ZCMD_SLEEP	(0<<0)
+#define	DVUCR_ZCMD_USE		(1<<0)
+
+/* ZCMCR Register Value */
+#define ZCMCR_ZCEN0_EN		(1<<0)
+#define ZCMCR_ZCEN1_EN		(1<<1)
+#define ZCMCR_ZCEN2_EN		(1<<2)
+#define ZCMCR_ZCEN3_EN		(1<<3)
+#define ZCMCR_ZCEN4_EN		(1<<4)
+#define ZCMCR_ZCEN5_EN		(1<<5)
+#define ZCMCR_ZCEN6_EN		(1<<6)
+#define ZCMCR_ZCEN7_EN		(1<<7)
+
+/* VRCTR Register Value */
+/* VRCTR_DVU0_n - DVU0_n Volume Ramp Control Register(n=0,1,2,3)
+b7:b0 VREN7:VREN0 - Volume Ramp Enable for Channel 7 to 0 - Set parameter
+Other Reserved - The write value should always be 0 */
+#define VRCTR_VREN0_EN		(1<<0)
+#define VRCTR_VREN1_EN		(1<<1)
+#define VRCTR_VREN2_EN		(1<<2)
+#define VRCTR_VREN3_EN		(1<<3)
+#define VRCTR_VREN4_EN		(1<<4)
+#define VRCTR_VREN5_EN		(1<<5)
+#define VRCTR_VREN6_EN		(1<<6)
+#define VRCTR_VREN7_EN		(1<<7)
+
+/* VRPDR Register Value */
+enum scux_ramp_period {
+	/*                vol_up , vol_down             */
+	DVU_PERIOD_1,		/*       1sample (  128dB,   -128dB/1step)   */
+	DVU_PERIOD_2,		/*       2sample (   64dB,    -64dB/1step)   */
+	DVU_PERIOD_4,		/*       4sample (   32dB,    -32dB/1step)   */
+	DVU_PERIOD_8,		/*       8sample (   16dB,    -16dB/1step)   */
+	DVU_PERIOD_16,		/*      16sample (    8dB,     -8dB/1step)   */
+	DVU_PERIOD_32,		/*      32sample (    4dB,     -4dB/1step)   */
+	DVU_PERIOD_64,		/*      64sample (    2dB,     -2dB/1step)   */
+	DVU_PERIOD_128,		/*     128sample (    1dB,     -1dB/1step)   */
+	DVU_PERIOD_256,		/*     256sample (  0.5dB,   -0.5dB/1step)   */
+	DVU_PERIOD_512,		/*     512sample ( 0.25dB,  -0.25dB/1step)   */
+	DVU_PERIOD_1024,	/*    1024sample (0.125dB, -0.125dB/1step)   */
+	DVU_PERIOD_2048,	/*    2048sample (0.125dB, -0.125dB/2step)   */
+	DVU_PERIOD_4096,	/*    4096sample (0.125dB, -0.125dB/4step)   */
+	DVU_PERIOD_8192,	/*    8192sample (0.125dB, -0.125dB/8step)   */
+	DVU_PERIOD_16384,	/*   16384sample (0.125dB, -0.125dB/16step)  */
+	DVU_PERIOD_32768,	/*   32768sample (0.125dB, -0.125dB/32step)  */
+	DVU_PERIOD_65536,	/*   65536sample (0.125dB, -0.125dB/64step)  */
+	DVU_PERIOD_131072,	/*  131072sample (0.125dB, -0.125dB/128step) */
+	DVU_PERIOD_262144,	/*  262144sample (0.125dB, -0.125dB/256step) */
+	DVU_PERIOD_524288,	/*  524288sample (0.125dB, -0.125dB/512step) */
+	DVU_PERIOD_1048576,	/* 1048576sample (0.125dB, -0.125dB/1024step)*/
+	DVU_PERIOD_2097152,	/* 2097152sample (0.125dB, -0.125dB/2048step)*/
+	DVU_PERIOD_4194304,	/* 4194304sample (0.125dB, -0.125dB/4096step)*/
+	DVU_PERIOD_8388608,	/* 8388608sample (0.125dB, -0.125dB/8192step)*/
+};
+#define VRPDR_VRPDUP_PERIOD_1       (DVU_PERIOD_1       << 8)
+#define VRPDR_VRPDUP_PERIOD_2       (DVU_PERIOD_2       << 8)
+#define VRPDR_VRPDUP_PERIOD_4       (DVU_PERIOD_4       << 8)
+#define VRPDR_VRPDUP_PERIOD_8       (DVU_PERIOD_8       << 8)
+#define VRPDR_VRPDUP_PERIOD_16      (DVU_PERIOD_16      << 8)
+#define VRPDR_VRPDUP_PERIOD_32      (DVU_PERIOD_32      << 8)
+#define VRPDR_VRPDUP_PERIOD_64      (DVU_PERIOD_64      << 8)
+#define VRPDR_VRPDUP_PERIOD_128     (DVU_PERIOD_128     << 8)
+#define VRPDR_VRPDUP_PERIOD_256     (DVU_PERIOD_256     << 8)
+#define VRPDR_VRPDUP_PERIOD_512     (DVU_PERIOD_512     << 8)
+#define VRPDR_VRPDUP_PERIOD_1024    (DVU_PERIOD_1024    << 8)
+#define VRPDR_VRPDUP_PERIOD_2048    (DVU_PERIOD_2048    << 8)
+#define VRPDR_VRPDUP_PERIOD_4096    (DVU_PERIOD_4096    << 8)
+#define VRPDR_VRPDUP_PERIOD_8192    (DVU_PERIOD_8192    << 8)
+#define VRPDR_VRPDUP_PERIOD_16384   (DVU_PERIOD_16384   << 8)
+#define VRPDR_VRPDUP_PERIOD_32768   (DVU_PERIOD_32768   << 8)
+#define VRPDR_VRPDUP_PERIOD_65536   (DVU_PERIOD_65536   << 8)
+#define VRPDR_VRPDUP_PERIOD_131072  (DVU_PERIOD_131072  << 8)
+#define VRPDR_VRPDUP_PERIOD_262144  (DVU_PERIOD_262144  << 8)
+#define VRPDR_VRPDUP_PERIOD_524288  (DVU_PERIOD_524288  << 8)
+#define VRPDR_VRPDUP_PERIOD_1048576 (DVU_PERIOD_1048576 << 8)
+#define VRPDR_VRPDUP_PERIOD_2097152 (DVU_PERIOD_2097152 << 8)
+#define VRPDR_VRPDUP_PERIOD_4194304 (DVU_PERIOD_4194304 << 8)
+#define VRPDR_VRPDUP_PERIOD_8388608 (DVU_PERIOD_8388608 << 8)
+
+#define VRPDR_VRPDDW_PERIOD_1       (DVU_PERIOD_1)
+#define VRPDR_VRPDDW_PERIOD_2       (DVU_PERIOD_2)
+#define VRPDR_VRPDDW_PERIOD_4       (DVU_PERIOD_4)
+#define VRPDR_VRPDDW_PERIOD_8       (DVU_PERIOD_8)
+#define VRPDR_VRPDDW_PERIOD_16      (DVU_PERIOD_16)
+#define VRPDR_VRPDDW_PERIOD_32      (DVU_PERIOD_32)
+#define VRPDR_VRPDDW_PERIOD_64      (DVU_PERIOD_64)
+#define VRPDR_VRPDDW_PERIOD_128     (DVU_PERIOD_128)
+#define VRPDR_VRPDDW_PERIOD_256     (DVU_PERIOD_256)
+#define VRPDR_VRPDDW_PERIOD_512     (DVU_PERIOD_512)
+#define VRPDR_VRPDDW_PERIOD_1024    (DVU_PERIOD_1024)
+#define VRPDR_VRPDDW_PERIOD_2048    (DVU_PERIOD_2048)
+#define VRPDR_VRPDDW_PERIOD_4096    (DVU_PERIOD_4096)
+#define VRPDR_VRPDDW_PERIOD_8192    (DVU_PERIOD_8192)
+#define VRPDR_VRPDDW_PERIOD_16384   (DVU_PERIOD_16384)
+#define VRPDR_VRPDDW_PERIOD_32768   (DVU_PERIOD_32768)
+#define VRPDR_VRPDDW_PERIOD_65536   (DVU_PERIOD_65536)
+#define VRPDR_VRPDDW_PERIOD_131072  (DVU_PERIOD_131072)
+#define VRPDR_VRPDDW_PERIOD_262144  (DVU_PERIOD_262144)
+#define VRPDR_VRPDDW_PERIOD_524288  (DVU_PERIOD_524288)
+#define VRPDR_VRPDDW_PERIOD_1048576 (DVU_PERIOD_1048576)
+#define VRPDR_VRPDDW_PERIOD_2097152 (DVU_PERIOD_2097152)
+#define VRPDR_VRPDDW_PERIOD_4194304 (DVU_PERIOD_4194304)
+#define VRPDR_VRPDDW_PERIOD_8388608 (DVU_PERIOD_8388608)
+
+/* VRDBR Register Value */
+#define VRDBR_VRDB_MUTE		(0x000003FFuL)
+#define VRDBR_VRDB_0DB		(0x00000000uL)
+
+/* VRWTR Register Value */
+#define VRWTR_VRWT		(0x00FFFFFFuL)
+
+/* VOL0R~VOL7R Register Value */
+#define SCUX_MAX_VOL_VALUE  (0x007FFFFFuL) /* SCUX DVU digital volume level */
+
+/* DVUER Register Value */
+#define DVUER_DVUEN_DI		(0uL)
+#define DVUER_DVUEN_EN (1uL) /* Set DVUER_DVU0_n register - DVUEN bit */
+
+/* DVUSR Register Value */
+#define DVUSR_VRSTS_MUTE (0uL)
+#define DVUSR_VRSTS_VOLRAMPDOWN	(1uL)
+#define DVUSR_VRSTS_VOLRAMPUP	(2uL)
+#define DVUSR_VRSTS_VRDBRREG	(3uL)
+#define DVUSR_VRSTS_VOLINDATA	(4uL)
+
+#define DVUSR_ZSTS0_MUTE	(1<<16)
+#define DVUSR_ZSTS1_MUTE	(1<<17)
+#define DVUSR_ZSTS2_MUTE	(1<<18)
+#define DVUSR_ZSTS3_MUTE	(1<<19)
+#define DVUSR_ZSTS4_MUTE	(1<<20)
+#define DVUSR_ZSTS5_MUTE	(1<<21)
+#define DVUSR_ZSTS6_MUTE	(1<<22)
+#define DVUSR_ZSTS7_MUTE	(1<<23)
+
+/* VEVMR Register Value */
+#define VEVMR_VEVMZCM7_EN	(1<<31)
+#define VEVMR_VEVMZCM6_EN	(1<<30)
+#define VEVMR_VEVMZCM5_EN	(1<<29)
+#define VEVMR_VEVMZCM4_EN	(1<<28)
+#define VEVMR_VEVMZCM3_EN	(1<<27)
+#define VEVMR_VEVMZCM2_EN	(1<<26)
+#define VEVMR_VEVMZCM1_EN	(1<<25)
+#define VEVMR_VEVMZCM0_EN	(1<<24)
+#define VEVMR_VEVMVR_EN		(1<<15)
+
+/* VEVCR Register Value */
+#define VEVCR_VEVCZCM7_EN	(1<<31)
+#define VEVCR_VEVCZCM6_EN	(1<<30)
+#define VEVCR_VEVCZCM5_EN	(1<<29)
+#define VEVCR_VEVCZCM4_EN	(1<<28)
+#define VEVCR_VEVCZCM3_EN	(1<<27)
+#define VEVCR_VEVCZCM2_EN	(1<<26)
+#define VEVCR_VEVCZCM1_EN	(1<<25)
+#define VEVCR_VEVCZCM0_EN	(1<<24)
+#define VEVCR_VEVCVR_EN		(1<<15)
+
+/* SWRSR Register Value */
+#define SWRSR_SWRST_RST		(0uL)
+#define SWRSR_SWRST_OPE		(1uL)
+
+/* DMACR Register Value */
+#define DMACR_DMAMDFFD0_EN	(1<<0)
+#define DMACR_DMAMDFFD1_EN	(1<<1)
+#define DMACR_DMAMDFFD2_EN	(1<<2)
+#define DMACR_DMAMDFFD3_EN	(1<<3)
+#define DMACR_DMAMDFFU0_EN	(1<<4)
+#define DMACR_DMAMDFFU1_EN	(1<<5)
+#define DMACR_DMAMDFFU2_EN	(1<<6)
+#define DMACR_DMAMDFFU3_EN	(1<<7)
+
+/* SSIRSEL Register Value */
+/* SSIRSEL_CIM - SSI Route Select Register
+b31:b30 SISEL3 - SRC3 SSIF Input Select - Set parameter
+b29:b28 SISEL2 - SRC2 SSIF Input Select - Set parameter
+b27:b26 SISEL1 - SRC1 SSIF Input Select - Input from SSIF3
+b25:b24 SISEL0 - SRC0 SSIF Input Select - input from SSIF0
+b21:b20 SOSEL5 - SSIF5 Output Select - Output from SRC3 (DVU0_3)
+b17:b16 SOSEL4 - SSIF4 Output Select - Output from SRC2 (DVU0_2)
+b13:b12 SOSEL3 - SSIF3 Output Select - Set parameter
+b9:b8   SOSEL2 - SSIF2 Output Select - Output from SRC3 (DVU0_3)
+b5:b4   SOSEL1 - SSIF1 Output Select - Output from SRC2 (DVU0_2)
+b1:b0   SOSEL0 - SSIF0 Output Select - Set parameter
+Other Reserved - The write value should always be 0 */
+#define SSIRSEL_SISEL3_USE_SSIF2	(0<<30)
+#define SSIRSEL_SISEL3_USE_SSIF5	(1<<30)
+#define SSIRSEL_SISEL2_USE_SSIF1	(0<<28)
+#define SSIRSEL_SISEL2_USE_SSIF4	(1<<28)
+#define SSIRSEL_SISEL1_USE_SSIF3	(0<<26)
+#define SSIRSEL_SISEL1_USE_SSIF345	(1<<26)
+#define SSIRSEL_SISEL0_USE_SSIF0	(0<<24)
+#define SSIRSEL_SISEL0_USE_SSIF012	(1<<24)
+#define SSIRSEL_SOSEL5_USE_SRC3		(0<<20)
+#define SSIRSEL_SOSEL5_USE_SRC1		(1<<20)
+#define SSIRSEL_SOSEL5_USE_SRC0		(2<<20)
+#define SSIRSEL_SOSEL4_USE_SRC2		(0<<16)
+#define SSIRSEL_SOSEL4_USE_SRC1		(1<<16)
+#define SSIRSEL_SOSEL4_USE_SRC0		(2<<16)
+#define SSIRSEL_SOSEL3_USE_SRC1		(0<<12)
+#define SSIRSEL_SOSEL3_USE_SRC0		(1<<12)
+#define SSIRSEL_SOSEL2_USE_SRC3		(0<<8)
+#define SSIRSEL_SOSEL2_USE_SRC0		(1<<8)
+#define SSIRSEL_SOSEL2_USE_SRC1		(2<<8)
+#define SSIRSEL_SOSEL1_USE_SRC2		(0<<4)
+#define SSIRSEL_SOSEL1_USE_SRC0		(1<<4)
+#define SSIRSEL_SOSEL1_USE_SRC1		(2<<4)
+#define SSIRSEL_SOSEL0_USE_SRC0		(0)
+#define SSIRSEL_SOSEL0_USE_SRC1		(1)
+
+/* FDTSEL Register Value */
+/* Configure SCUX
+FDTSELn_CIM - FFD0_n Timing Select Register(n=0,1,2,3)
+b26:16 SCKDIV - Division Ratio
+b8     DIVEN - Division Enable - Division disabled
+b3:0   SCKSEL - Clock Select
+Other Reserved - The write value should always be 0 */
+
+#define FDTSEL_SCKSEL_AUDIO_CLK		(0x0uL)
+#define FDTSEL_SCKSEL_AUIDIO_X1		(0x1uL)
+#define FDTSEL_SCKSEL_MLB_CLK		(0x2uL)
+#define FDTSEL_SCKSEL_USB_X1		(0x3uL)
+#define FDTSEL_SCKSEL_CLKP1_PHY_DIV2	(0x4uL)
+#define FDTSEL_SCKSEL_SSIF0_WS		(0x8uL)
+#define FDTSEL_SCKSEL_SSIF1_WS		(0x9uL)
+#define FDTSEL_SCKSEL_SSIF2_WS		(0xAuL)
+#define FDTSEL_SCKSEL_SSIF3_WS		(0xBuL)
+#define FDTSEL_SCKSEL_SSIF4_WS		(0xCuL)
+#define FDTSEL_SCKSEL_SSIF5_WS		(0xDuL)
+
+#define SCUX_FDTSEL_BIT_DIVEN		(0x00000100uL)
+
+#define FDTSEL_CH_0_SCKDIV		(0<<16)
+#define FDTSEL_CH_1_SCKDIV		(694uL)	/* P1PHY(66.67MHz)/2/48KHz */
+#define FDTSEL_CH_2_SCKDIV		(694uL)	/* P1PHY(66.67MHz)/2/48KHz */
+#define FDTSEL_CH_3_SCKDIV		(694uL)	/* P1PHY(66.67MHz)/2/48KHz */
+
+/* FUTSEL Register Value */
+#define FUTSEL_SCKSEL_AUDIO_CLK		(0x0uL)
+#define FUTSEL_SCKSEL_AUIDIO_X1		(0x1uL)
+#define FUTSEL_SCKSEL_MLB_CLK		(0x2uL)
+#define FUTSEL_SCKSEL_USB_X1		(0x3uL)
+#define FUTSEL_SCKSEL_CLKP1_PHY_DIV2	(0x4uL)
+#define FUTSEL_SCKSEL_SSIF0_WS		(0x8uL)
+#define FUTSEL_SCKSEL_SSIF1_WS		(0x9uL)
+#define FUTSEL_SCKSEL_SSIF2_WS		(0xAuL)
+#define FUTSEL_SCKSEL_SSIF3_WS		(0xBuL)
+#define FUTSEL_SCKSEL_SSIF4_WS		(0xCuL)
+#define FUTSEL_SCKSEL_SSIF5_WS		(0xDuL)
+
+#define FUTSEL_DIVEN_START		(0x00000100uL)
+
+#define FUTSEL_CH_0_SCKDIV		(0<<16)
+#define FUTSEL_CH_1_SCKDIV		(0<<16)
+#define FUTSEL_CH_2_SCKDIV		(0<<16)
+#define FUTSEL_CH_3_SCKDIV		(0<<16)
+
+#define SCKDIV_MAX			(2047)
+
+/* ==== SCUX SSIPMD_CIM register setting ==== */
+#define THIS_CH_NOT_USED		(0uL)
+
+/* SSIPMD Register Value */
+#define SSIPMD_SSI5CKS			(0<<21)
+#define SSIPMD_SSI4CKS			(0<<20)
+#define SSIPMD_SSI3CKS			(0<<19)
+#define SSIPMD_SSI2CKS			(0<<18)
+#define SSIPMD_SSI1CKS			(0<<17)
+#define SSIPMD_SSI0CKS			(0<<16)
+#define SSIPMD_SSI5PMD			(0<<8)
+#define SSIPMD_SSI4PMD			(0<<10)
+#define SSIPMD_SSI3PMD			(0<<14)
+#define SSIPMD_SSI2PMD			(0<<2)
+#define SSIPMD_SSI1PMD			(0)
+#define SSIPMD_INDEPENDENCE		(0x0uL)
+#define SSIPMD_COMMON_SLAVE		(0x1uL)
+#define SSIPMD_COMMON_MASTER_SLAVE	(0x2uL)
+
+/* SSICTRL Register Value */
+/* SSICTRL_CIM - SSI Control Register
+b30:28 SSI3TX,SSI4TX,SSI5TX - SSIF3,4,5 Direct Transmission - Set parameter
+b26:24 SSI3RX,SSI4RX,SSI5RX - SSIF3,4,5 Direct Reception - Set parameter
+b17    SSI345TEN - SSIF345 Transmission Enable - Transmission disabled
+b16    SSI345REN - SSIF345 Reception Enable - Reception disabled
+b14:12 SSI0TX,SSI1TX,SSI2TX - SSIF0,1,2 Direct Transmission - Set parameter
+b11:9  SSI0RX,SSI1RX,SSI2RX - SSIF0,1,2 Direct Reception - Set parameter
+b1     SSI012TEN - SSIF012 Transmission Enable - Transmission disabled
+b0     SSI012REN - SSIF012 Reception Enable - Reception disabled
+Other Reserved - The write value should always be 0 */
+#define SSICTRL_SSI3TX_EN	(1<<30)
+#define SSICTRL_SSI4TX_EN	(1<<29)
+#define SSICTRL_SSI5TX_EN	(1<<28)
+#define SSICTRL_SSI3RX_EN	(1<<26)
+#define SSICTRL_SSI4RX_EN	(1<<25)
+#define SSICTRL_SSI5RX_EN	(1<<24)
+#define SSICTRL_SSI345TEN	(1<<17)
+#define SSICTRL_SSI345REN	(1<<16)
+#define SSICTRL_SSI0TX_EN	(1<<14)
+#define SSICTRL_SSI1TX_EN	(1<<13)
+#define SSICTRL_SSI2TX_EN	(1<<12)
+#define SSICTRL_SSI0RX_EN	(1<<10)
+#define SSICTRL_SSI1RX_EN	(1<<9)
+#define SSICTRL_SSI2RX_EN	(1<<8)
+#define SSICTRL_SSI012TEN	(1<<1)
+#define SSICTRL_SSI012REN	(1)
+
+/* SRCRSEL Register Value */
+/* RSEL_INIT_VALUE:Initial value of SRCRSELn_CIM and MIXRSEL_CIM Register */
+#define RSEL_INIT_VALUE		(0x76543210uL)
+#define SRCRSEL_PLACE0		(7)
+#define SRCRSEL_PLACE1		(7<<4)
+#define SRCRSEL_PLACE2		(7<<8)
+#define SRCRSEL_PLACE3		(7<<12)
+#define SRCRSEL_PLACE4		(7<<16)
+#define SRCRSEL_PLACE5		(7<<20)
+#define SRCRSEL_PLACE6		(7<<24)
+#define SRCRSEL_PLACE7		(7<<28)
+
+/* MIXRSEL Register Value */
+#define MIXRSEL_INIT_VALUE	(0x76543210uL)
+#define MIXRSEL_PLACE0		(7)
+#define MIXRSEL_PLACE1		(7<<4)
+#define MIXRSEL_PLACE2		(7<<8)
+#define MIXRSEL_PLACE3		(7<<12)
+#define MIXRSEL_PLACE4		(7<<16)
+#define MIXRSEL_PLACE5		(7<<20)
+#define MIXRSEL_PLACE6		(7<<24)
+#define MIXRSEL_PLACE7		(7<<28)
+
+/* MIXBR Register Value */
+#define MIXBR_BYPASS_OFF	(0uL)
+#define MIXBR_BYPASS_ON		(1uL)
+#define MIXBR_BPSYS_B		(1<<16)
+
+/* CHCTRL Register */
+#define DMA_CHCTRL_SWRST_BIT	(0x00000008uL)
+#define DMA_CHCTRL_SETEN_BIT	(0x00000001uL)
+
+/************************************************************************
+	SCUX Register Structure
+************************************************************************/
+struct scux_ipc_regs {
+	u32	ipcir;
+	u32	ipslr;
+	unsigned char  dummy_ipc[248];
+};
+
+struct scux_opc_regs {
+	u32	opcir;
+	u32	opslr;
+	unsigned char  dummy_opc[248];
+};
+
+struct scux_ffd_regs {
+	u32	ffdir;
+	u32	fdair;
+	u32	drqsr;
+	u32	ffdpr;
+	u32	ffdbr;
+	u32	devmr;
+	unsigned char  dummy_ffd[4];
+	u32	devcr;
+	unsigned char  dummy2_ffd[224];
+};
+
+struct scux_ffu_regs {
+	u32	ffuir;
+	u32	fuair;
+	u32	urqsr;
+	u32	ffupr;
+	u32	uevmr;
+	unsigned char  dummy_ffu[4];
+	u32	uevcr;
+	unsigned char  dummy2_ffu[228];
+};
+
+struct scux_src_regs {
+	u32	srcir0;
+	u32	sadir0;
+	u32	srcbr0;
+	u32	ifscr0;
+	u32	ifsvr0;
+	u32	srccr0;
+	u32	mnfsr0;
+	u32	bfssr0;
+	u32	sc2sr0;
+	u32	watsr0;
+	u32	sevmr0;
+	unsigned char  dummy_src0[4];
+	u32	sevcr0;
+	u32	srcir1;
+	u32	sadir1;
+	u32	srcbr1;
+	u32	ifscr1;
+	u32	ifsvr1;
+	u32	srccr1;
+	u32	mnfsr1;
+	u32	bfssr1;
+	u32	sc2sr1;
+	u32	watsr1;
+	u32	sevmr1;
+	unsigned char  dummy_src1[4];
+	u32	sevcr1;
+	u32	srcirr1;
+	unsigned char  dummy_src[148];
+};
+
+struct scux_dvu_regs {
+	u32	dvuir;
+	u32	vadir;
+	u32	dvubr;
+	u32	dvucr;
+	u32	zcmcr;
+	u32	vrctr;
+	u32	vrpdr;
+	u32	vrdbr;
+	u32	vrwtr;
+	u32	vol0r;
+	u32	vol1r;
+	u32	vol2r;
+	u32	vol3r;
+	u32	vol4r;
+	u32	vol5r;
+	u32	vol6r;
+	u32	vol7r;
+	u32	dvuer;
+	u32	dvusr;
+	u32	vevmr;
+	unsigned char  dummy_dvu[4];
+	u32	vevcr;
+	unsigned char  dummy2_dvu[168];
+};
+
+struct scux_mix_regs {
+	u32	mixir;
+	u32	madir;
+	u32	mixbr;
+	u32	mixmr;
+	u32	mvpdr;
+	u32	mdbar;
+	u32	mdbbr;
+	u32	mdbcr;
+	u32	mdbdr;
+	u32	mdber;
+	u32	mixsr;
+	unsigned char  dummy_mix[212];
+};
+struct scux_cim_regs {
+	u32 swrsr;		/*  SWRSR_CIM       */
+	u32 dmacr_cim;		/*  DMACR_CIM       */
+	union {			/*                  */
+		/* DMATD0_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatd0_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATD1_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatd1_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATD2_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatd2_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATD3_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatd3_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATU0_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatu0_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATU1_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatu1_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATU2_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatu2_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATU3_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatu3_cim;		/*                  */
+	unsigned char  dummy_cim[16];	/*                  */
+	u32 ssirsel_cim;	/*  SSIRSEL_CIM     */
+	u32 fdtsel0_cim;	/*  FDTSEL0_CIM     */
+	u32 fdtsel1_cim;	/*  FDTSEL1_CIM     */
+	u32 fdtsel2_cim;	/*  FDTSEL2_CIM     */
+	u32 fdtsel3_cim;	/*  FDTSEL3_CIM     */
+	u32 futsel0_cim;	/*  FUTSEL0_CIM     */
+	u32 futsel1_cim;	/*  FUTSEL1_CIM     */
+	u32 futsel2_cim;	/*  FUTSEL2_CIM     */
+	u32 futsel3_cim;	/*  FUTSEL3_CIM     */
+	u32 ssipmd_cim;		/*  SSIPMD_CIM      */
+	u32 ssictrl_cim;	/*  SSICTRL_CIM     */
+	u32 srcrsel0_cim;	/*  SRCRSEL0_CIM    */
+	u32 srcrsel1_cim;	/*  SRCRSEL1_CIM    */
+	u32 srcrsel2_cim;	/*  SRCRSEL2_CIM    */
+	u32 srcrsel3_cim;	/*  SRCRSEL3_CIM    */
+	u32 mixrsel_cim;	/*  MIXRSEL_CIM     */
+};
+
+struct ssif_regs {
+	u32	ssicr;
+	u32	ssisr;
+	unsigned char dummy_ssifreg1[8];
+	u32	ssifcr;
+	u32	ssifsr;
+	u32	ssiftdr;
+	u32	ssifrdr;
+	u32	ssitdmr;
+	u32	ssifccr;
+	u32	ssifcmr;
+	u32	ssifcsr;
+	unsigned char dummy_ssifreg2[2000];
+};
+
+struct dmac_regs {
+	u32	chctrl;
+};
+
+struct scux_reg_info {
+	void __iomem				*scuxreg;
+	struct scux_ipc_regs		*ipcreg[NUM_SCUX_CH];
+	struct scux_opc_regs		*opcreg[NUM_SCUX_CH];
+	struct scux_ffd_regs		*ffdreg[NUM_SCUX_CH];
+	struct scux_ffu_regs		*ffureg[NUM_SCUX_CH];
+	struct scux_src_regs		*srcreg[MAXCH_SRC];
+	struct scux_dvu_regs		*dvureg[MAXCH_DVU];
+	struct scux_mix_regs		*mixreg;
+	struct scux_cim_regs		*cimreg;
+	void __iomem				*ssireg;
+	struct ssif_regs			*ssifreg[MAXCH_SSIF];
+};
+
+struct scu_audio_info {
+	struct scux_reg_info reginfo;
+	struct scu_route_info routeinfo;
+	struct scu_clock_info clockinfo;
+	spinlock_t scu_lock;		/* for common register */
+	unsigned int rate[2];
+	unsigned int volume[2][2];
+	unsigned int mute[2];
+};
+
+/******************************************************************************
+ ==== SSIF ====
+******************************************************************************/
+/* SSICRn bit */
+#define	SSICR_REN_DIS	(0<<0)
+#define	SSICR_REN_EN	(1<<0)
+#define	SSICR_TEN_DIS	(0<<1)
+#define	SSICR_TEN_EN	(1<<1)
+#define	SSICR_MUEN	(1<<3)
+#define	SSICR_CKDV_1	(0<<4)
+#define	SSICR_CKDV_2	(1<<4)
+#define	SSICR_CKDV_4	(2<<4)
+#define	SSICR_CKDV_8	(3<<4)
+#define	SSICR_CKDV_16	(4<<4)
+#define	SSICR_CKDV_32	(5<<4)
+#define	SSICR_CKDV_64	(6<<4)
+#define	SSICR_CKDV_128	(7<<4)
+#define	SSICR_CKDV_6	(8<<4)
+#define	SSICR_CKDV_12	(9<<4)
+#define	SSICR_CKDV_24	(10<<4)
+#define	SSICR_CKDV_48	(11<<4)
+#define	SSICR_CKDV_96	(12<<4)
+#define	SSICR_DEL_1CLKDEL (0<<8)
+#define	SSICR_DEL_NODEL (1<<8)
+#define	SSICR_PDTA	(1<<9)
+#define	SSICR_SDTA	(1<<10)
+#define	SSICR_SPDP	(1<<11)
+#define	SSICR_SWSP	(1<<12)
+#define	SSICR_SCKP	(1<<13)
+#define	SSICR_SWSD_SLAVE (0<<14)
+#define	SSICR_SWSD_MASTER (1<<14)
+#define	SSICR_M_MASTER	(3<<14)
+#define	SSICR_SCKD_SLAVE (0<<15)
+#define	SSICR_SCKD_MASTER (1<<15)
+#define	SSICR_SWL_ST8	(0<<16)
+#define	SSICR_SWL_ST16	(1<<16)
+#define	SSICR_SWL_ST24	(2<<16)
+#define	SSICR_SWL_ST32	(3<<16)
+#define	SSICR_SWL_ST48	(4<<16)
+#define	SSICR_SWL_ST64	(5<<16)
+#define	SSICR_SWL_ST128	(6<<16)
+#define	SSICR_SWL_ST256	(7<<16)
+#define	SSICR_DWL_ST8	(0<<19)
+#define	SSICR_DWL_ST16	(1<<19)
+#define	SSICR_DWL_ST18	(2<<19)
+#define	SSICR_DWL_ST20	(3<<19)
+#define	SSICR_DWL_ST22	(4<<19)
+#define	SSICR_DWL_ST24	(5<<19)
+#define	SSICR_DWL_ST32	(6<<19)
+#define	SSICR_CHNL_ST1	(0<<22)
+#define	SSICR_CHNL_ST2	(1<<22)
+#define	SSICR_CHNL_ST3	(2<<22)
+#define	SSICR_CHNL_ST4	(3<<22)
+#define	SSICR_IIEN	(1<<25)
+#define	SSICR_ROIEN	(1<<26)
+#define	SSICR_RUIEN	(1<<27)
+#define	SSICR_TOIEN	(1<<28)
+#define	SSICR_TUIEN	(1<<29)
+#define	SSICR_CKS	(1<<30)
+
+
+/* for SSI start */
+#define	SSICR_ENABLE	(SSICR_REN_EN	| \
+			 SSICR_ROIEN	| \
+			 SSICR_RUIEN	| \
+			 SSICR_TOIEN)
+
+/* SSISRn bit */
+#define	SSISR_IDST	(1<<0)
+#define	SSISR_SWNO	(1<<1)
+#define	SSISR_CHNO0	(1<<2)
+#define	SSISR_CHNO1	(1<<3)
+#define	SSISR_DIRQ	(1<<24)
+#define	SSISR_IIRQ	(1<<25)
+#define	SSISR_OIRQ	(1<<26)
+#define	SSISR_UIRQ	(1<<27)
+#define	SSISR_DMRQ	(1<<28)
+#define	SSISR_ROIRQ	(0<<26)
+#define	SSISR_RUIRQ	(0<<27)
+#define	SSISR_TOIRQ	(0<<28)
+#define	SSISR_TUIRQ	(0<<29)
+
+/* SSIFCRn bit */
+#define SSIFCR_RFRST	(1<<0)
+#define SSIFCR_TFRST	(1<<1)
+#define SSIFCR_RIE	(1<<2)
+#define SSIFCR_TIE	(1<<3)
+
+/* SSI TDM Mode Register Setting */
+/*  [17] RXDMUTE  : B'0 : Rx Direct Data MUTE : Rx Direct Data  */
+/*  [8] CONT  : B'1 : WS Continue Mode:Enables WS continue mode */
+/*  [0] TDM      : B'0 : TDM Mode : Disables TDM mode           */
+#define	SSITDMR_TDM_DIS			(0<<0)
+#define	SSITDMR_TDM_EN			(1<<0)
+#define	SSITDMR_CONT_DIS		(0<<8)
+#define	SSITDMR_CONT_EN			(1<<8)
+#define	SSITDMR_RXDMUTE_RCVDATA		(0<<17)
+#define	SSITDMR_RXDMUTE_0DATA		(1<<17)
+#define SSI_SSITDMR_BASE_INIT_VALUE	(SSITDMR_RXDMUTE_RCVDATA | \
+						SSITDMR_CONT_EN | \
+						SSITDMR_TDM_DIS)
+
+/* ==== SSI Channel0 ==== */
+/* SSI0 Control Register Setting */
+#define SSI_SSICR0_CKS_VALUE		(0x00000000uL)
+#define SSI_SSICR0_CHNL_VALUE		(0x00000000uL)
+#define SSI_SSICR0_DWL_VALUE		(0x00080000uL)
+#define SSI_SSICR0_SWL_VALUE		(0x00030000uL)
+#define SSI_SSICR0_SCKD_VALUE		(0x00008000uL)
+#define SSI_SSICR0_SWSD_VALUE		(0x00004000uL)
+#define SSI_SSICR0_SCKP_VALUE		(0x00000000uL)
+#define SSI_SSICR0_SWSP_VALUE		(0x00000000uL)
+#define SSI_SSICR0_SPDP_VALUE		(0x00000000uL)
+#define SSI_SSICR0_SDTA_VALUE		(0x00000000uL)
+#define SSI_SSICR0_PDTA_VALUE		(0x00000000uL)
+#define SSI_SSICR0_DEL_VALUE		(0x00000000uL)
+#define SSI_SSICR0_CKDV_VALUE		(0x00000030uL)
+
+/*  [30]    CKS : B'0  : AUDIO_X1 input                                      */
+/*  [23:22] CHNL: B'00 : 1 channel / system word                             */
+/*  [21:19] DWL : B'001: 16 bit / data word                                  */
+/*  [18:16] SWL : B'011: 32 bit / system word                                */
+/*  [15]    SCKD: B'1  : Serial Bit Clock Direction:master mode              */
+/*  [14]    SWSD: B'1  : Serial WS Direction:master mode                     */
+/*  [13]    SCKP: B'0  : SSIWS and SSIDATA change at the SSISCK falling edge */
+/*  [12]    SWSP: B'0  : SSIWS is low for 1st channel, high for 2nd channel  */
+/*  [11]    SPDP: B'0  : Padding bits are low                                */
+/*  [10]    SDTA: B'0  : Tx and Rx in the order of serial data and padding bit*/
+/*  [9]     PDTA: B'0  : The lower bits of parallel data(SSITDR, SSIRDR)
+				     are transferred prior to the upper bits */
+/*  [8]     DEL : B'0  : 1 clock cycle delay between SSIWS and SSIDATA       */
+/*  [7:4]   CKDV: B'0011: AUDIO dia / 8
+			(64FS,AUDIO_X1@22.5792MHz/32bit system word) */
+#define SSI_SSICR0_USER_INIT_VALUE  (SSI_SSICR0_CKS_VALUE  | \
+					SSI_SSICR0_CHNL_VALUE | \
+					SSI_SSICR0_DWL_VALUE  | \
+					SSI_SSICR0_SWL_VALUE  | \
+					SSI_SSICR0_SCKD_VALUE | \
+					SSI_SSICR0_SWSD_VALUE | \
+					SSI_SSICR0_SCKP_VALUE | \
+					SSI_SSICR0_SWSP_VALUE | \
+					SSI_SSICR0_SPDP_VALUE | \
+					SSI_SSICR0_SDTA_VALUE | \
+					SSI_SSICR0_PDTA_VALUE | \
+					SSI_SSICR0_DEL_VALUE  | \
+					SSI_SSICR0_CKDV_VALUE)
+
+/* SSI SSICR0 Register INIT Setting */
+/*  [29]    TUIEN   : B'0    : Disables an underflow interrupt              */
+/*  [28]    TOIEN   : B'0    : Disables an overflow interrupt               */
+/*  [27]    RUIEN   : B'0    : Disables an underflow interrupt              */
+/*  [26]    ROIEN   : B'0    : Receive Overflow Interrupt Enable            */
+/*  [25]    IIEN    : B'0    : Disables an idle mode interrupt              */
+/*  [3]     MUEN    : B'0    : This module is not muted                     */
+/*  [1]     TEN     : B'0    : Disables the transmit operation              */
+/*  [0]     REN     : B'0    : Disables the receive operation               */
+/*  [30:4] SSI_SSICR0_USER_INIT_VALUE SSICR0 INIT                          */
+#define SSI_SSICR_TUIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_TOIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_RUIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_ROIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_IIEN_INIT_VALUE           (0x00000000uL)
+#define SSI_SSICR_MUEN_INIT_VALUE           (0x00000000uL)
+#define SSI_SSICR_TEN_INIT_VALUE            (0x00000000uL)
+#define SSI_SSICR_REN_INIT_VALUE            (0x00000000uL)
+#define SSI_SSICR_BASE_INIT_VALUE           (SSI_SSICR_TUIEN_INIT_VALUE | \
+						SSI_SSICR_TOIEN_INIT_VALUE | \
+						SSI_SSICR_RUIEN_INIT_VALUE | \
+						SSI_SSICR_ROIEN_INIT_VALUE | \
+						SSI_SSICR_IIEN_INIT_VALUE  | \
+						SSI_SSICR_MUEN_INIT_VALUE  | \
+						SSI_SSICR_TEN_INIT_VALUE   | \
+						SSI_SSICR_REN_INIT_VALUE   | \
+						SSI_SSICR0_USER_INIT_VALUE)
+/*
+ * SSICR setting for WM8978
+ *   playback, master, 16bit, stereo
+ *   SCLK=256fs(MCLK)/8=32fs
+ */
+#define	SSICR_PLAY_WM8978_ST	(SSICR_CHNL_ST1    | \
+			 SSICR_DWL_ST16 | \
+			 SSICR_SWL_ST32 | \
+			 SSICR_M_MASTER | \
+			 SSICR_CKDV_8)
+/*
+ * SSICR setting for WWM8978
+ *   capture, slave, 16bit, stereo
+ *   SCLK=256fs(MCLK)/8=32fs
+ */
+#define	SSICR_CAP_WM8978_ST	(SSICR_CHNL_ST1    | \
+			 SSICR_DWL_ST16 | \
+			 SSICR_SWL_ST32 | \
+			 SSICR_M_MASTER | \
+			 SSICR_CKDV_8)
+/* SSI0 FIFO Control Register Setting */
+/*  [7:6] TTRG  : B'00 : Transmit Data Trigger Number:7                       */
+/*  [5:4] RTRG  : B'00 : Receive Data Trigger Number:1                        */
+/*  [3]   TIE   : B'0  : Transmit data empty interrupt (TXI)
+			 request is disabled */
+/*  [2]   RIE   : B'0  : Receive data full interrupt (RXI)
+			 request is disabled   */
+/*  [1]   TFRST : B'1  : Reset is enabled                                     */
+/*  [0]   RFRST : B'1  : Reset is enabled                                     */
+#define SSI_SSIFCR0_TTRG_VALUE			(0x00000000uL)
+#define SSI_SSIFCR0_RTRG_VALUE			(0x00000000uL)
+#define SSI_SSIFCR_TIE_INIT_VALUE		(0x00000000uL)
+#define SSI_SSIFCR_RIE_INIT_VALUE		(0x00000000uL)
+#define SSI_SSIFCR_TFRST_INIT_VALUE		(0x00000002uL)
+#define SSI_SSIFCR_RFRST_INIT_VALUE		(0x00000001uL)
+
+#define SSI_SSIFCR_BASE_INIT_VALUE	(SSI_SSIFCR0_TTRG_VALUE     | \
+					SSI_SSIFCR0_RTRG_VALUE      | \
+					SSI_SSIFCR_TIE_INIT_VALUE   | \
+					SSI_SSIFCR_RIE_INIT_VALUE   | \
+					SSI_SSIFCR_TFRST_INIT_VALUE | \
+					SSI_SSIFCR_RFRST_INIT_VALUE)
+
+/******************************************************************************
+ ==== SWRSTCR1 ====
+******************************************************************************/
+#define	SWRSTCR1	0xFCFE0460	/* SWRSTCR1 Address */
+#define	SWRSTCR1_INIT	(0x00)		/* Initialize */
+#define	SWRSTCR1_SRST11	(1<<1)		/* SSIF5SRST */
+#define	SWRSTCR1_SRST12 (1<<2)		/* SSIF4SRST */
+#define	SWRSTCR1_SRST13 (1<<3)		/* SSIF3SRST */
+#define	SWRSTCR1_SRST14 (1<<4)		/* SSIF2SRST */
+#define	SWRSTCR1_SRST15 (1<<5)		/* SSIF1SRST */
+#define	SWRSTCR1_SRST16 (1<<6)		/* SSIF0SRST */
+#define	SWRSTCR1_AXTALE (1<<7)		/* AXTALE    */
+
+/************************************************************************
+	external prototype declaration
+************************************************************************/
+extern struct snd_soc_platform_driver scu_platform;
+extern struct scu_route_info *scu_get_route_info(void);
+extern struct scu_platform_data *scu_get_platform_data(void);
+extern void scu_init_ssi(int, int, int, int, int);
+extern void scu_init_src(int, unsigned int, unsigned int);
+extern void scu_init_dvc(int);
+extern void scu_deinit_ssi(int, int, int, int);
+extern void scu_deinit_src(int);
+extern void scu_deinit_dvc(int);
+extern int scu_check_route(int dir, struct scu_route_info *routeinfo);
+extern int scu_dai_add_control(struct snd_card *card);
+
+#endif /* SH_SCUX_H */
diff --git a/include/video/vdc5fb.h b/include/video/vdc5fb.h
new file mode 100644
index 0000000..a679549
--- /dev/null
+++ b/include/video/vdc5fb.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2013-2014 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _VDC5FB_H_
+#define _VDC5FB_H_
+
+#ifdef __KERNEL__
+
+#include <linux/fb.h>
+
+/* NUMBER OF CHANNELS */
+#define	VDC5FB_NUM_CH		2
+
+/* NUMBER OF RESOURCES */
+#define	VDC5FB_NUM_RES		3
+/* MEM resource 0 is used for registers */
+/* MEM resource 1 is used for framebuffer(s) */
+/* IRQ resource 0 is used for irq numbers */
+
+/* BASE ADDRESS AND SIZE OF REGISTERS */
+#define	VDC5FB_REG_BASE(x)	(0xFCFF6000 + (0x2000 * (x)))
+#define	VDC5FB_REG_SIZE		0x2000
+
+/* START AND TOTAL NUMBER OF IRQS */
+#define	VDC5FB_IRQ_BASE(x)	(75 + (24 * (x)))
+#define	VDC5FB_IRQ_SIZE		23
+
+/* clock_source */
+enum {
+	ICKSEL_INPSEL = 0,
+	ICKSEL_EXTCLK0,
+	ICKSEL_EXTCLK1,
+	ICKSEL_P1CLK,
+};
+
+/* tcon_sel */
+enum {				/* index */
+	LCD_TCON0 = 0,
+	LCD_TCON1,
+	LCD_TCON2,
+	LCD_TCON3,
+	LCD_TCON4,
+	LCD_TCON5,
+	LCD_TCON6,
+	LCD_MAX_TCON,
+};
+#define	TCON_SEL_STVA		0	/* STVA/VS */
+#define	TCON_SEL_STVB		1	/* STVB/VE */
+#define	TCON_SEL_STH		2	/* STH/SP/HS */
+#define	TCON_SEL_STB		3	/* STB/LP/HE */
+#define	TCON_SEL_CPV		4	/* CPV/GCK */
+#define	TCON_SEL_POLA		5	/* POLA */
+#define	TCON_SEL_POLB		6	/* POLB */
+#define	TCON_SEL_DE		7	/* DE */
+#define	TCON_SEL_UNUSED		0xff
+
+/* out_format */
+#define	OUT_FORMAT_RGB888	0
+#define	OUT_FORMAT_RGB666	1
+#define	OUT_FORMAT_RGB565	2
+
+/* board-specific data */
+struct vdc5fb_pdata {
+	const char *name;
+	struct fb_videomode *videomode;
+	int bpp;		/* should be 16 or 32 */
+	int panel_icksel;	/* should be ICKSEL_P1CLK */
+	unsigned long panel_width;
+	unsigned long panel_height;
+	unsigned long flm_max;
+	int out_format;
+	int use_lvds;
+	int flags;
+#define	FLAGS_RESIZE	0x01	/* enable resize */
+#define	FLAGS_RETIMING	0x02	/* enable resize */
+#define	FLAGS_DS	0x04	/* enable down-scale */
+	unsigned char tcon_sel[LCD_MAX_TCON];
+/* board specific setting function */
+	int (*pinmux)(struct platform_device *pdev);
+};
+#endif /* __KERNEL__ */
+
+/*****************/
+/* VDC5FB IOCTLs */
+/*****************/
+
+#define	FBIOGET_CONTRAST	_IOR('F', 0x21, int)
+#define	FBIOPUT_CONTRAST	_IOW('F', 0x22, int)
+#define	FBIOGET_BRIGHT		_IOR('F', 0x23, int)
+#define	FBIOPUT_BRIGHT		_IOW('F', 0x24, int)
+#define	FBIOGET_FRAME		_IOW('F', 0x25, int)
+#define	FBIOPUT_FRAME		_IOW('F', 0x26, int)
+
+struct fbio_bright {
+	unsigned short pbrt_r;	/* 0-1023, inclusive */
+	unsigned short pbrt_g;
+	unsigned short pbrt_b;
+};
+
+struct fbio_contrast {
+	unsigned short cont_r;	/* 0-255, inclusive */
+	unsigned short cont_g;
+	unsigned short cont_b;
+};
+
+struct fbio_frame {
+	unsigned short fr_num;	/* 0-(frame_max-1), inclusive */
+	unsigned short fr_max;
+};
+
+#endif /* _VDC5FB_H_ */
diff --git a/scripts/link-vmlinux.sh b/scripts/link-vmlinux.sh
index 2dcb377..9df7f8c 100644
--- a/scripts/link-vmlinux.sh
+++ b/scripts/link-vmlinux.sh
@@ -83,7 +83,13 @@ kallsyms()
 	fi
 
 	if [ -n "${CONFIG_ARM}" ] && [ -n "${CONFIG_PAGE_OFFSET}" ]; then
-		kallsymopt="${kallsymopt} --page-offset=$CONFIG_PAGE_OFFSET"
+		if [ -n "${CONFIG_XIP_KERNEL}" ]; then
+			# For XIP Kernels, the kernel starts 16M below RAM
+			# See arch/arm/include/asm/memory.h
+			kallsymopt="${kallsymopt} --page-offset=$(printf \"%X\" $[$CONFIG_PAGE_OFFSET-0x01000000])"
+		else
+			kallsymopt="${kallsymopt} --page-offset=$CONFIG_PAGE_OFFSET"
+		fi
 	fi
 
 	local aflags="${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL}               \
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 983d087a..31b1e4c 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -51,6 +51,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_MAX98090 if I2C
 	select SND_SOC_MAX98095 if I2C
 	select SND_SOC_MAX9850 if I2C
+	select SND_SOC_MAX9856 if I2C
 	select SND_SOC_MAX9768 if I2C
 	select SND_SOC_MAX9877 if I2C
 	select SND_SOC_MC13783 if MFD_MC13XXX
@@ -301,6 +302,9 @@ config SND_SOC_MAX98095
 config SND_SOC_MAX9850
 	tristate
 
+config SND_SOC_MAX9856
+	tristate
+
 config SND_SOC_HDMI_CODEC
        tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index bc12676..86c9ea8 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -40,6 +40,7 @@ snd-soc-max98088-objs := max98088.o
 snd-soc-max98090-objs := max98090.o
 snd-soc-max98095-objs := max98095.o
 snd-soc-max9850-objs := max9850.o
+snd-soc-max9856-objs := max9856.o
 snd-soc-mc13783-objs := mc13783.o
 snd-soc-ml26124-objs := ml26124.o
 snd-soc-hdmi-codec-objs := hdmi.o
@@ -173,6 +174,7 @@ obj-$(CONFIG_SND_SOC_MAX98088)	+= snd-soc-max98088.o
 obj-$(CONFIG_SND_SOC_MAX98090)	+= snd-soc-max98090.o
 obj-$(CONFIG_SND_SOC_MAX98095)	+= snd-soc-max98095.o
 obj-$(CONFIG_SND_SOC_MAX9850)	+= snd-soc-max9850.o
+obj-$(CONFIG_SND_SOC_MAX9856)	+= snd-soc-max9856.o
 obj-$(CONFIG_SND_SOC_MC13783)	+= snd-soc-mc13783.o
 obj-$(CONFIG_SND_SOC_ML26124)	+= snd-soc-ml26124.o
 obj-$(CONFIG_SND_SOC_HDMI_CODEC) += snd-soc-hdmi-codec.o
diff --git a/sound/soc/codecs/max9856.c b/sound/soc/codecs/max9856.c
new file mode 100644
index 0000000..1ee593e
--- /dev/null
+++ b/sound/soc/codecs/max9856.c
@@ -0,0 +1,532 @@
+/*
+ * max9856.c  --  codec driver for max9856
+ *
+ * Copyright (C) 2011 taskit GmbH
+ *
+ * Author: Christian Glindkamp <christian.glindkamp@taskit.de>
+ *
+ * Initial development of this code was funded by
+ * MICRONIC Computer Systeme GmbH, http://www.mcsberlin.de/
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "max9856.h"
+
+struct max9856_priv {
+	struct regmap *regmap;
+	unsigned int sysclk;
+};
+
+/* max9856 register cache */
+static const struct reg_default max9856_reg[] = {
+	{ 0x02, 0x00 },
+	{ 0x03, 0x00 },
+	{ 0x04, 0x00 },
+	{ 0x05, 0x00 },
+	{ 0x06, 0x00 },
+	{ 0x07, 0x00 },
+	{ 0x08, 0x00 },
+	{ 0x09, 0x00 },
+	{ 0x0a, 0x00 },
+	{ 0x0b, 0x00 },
+	{ 0x0c, 0x00 },
+	{ 0x0d, 0x00 },
+	{ 0x0e, 0x08 },
+	{ 0x0f, 0x04 },
+	{ 0x10, 0x11 },
+	{ 0x11, 0x00 },
+	{ 0x12, 0x00 },
+	{ 0x13, 0x00 },
+	{ 0x14, 0x00 },
+	{ 0x15, 0x00 },
+	{ 0x16, 0x00 },
+	{ 0x17, 0x00 },
+	{ 0x18, 0x00 },
+	{ 0x19, 0x00 },
+	{ 0x1a, 0x00 },
+	{ 0x1b, 0x00 },
+	{ 0x1c, 0xbf },
+};
+
+/* these registers are not used at the moment but provided for the sake of
+ * completeness */
+static bool max9856_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MAX9856_STATUSA:
+	case MAX9856_STATUSB:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static const struct regmap_config max9856_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = MAX9856_PM,
+	.volatile_reg = max9856_volatile_register,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static const DECLARE_TLV_DB_SCALE(max9856_adc_gain_tlv, -1200, 100, 0);
+static const DECLARE_TLV_DB_SCALE(max9856_pgal_tlv, -3200, 200, 0);
+static const unsigned int max9856_pgam_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0xB, 0x1f, TLV_DB_SCALE_ITEM(0, 100, 0),
+};
+
+static const unsigned int max9856_pgads_tlv[] = {
+	TLV_DB_RANGE_HEAD(6),
+	0x1A, 0x2F, TLV_DB_SCALE_ITEM(-4000, 50, 0),
+	0x30, 0x5F, TLV_DB_SCALE_ITEM(-2900, 25, 0),
+	0x60, 0x7F, TLV_DB_SCALE_ITEM(-1700, 15, 0),
+	0x80, 0xCF, TLV_DB_SCALE_ITEM(-1200, 10, 0),
+	0xD0, 0xFE, TLV_DB_SCALE_ITEM(-350, 7, 0),
+	0xFF, 0xFF, TLV_DB_SCALE_ITEM(0, 0, 0),
+};
+
+static const unsigned int max9856_hpvol_tlv[] = {
+	TLV_DB_RANGE_HEAD(4),
+	0x18, 0x1f, TLV_DB_SCALE_ITEM(-7400, 400, 0),
+	0x20, 0x33, TLV_DB_SCALE_ITEM(-4200, 200, 0),
+	0x34, 0x37, TLV_DB_SCALE_ITEM(-200, 100, 0),
+	0x38, 0x3f, TLV_DB_SCALE_ITEM(200, 50, 0),
+};
+
+static const struct snd_kcontrol_new max9856_controls[] = {
+SOC_SINGLE_TLV("ADC Out Volume", MAX9856_ADC_LEVEL, 4, 0xf, 1, max9856_adc_gain_tlv),
+SOC_SINGLE_TLV("Digital Audio Input Volume", MAX9856_DIGITAL_GAIN, 0, 0xff, 1, max9856_pgads_tlv),
+SOC_SINGLE_TLV("PGAAUX Volume", MAX9856_AUXIN_GAIN, 0, 0x1f, 1, max9856_pgal_tlv),
+SOC_SINGLE_TLV("LINEIN1 Volume", MAX9856_LINEIN1_GAIN, 0, 0x1f, 1, max9856_pgal_tlv),
+SOC_SINGLE_TLV("LINEIN2 Volume", MAX9856_LINEIN2_GAIN, 0, 0x1f, 1, max9856_pgal_tlv),
+SOC_SINGLE_TLV("PGAML Volume", MAX9856_MICL_GAIN, 0, 0x1f, 1, max9856_pgam_tlv),
+SOC_SINGLE_TLV("Headphone Left Volume", MAX9856_HPL_VOL, 0, 0x3f, 1, max9856_hpvol_tlv),
+SOC_SINGLE_TLV("Headphone Right Volume", MAX9856_HPR_VOL, 0, 0x3f, 1, max9856_hpvol_tlv),
+};
+
+/* Left Output Mixer Switch */
+static const struct snd_kcontrol_new max9856_lout_mixer_controls[] = {
+	SOC_DAPM_SINGLE("DAC Switch", MAX9856_MIX_OUT,
+		MAX9856_MIX_OUT_MXOUTL_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEIN2 Switch", MAX9856_MIX_OUT,
+		MAX9856_MIX_OUT_MXOUTL_SHIFT + 1, 1, 0),
+	SOC_DAPM_SINGLE("LINEIN1 Switch", MAX9856_MIX_OUT,
+		MAX9856_MIX_OUT_MXOUTL_SHIFT + 2, 1, 0),
+	SOC_DAPM_SINGLE("MIC PGA Switch", MAX9856_MIX_OUT,
+		MAX9856_MIX_OUT_MXOUTL_SHIFT + 3, 1, 0),
+};
+
+/* Right Output Mixer Switch */
+static const struct snd_kcontrol_new max9856_rout_mixer_controls[] = {
+	SOC_DAPM_SINGLE("DAC Switch", MAX9856_MIX_OUT,
+		MAX9856_MIX_OUT_MXOUTR_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEIN2 Switch", MAX9856_MIX_OUT,
+		MAX9856_MIX_OUT_MXOUTR_SHIFT + 1, 1, 0),
+	SOC_DAPM_SINGLE("LINEIN1 Switch", MAX9856_MIX_OUT,
+		MAX9856_MIX_OUT_MXOUTR_SHIFT + 2, 1, 0),
+	SOC_DAPM_SINGLE("MIC PGA Switch", MAX9856_MIX_OUT,
+		MAX9856_MIX_OUT_MXOUTR_SHIFT + 3, 1, 0),
+};
+
+/* Left Input Mixer Switch */
+static const struct snd_kcontrol_new max9856_lin_mixer_controls[] = {
+	SOC_DAPM_SINGLE("MICR Switch", MAX9856_MIX_IN_L, 0, 1, 0),
+	SOC_DAPM_SINGLE("MICL Switch", MAX9856_MIX_IN_L, 1, 1, 0),
+	SOC_DAPM_SINGLE("LINEIN2 Switch", MAX9856_MIX_IN_L, 2, 1, 0),
+	SOC_DAPM_SINGLE("LINEIN1 Switch", MAX9856_MIX_IN_L, 3, 1, 0),
+	SOC_DAPM_SINGLE("AUXIN Switch", MAX9856_MIX_IN_L, 4, 1, 0),
+};
+
+/* Right Input Mixer Switch */
+static const struct snd_kcontrol_new max9856_rin_mixer_controls[] = {
+	SOC_DAPM_SINGLE("MICR Switch", MAX9856_MIX_IN_R, 0, 1, 0),
+	SOC_DAPM_SINGLE("MICL Switch", MAX9856_MIX_IN_R, 1, 1, 0),
+	SOC_DAPM_SINGLE("LINEIN2 Switch", MAX9856_MIX_IN_R, 2, 1, 0),
+	SOC_DAPM_SINGLE("LINEIN1 Switch", MAX9856_MIX_IN_R, 3, 1, 0),
+	SOC_DAPM_SINGLE("AUXIN Switch", MAX9856_MIX_IN_R, 4, 1, 0),
+};
+
+
+static const struct snd_soc_dapm_widget max9856_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DACL", "HiFi Playback", MAX9856_PM, MAX9856_PM_DALEN_SHIFT, 0),
+	SND_SOC_DAPM_DAC("DACR", "HiFi Playback", MAX9856_PM, MAX9856_PM_DAREN_SHIFT, 0),
+	SND_SOC_DAPM_ADC("ADCL", "HiFi Capture", MAX9856_PM, MAX9856_PM_ADLEN_SHIFT, 0),
+	SND_SOC_DAPM_ADC("ADCR", "HiFi Capture", MAX9856_PM, MAX9856_PM_ADREN_SHIFT, 0),
+	SND_SOC_DAPM_OUTPUT("OUTL"),
+	SND_SOC_DAPM_OUTPUT("OUTR"),
+	SND_SOC_DAPM_OUTPUT("HPL"),
+	SND_SOC_DAPM_OUTPUT("HPR"),
+	SND_SOC_DAPM_INPUT("LINEIN1"),
+	SND_SOC_DAPM_INPUT("LINEIN2"),
+	SND_SOC_DAPM_INPUT("AUXIN"),
+	SND_SOC_DAPM_INPUT("MICL"),
+	SND_SOC_DAPM_INPUT("MICR"),
+	SND_SOC_DAPM_INPUT("INR"),
+	SND_SOC_DAPM_MIXER("Left Input Mixer", SND_SOC_NOPM, 0, 0,
+		&max9856_lin_mixer_controls[0],
+		ARRAY_SIZE(max9856_lin_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Input Mixer", SND_SOC_NOPM, 0, 0,
+		&max9856_rin_mixer_controls[0],
+		ARRAY_SIZE(max9856_rin_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Left Output Mixer", SND_SOC_NOPM, 0, 0,
+		&max9856_lout_mixer_controls[0],
+		ARRAY_SIZE(max9856_lout_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Output Mixer", SND_SOC_NOPM, 0, 0,
+		&max9856_rout_mixer_controls[0],
+		ARRAY_SIZE(max9856_rout_mixer_controls)),
+};
+
+static const struct snd_soc_dapm_route max9856_dapm_routes[] = {
+	/* Left Output mixer */
+	{"Left Output Mixer", "MIC PGA Switch", "MICL"},
+	{"Left Output Mixer", "LINEIN1 Switch", "LINEIN1"},
+	{"Left Output Mixer", "LINEIN2 Switch", "LINEIN2"},
+	{"Left Output Mixer", "DAC Switch", "DACL"},
+
+	/* Right Output mixer */
+	{"Right Output Mixer", "MIC PGA Switch", "MICR"},
+	{"Right Output Mixer", "LINEIN1 Switch", "LINEIN1"},
+	{"Right Output Mixer", "LINEIN2 Switch", "LINEIN2"},
+	{"Right Output Mixer", "DAC Switch", "DACR"},
+
+	/* Left Input mixer */
+	{"Left Input Mixer", "AUXIN Switch", "AUXIN"},
+	{"Left Input Mixer", "LINEIN1 Switch", "LINEIN1"},
+	{"Left Input Mixer", "LINEIN2 Switch", "LINEIN2"},
+	{"Left Input Mixer", "MICL Switch", "MICL"},
+	{"Left Input Mixer", "MICR Switch", "MICR"},
+
+	/* Right Input mixer */
+	{"Right Input Mixer", "AUXIN Switch", "AUXIN"},
+	{"Right Input Mixer", "LINEIN1 Switch", "LINEIN1"},
+	{"Right Input Mixer", "LINEIN2 Switch", "LINEIN2"},
+	{"Right Input Mixer", "MICL Switch", "MICL"},
+	{"Right Input Mixer", "MICR Switch", "MICR"},
+
+	/* Output Pins */
+	{"HPL", NULL, "Left Output Mixer"},
+	{"HPR", NULL, "Right Output Mixer"},
+	{"OUTL", NULL, "Left Output Mixer"},
+	{"OUTR", NULL, "Right Output Mixer"},
+
+	/* ADC */
+	{"ADCL", NULL, "Left Input Mixer"},
+	{"ADCR", NULL, "Right Input Mixer"},
+};
+
+static int max9856_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max9856_priv *max9856 = snd_soc_codec_get_drvdata(codec);
+	u64 lrclk_div;
+	u8 mclk_div, clock, dac;
+
+	if (!max9856->sysclk)
+		return -EINVAL;
+
+	/* DACNI = (65536 x 96 x LRCLK_D ) / PSCLK */
+	/* PSCLK = MCLK / mclk_div */
+	clock = snd_soc_read(codec, MAX9856_CLOCK);
+	switch(clock & MAX9856_CLOCK_PSCLK(7)) {
+	case MAX9856_CLOCK_PSCLK(1):
+	case MAX9856_CLOCK_PSCLK(2):
+		mclk_div = 1;
+		break;
+	case MAX9856_CLOCK_PSCLK(3):
+	case MAX9856_CLOCK_PSCLK(4):
+		mclk_div = 2;
+		break;
+	case MAX9856_CLOCK_PSCLK(5):
+		mclk_div = 4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	lrclk_div = 6291456;
+	lrclk_div *= params_rate(params);
+	lrclk_div *= mclk_div;
+	do_div(lrclk_div, max9856->sysclk);
+
+	/* Since we use the same LRCLK for both ADC and DAC, only change DACNI */
+	snd_soc_write(codec, MAX9856_DAC_INTA, (lrclk_div >> 8) & 0x7f);
+	snd_soc_write(codec, MAX9856_DAC_INTB, lrclk_div & 0xff);
+
+	switch (params_width(params)) {
+	case 16:
+		dac = 0;
+		break;
+	case 18:
+	case 20:
+		dac = MAX9856_DAC_SYS_WS;
+		break;
+	default:
+		return -EINVAL;
+	}
+	snd_soc_update_bits(codec, MAX9856_DAC_SYS, MAX9856_DAC_SYS_WS, dac);
+
+	return 0;
+}
+
+static int max9856_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct max9856_priv *max9856 = snd_soc_codec_get_drvdata(codec);
+	u8 clock = 0;
+
+	/* MCLK to PSCLK divider */
+	if (freq <= 10000000)
+		return -EINVAL;
+	else if (freq <= 16000000)
+		clock = MAX9856_CLOCK_PSCLK(1);
+	else if (freq <= 20000000)
+		clock = MAX9856_CLOCK_PSCLK(2);
+	else if (freq <= 32000000)
+		clock = MAX9856_CLOCK_PSCLK(3);
+	else if (freq <= 40000000)
+		clock = MAX9856_CLOCK_PSCLK(4);
+	else if (freq <= 60000000)
+		clock = MAX9856_CLOCK_PSCLK(5);
+	else
+		return -EINVAL;
+
+	snd_soc_update_bits(codec, MAX9856_CLOCK, MAX9856_CLOCK_PSCLK(7), clock);
+
+	max9856->sysclk = freq;
+	return 0;
+}
+
+static int max9856_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u8 dac_sys = 0;
+	u8 adc_sys = 0;
+	u8 clock = 0;
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clock |= MAX9856_CLOCK_MAS;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dac_sys |= MAX9856_DAC_SYS_DDLY;
+		adc_sys |= MAX9856_ADC_SYS_ADLY;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		dac_sys |= MAX9856_DAC_SYS_DBCI | MAX9856_DAC_SYS_DWCI;
+		adc_sys |= MAX9856_ADC_SYS_ABCI | MAX9856_ADC_SYS_AWCI;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dac_sys |= MAX9856_DAC_SYS_DBCI;
+		adc_sys |= MAX9856_ADC_SYS_ABCI;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		dac_sys |= MAX9856_DAC_SYS_DWCI;
+		adc_sys |= MAX9856_ADC_SYS_AWCI;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_update_bits(codec, MAX9856_DAC_SYS, 0xF8, dac_sys);
+	snd_soc_update_bits(codec, MAX9856_ADC_SYS, 0xC8, adc_sys);
+	snd_soc_update_bits(codec, MAX9856_CLOCK, MAX9856_CLOCK_MAS, clock);
+
+	return 0;
+}
+
+static int max9856_set_bias_level(struct snd_soc_codec *codec,
+				  enum snd_soc_bias_level level)
+{
+	struct max9856_priv *max9856 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			ret = regcache_sync(max9856->regmap);
+			if (ret) {
+				dev_err(codec->dev,
+					"Failed to sync cache: %d\n", ret);
+				return ret;
+			}
+		}
+		break;
+	case SND_SOC_BIAS_OFF:
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+#define MAX9856_RATES SNDRV_PCM_RATE_8000_48000
+
+#define MAX9856_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE)
+
+static const struct snd_soc_dai_ops max9856_dai_ops = {
+	.hw_params	= max9856_hw_params,
+	.set_sysclk	= max9856_set_dai_sysclk,
+	.set_fmt	= max9856_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver max9856_dai = {
+	.name = "max9856-hifi",
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = MAX9856_RATES,
+		.formats = MAX9856_FORMATS
+	},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = MAX9856_RATES,
+		.formats = MAX9856_FORMATS
+	},
+	.ops = &max9856_dai_ops,
+	.symmetric_rates = 1,
+};
+
+#ifdef CONFIG_PM
+static int max9856_suspend(struct snd_soc_codec *codec)
+{
+	max9856_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+static int max9856_resume(struct snd_soc_codec *codec)
+{
+	max9856_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return 0;
+}
+#else
+#define max9856_suspend NULL
+#define max9856_resume NULL
+#endif
+
+static int max9856_probe(struct snd_soc_codec *codec)
+{
+	int ret;
+
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+
+	snd_soc_write(codec, MAX9856_PM, 0xbf);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_max9856 = {
+	.probe =	max9856_probe,
+	.suspend =	max9856_suspend,
+	.resume =	max9856_resume,
+	.set_bias_level = max9856_set_bias_level,
+
+	.controls = max9856_controls,
+	.num_controls = ARRAY_SIZE(max9856_controls),
+	.dapm_widgets = max9856_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(max9856_dapm_widgets),
+	.dapm_routes = max9856_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(max9856_dapm_routes),
+};
+
+static int max9856_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct max9856_priv *max9856;
+	int ret;
+
+	max9856 = devm_kzalloc(&i2c->dev, sizeof(struct max9856_priv),
+			       GFP_KERNEL);
+	if (max9856 == NULL)
+		return -ENOMEM;
+
+	max9856->regmap = devm_regmap_init_i2c(i2c, &max9856_regmap);
+	if (IS_ERR(max9856->regmap))
+		return PTR_ERR(max9856->regmap);
+
+	i2c_set_clientdata(i2c, max9856);
+
+	ret = snd_soc_register_codec(&i2c->dev,
+			&soc_codec_dev_max9856, &max9856_dai, 1);
+
+	return ret;
+}
+
+static int max9856_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id max9856_i2c_id[] = {
+	{ "max9856", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max9856_i2c_id);
+
+static struct i2c_driver max9856_i2c_driver = {
+	.driver = {
+		.name = "max9856",
+		.owner = THIS_MODULE,
+	},
+	.probe = max9856_i2c_probe,
+	.remove = max9856_i2c_remove,
+	.id_table = max9856_i2c_id,
+};
+
+module_i2c_driver(max9856_i2c_driver);
+
+MODULE_AUTHOR("Christian Glindkamp <christian.glindkamp@taskit.de>");
+MODULE_DESCRIPTION("ASoC MAX9856 codec driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/max9856.h b/sound/soc/codecs/max9856.h
new file mode 100644
index 0000000..f594f4b
--- /dev/null
+++ b/sound/soc/codecs/max9856.h
@@ -0,0 +1,80 @@
+/*
+ * max9856.h  --  codec driver for max9856
+ *
+ * Copyright (C) 2011 taskit GmbH
+ * Author: Christian Glindkamp <christian.glindkamp@taskit.de>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _MAX9856_H
+#define _MAX9856_H
+
+#define MAX9856_STATUSA			0x00
+#define MAX9856_STATUSB			0x01
+#define MAX9856_INTERRUPT		0x02
+#define MAX9856_CLOCK			0x03
+#define MAX9856_DAC_SYS			0x04
+#define MAX9856_DAC_INTA		0x05
+#define MAX9856_DAC_INTB		0x06
+#define MAX9856_ADC_SYS			0x07
+#define MAX9856_ADC_INTA		0x08
+#define MAX9856_ADC_INTB		0x09
+#define MAX9856_ADC_LEVEL		0x0A
+#define MAX9856_HPF			0x0B
+#define MAX9856_AGC_CONTROL		0x0C
+#define MAX9856_AGC_THRESH		0x0D
+#define MAX9856_MIX_IN_L		0x0E
+#define MAX9856_MIX_IN_R		0x0F
+#define MAX9856_MIX_OUT			0x10
+#define MAX9856_DIGITAL_GAIN		0x11
+#define MAX9856_AUXIN_GAIN		0x12
+#define MAX9856_LINEIN1_GAIN		0x13
+#define MAX9856_LINEIN2_GAIN		0x14
+#define MAX9856_MICL_GAIN		0x15
+#define MAX9856_MICR_GAIN		0x16
+#define MAX9856_MIC_MODE		0x17
+#define MAX9856_HPL_VOL			0x18
+#define MAX9856_HPR_VOL			0x19
+#define MAX9856_OUT_MODE		0x1A
+#define MAX9856_HEADSET			0x1B
+#define MAX9856_PM			0x1C
+
+#define MAX9856_CACHEREGNUM 29
+
+#define MAX9856_CLOCK_PSCLK(n)		((n & 0x7) << 4)
+#define MAX9856_CLOCK_MAS		(1 << 3)
+#define MAX9856_CLOCK_BSEL(n)		((n & 0x7) << 0)
+
+#define MAX9856_DAC_SYS_DWCI		(1 << 7)
+#define MAX9856_DAC_SYS_DBCI		(1 << 6)
+#define MAX9856_DAC_SYS_DRATE(n)	((n & 0x3) << 4)
+#define MAX9856_DAC_SYS_DDLY		(1 << 3)
+#define MAX9856_DAC_SYS_PCM		(1 << 2)
+#define MAX9856_DAC_SYS_DHF		(1 << 1)
+#define MAX9856_DAC_SYS_WS		(1 << 0)
+
+#define MAX9856_ADC_SYS_AWCI		(1 << 7)
+#define MAX9856_ADC_SYS_ABCI		(1 << 6)
+#define MAX9856_ADC_SYS_APIN_GPI	(0 << 4)
+#define MAX9856_ADC_SYS_APIN_WC		(1 << 4)
+#define MAX9856_ADC_SYS_APIN_GPO_L	(2 << 4)
+#define MAX9856_ADC_SYS_APIN_GPO_H	(3 << 4)
+#define MAX9856_ADC_SYS_ADLY		(1 << 3)
+
+#define MAX9856_MIX_OUT_MXOUTL_SHIFT	(4)
+#define MAX9856_MIX_OUT_MXOUTR_SHIFT	(0)
+
+#define MAX9856_PM_SHDN_SHIFT		(7)
+#define MAX9856_PM_DIGEN_SHIFT		(5)
+#define MAX9856_PM_LOUTEN_SHIFT		(4)
+#define MAX9856_PM_DALEN_SHIFT		(3)
+#define MAX9856_PM_DAREN_SHIFT		(2)
+#define MAX9856_PM_ADLEN_SHIFT		(1)
+#define MAX9856_PM_ADREN_SHIFT		(0)
+
+#endif
diff --git a/sound/soc/codecs/wm8978.c b/sound/soc/codecs/wm8978.c
index d8fc531..89e3cb0 100644
--- a/sound/soc/codecs/wm8978.c
+++ b/sound/soc/codecs/wm8978.c
@@ -1,6 +1,7 @@
 /*
  * wm8978.c  --  WM8978 ALSA SoC Audio Codec driver
  *
+ * Copyright (C) 2013  Renesas Solutions Corp.
  * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
  * Copyright (C) 2007 Carlos Munoz <carlos@kenati.com>
  * Copyright 2006-2009 Wolfson Microelectronics PLC.
@@ -27,7 +28,7 @@
 #include <sound/initval.h>
 #include <sound/tlv.h>
 #include <asm/div64.h>
-
+#include <linux/spi/spi.h>
 #include "wm8978.h"
 
 static const struct reg_default wm8978_reg_defaults[] = {
@@ -150,10 +151,11 @@ static const struct snd_kcontrol_new wm8978_snd_controls[] = {
 
 	SOC_DOUBLE("DAC Inversion Switch", WM8978_DAC_CONTROL, 0, 1, 1, 0),
 
+#if !defined(CONFIG_MACH_RSKRZA1) /* The volume of a codec is not changed, either, when the volume of DVU is changed.  */
 	SOC_DOUBLE_R_TLV("PCM Volume",
 		WM8978_LEFT_DAC_DIGITAL_VOLUME, WM8978_RIGHT_DAC_DIGITAL_VOLUME,
 		0, 255, 0, digital_tlv),
-
+#endif
 	SOC_SINGLE("High Pass Filter Switch", WM8978_ADC_CONTROL, 8, 1, 0),
 	SOC_SINGLE("High Pass Cut Off", WM8978_ADC_CONTROL, 4, 7, 0),
 	SOC_DOUBLE("ADC Inversion Switch", WM8978_ADC_CONTROL, 0, 1, 1, 0),
@@ -751,6 +753,7 @@ static int wm8978_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	/* filter coefficient */
+#if !defined(CONFIG_MACH_RSKRZA1) /* codec setup is fixed to 44100Hz */
 	switch (params_rate(params)) {
 	case 8000:
 		add_ctl |= 0x5 << 1;
@@ -771,9 +774,14 @@ static int wm8978_hw_params(struct snd_pcm_substream *substream,
 	case 48000:
 		break;
 	}
+#endif
 
 	/* Sampling rate is known now, can configure the MCLK divider */
+#if defined(CONFIG_MACH_RSKRZA1) /* codec setup is fixed to 44100Hz */
+	wm8978->f_256fs = 44100 * 256;
+#else
 	wm8978->f_256fs = params_rate(params) * 256;
+#endif
 
 	if (wm8978->sysclk == WM8978_MCLK) {
 		wm8978->mclk_idx = -1;
@@ -976,7 +984,6 @@ static int wm8978_probe(struct snd_soc_codec *codec)
 {
 	struct wm8978_priv *wm8978 = snd_soc_codec_get_drvdata(codec);
 	int ret = 0, i;
-
 	/*
 	 * Set default system clock to PLL, it is more precise, this is also the
 	 * default hardware setting
@@ -1035,9 +1042,8 @@ static const struct regmap_config wm8978_regmap_config = {
 	.reg_defaults = wm8978_reg_defaults,
 	.num_reg_defaults = ARRAY_SIZE(wm8978_reg_defaults),
 };
-
-static int wm8978_i2c_probe(struct i2c_client *i2c,
-			    const struct i2c_device_id *id)
+#if !(defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+static int wm8978_i2c_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 {
 	struct wm8978_priv *wm8978;
 	int ret;
@@ -1062,7 +1068,7 @@ static int wm8978_i2c_probe(struct i2c_client *i2c,
 		dev_err(&i2c->dev, "Failed to issue reset: %d\n", ret);
 		return ret;
 	}
-
+	
 	ret = snd_soc_register_codec(&i2c->dev,
 			&soc_codec_dev_wm8978, &wm8978_dai, 1);
 	if (ret != 0) {
@@ -1095,8 +1101,97 @@ static struct i2c_driver wm8978_i2c_driver = {
 	.remove =   wm8978_i2c_remove,
 	.id_table = wm8978_i2c_id,
 };
+#else /* !(defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1)) */
+/* RSPI4 is Registration */
+static int wm8978_rspi_probe(struct spi_device *rspi)
+{
+	struct wm8978_priv *wm8978;
+	int ret;
+
+	wm8978 = devm_kzalloc(&rspi->dev, sizeof(struct wm8978_priv), GFP_KERNEL);
+	if (wm8978 == NULL){
+		pr_warn(KERN_WARNING "error:wm8978_rspi_probe():NULL.\n");
+		return -ENOMEM;
+	}
+
+	wm8978->regmap = devm_regmap_init_spi(rspi, &wm8978_regmap_config);
+	if (IS_ERR(wm8978->regmap)) {
+		ret = PTR_ERR(wm8978->regmap);
+		dev_err(&rspi->dev, "Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+
+	spi_set_drvdata(rspi, wm8978);
+	
+	/* Reset the codec */
+	ret = regmap_write(wm8978->regmap, WM8978_RESET, 0);
+	if (ret != 0) {
+		dev_err(&rspi->dev, "Failed to issue reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_register_codec(&rspi->dev,&soc_codec_dev_wm8978, &wm8978_dai, 1);
+
+	if (ret != 0) {
+		dev_err(&rspi->dev, "Failed to register CODEC: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int wm8978_rspi_remove(struct spi_device *rspi)
+{
+	snd_soc_unregister_codec(&rspi->dev);
+	return 0;
+}
+
+static struct spi_driver wm8978_rspi_driver = {
+	.driver = {
+		.name	= "wm8978",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm8978_rspi_probe,
+	.remove		= wm8978_rspi_remove,
+};
+#endif /* !(defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1)) */
+
+static int __init wm8978_modinit(void)
+{
+	int ret = 0;
+	
+#if (defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+	ret = spi_register_driver(&wm8978_rspi_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to register wm8978 RSPI driver: %d\n",
+		       ret);
+	}else{
+		printk(KERN_WARNING "wm8978_modinit(). OK \n");
+	}
+#else
+	ret = i2c_add_driver(&wm8978_i2c_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to register wm8978 I2C driver: %d\n",
+		       ret);
+	}
+#endif
+
+	return ret;
+}
+
+module_init(wm8978_modinit);
+
+static void __exit wm8978_exit(void)
+{
+#if (defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+	spi_unregister_driver(&wm8978_rspi_driver);
+#else
+	i2c_del_driver(&wm8978_i2c_driver);
+#endif
+
+}
 
-module_i2c_driver(wm8978_i2c_driver);
+module_exit(wm8978_exit);
 
 MODULE_DESCRIPTION("ASoC WM8978 codec driver");
 MODULE_AUTHOR("Guennadi Liakhovetski <g.liakhovetski@gmx.de>");
diff --git a/sound/soc/sh/Kconfig b/sound/soc/sh/Kconfig
index ff60e11..659c06e 100644
--- a/sound/soc/sh/Kconfig
+++ b/sound/soc/sh/Kconfig
@@ -41,6 +41,12 @@ config SND_SOC_RCAR
 	help
 	  This option enables R-Car SUR/SCU/SSIU/SSI sound support
 
+config SND_SOC_SCUX
+	tristate
+	depends on ARCH_R7S72100
+	select DMA_ENGINE
+	select DMADEVICES
+
 ##
 ## Boards
 ##
@@ -62,4 +68,33 @@ config SND_SIU_MIGOR
 	help
 	  This option enables sound support for the SH7722 Migo-R board
 
+config SND_SCUX_GENMAI
+	tristate "SCUX sound support on GENMAI"
+	depends on ARCH_R7S72100
+	select SND_SOC_SCUX
+	select SND_SCUX_WM8978
+
+	help
+	  Enable sound support for the RZA1 GENMAI board.
+	  This is supported to the Renesas SCUX peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
+config SND_SCUX_WM8978
+        tristate "GENMAI WM8978 sound support"
+        depends on SND_SCUX_GENMAI
+        select SND_SOC_WM8978
+
+config SND_SCUX_RSKRZA1
+	tristate "SCUX sound support on RSK-RZA1"
+	depends on ARCH_R7S72100
+	select SND_SOC_SCUX
+	select SND_SOC_MAX9856
+
+	help
+	  Enable sound support for the RSK-RZA1 board.
+	  This is supported to the Renesas SCUX peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
 endmenu
diff --git a/sound/soc/sh/Makefile b/sound/soc/sh/Makefile
index aaf3dcd..89cd73b 100644
--- a/sound/soc/sh/Makefile
+++ b/sound/soc/sh/Makefile
@@ -7,10 +7,12 @@ snd-soc-hac-objs	:= hac.o
 snd-soc-ssi-objs	:= ssi.o
 snd-soc-fsi-objs	:= fsi.o
 snd-soc-siu-objs	:= siu_pcm.o siu_dai.o
+snd-soc-scux-objs	:= scux_pcm.o scux_dai.o
 obj-$(CONFIG_SND_SOC_SH4_HAC)	+= snd-soc-hac.o
 obj-$(CONFIG_SND_SOC_SH4_SSI)	+= snd-soc-ssi.o
 obj-$(CONFIG_SND_SOC_SH4_FSI)	+= snd-soc-fsi.o
 obj-$(CONFIG_SND_SOC_SH4_SIU)	+= snd-soc-siu.o
+obj-$(CONFIG_SND_SOC_SCUX)	+= snd-soc-scux.o
 
 ## audio units for R-Car
 obj-$(CONFIG_SND_SOC_RCAR)	+= rcar/
@@ -18,6 +20,10 @@ obj-$(CONFIG_SND_SOC_RCAR)	+= rcar/
 ## boards
 snd-soc-sh7760-ac97-objs	:= sh7760-ac97.o
 snd-soc-migor-objs		:= migor.o
+snd-soc-genmai-objs		:= genmai.o
+snd-soc-rskrza1-objs		:= rskrza1.o
 
 obj-$(CONFIG_SND_SH7760_AC97)	+= snd-soc-sh7760-ac97.o
 obj-$(CONFIG_SND_SIU_MIGOR)	+= snd-soc-migor.o
+obj-$(CONFIG_SND_SCUX_GENMAI)	+= snd-soc-genmai.o
+obj-$(CONFIG_SND_SCUX_RSKRZA1)	+= snd-soc-rskrza1.o
diff --git a/sound/soc/sh/genmai.c b/sound/soc/sh/genmai.c
new file mode 100644
index 0000000..5c3665c
--- /dev/null
+++ b/sound/soc/sh/genmai.c
@@ -0,0 +1,603 @@
+/*
+ * sound/soc/sh/genmai.c
+ *     This file is ALSA SoC driver for genmai.
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/migor.c
+ *
+ * ALSA SoC driver for Migo-R
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/sh_scux.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+static struct scu_route_info *routeinfo;
+
+int scu_check_route(int dir, struct scu_route_info *routeinfo)
+{
+	if (!dir) { /* playback */
+		if (routeinfo->p_route != RP_MEM_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC1_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC1_DVC1_SSI0) {
+			pr_info("scu playback route is invalid.\n");
+			return -EPERM;
+		}
+	} else { /* capture */
+		if (routeinfo->c_route != RC_SSI0_MEM &&
+		    routeinfo->c_route != RC_SSI0_SRC0_MEM) {
+			pr_info("scu capture route is invalid.\n");
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scu_check_route);
+
+/************************************************************************
+
+	DAPM
+
+************************************************************************/
+#undef EV_PRINT
+#ifdef EV_PRINT
+static void event_print(int event, char *evt_str)
+{
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMD\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMD\n", evt_str);
+		break;
+	default:
+		snd_printk(KERN_INFO "%s unknown event\n", evt_str);
+	}
+}
+#else
+#define event_print(a, b)
+#endif
+
+static int event_ssi0(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		/* playback */
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+		/* add capture */
+		routeinfo->ccb.init_ssi = scu_init_ssi;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		/* playback */
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+		/* add capture */
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src0(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_ssi = scu_init_ssi;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_dvc1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+
+static int event_src0(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_src = scu_init_src;
+		routeinfo->ccb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_src = NULL;
+		routeinfo->ccb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src;
+		routeinfo->pcb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1_dvc1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src;
+		routeinfo->pcb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_dvc1(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_dvc = scu_init_dvc;
+		routeinfo->pcb.deinit_dvc = scu_deinit_dvc;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_dvc = NULL;
+		routeinfo->pcb.deinit_dvc = NULL;
+	}
+	return 0;
+}
+
+static void scu_playback_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT1");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT2");
+
+	switch (routeinfo->p_route) {
+	case RP_MEM_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT0");
+		break;
+	case RP_MEM_SRC1_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT1");
+		break;
+	case RP_MEM_SRC1_DVC1_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT2");
+		break;
+	default:
+		break;
+	};
+}
+
+static void scu_capture_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_IN0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_IN1");
+
+	switch (routeinfo->c_route) {
+	case RC_SSI0_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_IN0");
+		break;
+	case RC_SSI0_SRC0_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_IN1");
+		break;
+	default:
+		break;
+	};
+}
+
+static int scu_get_ssi0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_ssi[0];
+
+	return 0;
+}
+
+static int scu_set_ssi0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_ssi[0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[0] = ucontrol->value.integer.value[0];
+
+	if (routeinfo->route_ssi[0])
+		routeinfo->p_route |= RP_MEM_SSI0;
+	else
+		routeinfo->p_route &= ~RP_MEM_SSI0;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_set_ssi0_caproute(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	DBG_MSG("start:scu_set_ssi0_caproute");
+	if (routeinfo->route_ssi[0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[0] = ucontrol->value.integer.value[0];
+
+	if (routeinfo->route_ssi[0])
+		routeinfo->c_route |= RC_SSI0_MEM;
+	else
+		routeinfo->c_route &= ~RC_SSI0_MEM;
+
+	scu_capture_route_control(&card->dapm);
+	return 1;
+}
+
+static int scu_get_src0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[SRC0];
+
+	return 0;
+}
+
+static int scu_set_src0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[SRC0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[SRC0] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[SRC0])
+		routeinfo->c_route |= W_SRC0;
+	else
+		routeinfo->c_route &= ~W_SRC0;
+
+	scu_capture_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_src1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[SRC1];
+
+	return 0;
+}
+static int scu_set_src1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[SRC1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[SRC1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[SRC1])
+		routeinfo->p_route |= W_SRC1;
+	else
+		routeinfo->p_route &= ~W_SRC1;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_dvc1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_dvc[DVC1];
+
+	return 0;
+}
+
+static int scu_set_dvc1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_dvc[DVC1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_dvc[DVC1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_dvc[DVC1])
+		routeinfo->p_route |= W_DVC1;
+	else
+		routeinfo->p_route &= ~W_DVC1;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static const char * const widget_switch[] = {"Off", "On"};
+
+static const struct soc_enum widget_switch_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(widget_switch), widget_switch);
+
+static const struct snd_kcontrol_new playback_controls[] = {
+	SOC_ENUM_EXT("SSI0 Control", widget_switch_enum,
+	scu_get_ssi0_route, scu_set_ssi0_route),
+	SOC_ENUM_EXT("SRC1 Control", widget_switch_enum,
+	scu_get_src1_route, scu_set_src1_route),
+	SOC_ENUM_EXT("DVC1 Control", widget_switch_enum,
+	scu_get_dvc1_route, scu_set_dvc1_route),
+};
+
+static const struct snd_kcontrol_new capture_controls[] = {
+	SOC_ENUM_EXT("SSI0 CapControl", widget_switch_enum,
+	scu_get_ssi0_route, scu_set_ssi0_caproute),
+	SOC_ENUM_EXT("SRC0 Control", widget_switch_enum,
+	scu_get_src0_route, scu_set_src0_route),
+};
+
+static const struct snd_soc_dapm_widget genmai_dapm_widgets[] = {
+	/* Playback */
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT0"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT1"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT2"),
+	SND_SOC_DAPM_DAC("MEM_OUT", "HiFi Playback", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_src1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("src1_dvc1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src1_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+
+	/* Capture */
+	SND_SOC_DAPM_ADC("MEM_IN", "HiFi Capture", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_INPUT("SSI0_IN0"),
+	SND_SOC_DAPM_INPUT("SSI0_IN1"),
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_src0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Playback route */
+	/* SSI<-MEM */
+	{"SSI0", NULL, "MEM_OUT"},
+	{"SSI0_OUT0", NULL, "SSI0"},
+	/* SSI<-SRC<-MEM */
+	{"SRC1", NULL, "MEM_OUT"},
+	{"SSI0_SRC1", NULL, "SRC1"},
+	{"SSI0_OUT1", NULL, "SSI0_SRC1"},
+	/* SSI<-DVC<-SRC<-MEM */
+	{"DVC1", NULL, "SRC1"},
+	{"SSI0_DVC1", NULL, "DVC1"},
+	{"SSI0_OUT2", NULL, "SSI0_DVC1"},
+
+	/* Capture route */
+	/* MEM<-SSI */
+	{"SSI0", NULL, "SSI0_IN0"},
+	{"MEM_IN", NULL, "SSI0"},
+	/* MEM<-SRC<-SSI */
+	{"SSI0_SRC0", NULL, "SSI0_IN1"},
+	{"SRC0", NULL, "SSI0_SRC0"},
+	{"MEM_IN", NULL, "SRC0"},
+};
+
+/************************************************************************
+
+	ALSA SoC
+
+************************************************************************/
+static int genmai_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret;
+
+	/* set PLL clock */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, 11289600, SND_SOC_CLOCK_IN);
+	if (ret) {
+		pr_err("snd_soc_dai_set_sysclk err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_CBS_CFS |
+				  SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF);
+	if (ret) {
+		pr_err("snd_soc_dai_set_fmt err=%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int genmai_hw_free(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static struct snd_soc_ops genmai_dai_ops = {
+	.hw_params = genmai_hw_params,
+	.hw_free = genmai_hw_free,
+};
+
+static int genmai_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int ret;
+
+	FNC_ENTRY
+
+	/* Add controls */
+	ret = snd_soc_add_card_controls(rtd->card, playback_controls,
+					ARRAY_SIZE(playback_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(playback) err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_add_card_controls(rtd->card, capture_controls,
+					ARRAY_SIZE(capture_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(capture) err=%d\n", ret);
+		return ret;
+	}
+
+	/* Add widget and route for scu */
+	ret = snd_soc_dapm_new_controls(dapm, genmai_dapm_widgets,
+					ARRAY_SIZE(genmai_dapm_widgets));
+	if (ret) {
+		pr_err("snd_soc_dapm_new_controls err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+	if (ret) {
+		pr_err("snd_soc_dapm_add_routes err=%d\n", ret);
+		return ret;
+	}
+
+	scu_playback_route_control(dapm);
+	scu_capture_route_control(dapm);
+
+	FNC_EXIT
+	return ret;
+}
+/* genmai digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link genmai_dai = {
+	.name		= "wm8978",		/* Codec name */
+	.stream_name	= "WM8978",		/* Stream name */
+	.cpu_dai_name	= "scu-ssi-dai",	/* DAI name of the CPU DAI*/
+	.codec_dai_name	= "wm8978-hifi",	/* DAI name within the codec */
+	.platform_name	= "scux-pcm-audio.0",	/* device name */
+#if (defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RSKRZA1))
+	.codec_name	= "spi4.0",		/* device name */
+#else
+	.codec_name	= "wm8978.0-001a",	/* device name */
+#endif
+	.ops		= &genmai_dai_ops,	/* machine stream operations */
+	.init		= genmai_dai_init,	/* machine specific init */
+};
+
+/* genmai audio machine driver */
+static struct snd_soc_card snd_soc_genmai = {
+	.name = "genmai-wm8978",
+	.owner = THIS_MODULE,
+	.dai_link = &genmai_dai,
+	.num_links = 1,
+};
+
+static int genmai_probe(struct platform_device *pdev)
+{
+	int ret = -ENOMEM;
+
+	FNC_ENTRY
+
+	routeinfo = scu_get_route_info();
+
+	snd_soc_genmai.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_soc_genmai);
+
+	if (ret)
+		pr_err("Unable to register sourd card\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct platform_driver genmai_alsa_driver = {
+	.driver = {
+		.name = "genmai_alsa_soc_platform",
+		.owner = THIS_MODULE,
+	},
+	.probe = genmai_probe,
+};
+
+module_platform_driver(genmai_alsa_driver);
+
+MODULE_AUTHOR(" Renesas Solutions Corp.");
+MODULE_DESCRIPTION("ALSA SoC GENMAI");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/sh/rskrza1.c b/sound/soc/sh/rskrza1.c
new file mode 100644
index 0000000..72c8afd
--- /dev/null
+++ b/sound/soc/sh/rskrza1.c
@@ -0,0 +1,604 @@
+/*
+ * sound/soc/sh/rskrza1.c
+ *     This file is ALSA SoC driver for rskrza1.
+ *
+ * Copyright (C) 2014 Renesas Solutions Corp.
+ * Copyright (C) 2014 Renesas Electronics Corporation
+ * Copyright (C) 2014 Timesys Corporation
+ *
+ * This file is based on the sound/soc/sh/rskrza1.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/sh_scux.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+static struct scu_route_info *routeinfo;
+
+int scu_check_route(int dir, struct scu_route_info *routeinfo)
+{
+	if (!dir) { /* playback */
+		if (routeinfo->p_route != RP_MEM_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC1_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC1_DVC1_SSI0) {
+			pr_info("scu playback route is invalid.\n");
+			return -EPERM;
+		}
+	} else { /* capture */
+		if (routeinfo->c_route != RC_SSI0_MEM &&
+		    routeinfo->c_route != RC_SSI0_SRC0_MEM) {
+			pr_info("scu capture route is invalid.\n");
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scu_check_route);
+
+/************************************************************************
+
+	DAPM
+
+************************************************************************/
+#undef EV_PRINT
+#ifdef EV_PRINT
+static void event_print(int event, char *evt_str)
+{
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMD\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMD\n", evt_str);
+		break;
+	default:
+		snd_printk(KERN_INFO "%s unknown event\n", evt_str);
+	}
+}
+#else
+#define event_print(a, b)
+#endif
+
+static int event_ssi0(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		/* playback */
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+		/* add capture */
+		routeinfo->ccb.init_ssi = scu_init_ssi;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		/* playback */
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+		/* add capture */
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src0(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_ssi = scu_init_ssi;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_dvc1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+
+static int event_src0(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_src = scu_init_src;
+		routeinfo->ccb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_src = NULL;
+		routeinfo->ccb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src;
+		routeinfo->pcb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1_dvc1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src;
+		routeinfo->pcb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_dvc1(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_dvc = scu_init_dvc;
+		routeinfo->pcb.deinit_dvc = scu_deinit_dvc;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_dvc = NULL;
+		routeinfo->pcb.deinit_dvc = NULL;
+	}
+	return 0;
+}
+
+static void scu_playback_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT1");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT2");
+
+	switch (routeinfo->p_route) {
+	case RP_MEM_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT0");
+		break;
+	case RP_MEM_SRC1_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT1");
+		break;
+	case RP_MEM_SRC1_DVC1_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT2");
+		break;
+	default:
+		break;
+	};
+}
+
+static void scu_capture_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_IN0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_IN1");
+
+	switch (routeinfo->c_route) {
+	case RC_SSI0_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_IN0");
+		break;
+	case RC_SSI0_SRC0_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_IN1");
+		break;
+	default:
+		break;
+	};
+}
+
+static int scu_get_ssi0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_ssi[0];
+
+	return 0;
+}
+
+static int scu_set_ssi0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_ssi[0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[0] = ucontrol->value.integer.value[0];
+
+	if (routeinfo->route_ssi[0])
+		routeinfo->p_route |= RP_MEM_SSI0;
+	else
+		routeinfo->p_route &= ~RP_MEM_SSI0;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_ssi0_caproute(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_ssi[1];
+
+	return 0;
+}
+
+static int scu_set_ssi0_caproute(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	DBG_MSG("start:scu_set_ssi0_caproute");
+	if (routeinfo->route_ssi[1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[1] = ucontrol->value.integer.value[0];
+
+	if (routeinfo->route_ssi[1])
+		routeinfo->c_route |= RC_SSI0_MEM;
+	else
+		routeinfo->c_route &= ~RC_SSI0_MEM;
+
+	scu_capture_route_control(&card->dapm);
+	return 1;
+}
+
+static int scu_get_src0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[SRC0];
+
+	return 0;
+}
+
+static int scu_set_src0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[SRC0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[SRC0] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[SRC0])
+		routeinfo->c_route |= W_SRC0;
+	else
+		routeinfo->c_route &= ~W_SRC0;
+
+	scu_capture_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_src1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[SRC1];
+
+	return 0;
+}
+static int scu_set_src1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[SRC1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[SRC1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[SRC1])
+		routeinfo->p_route |= W_SRC1;
+	else
+		routeinfo->p_route &= ~W_SRC1;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_dvc1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_dvc[DVC1];
+
+	return 0;
+}
+
+static int scu_set_dvc1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_dvc[DVC1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_dvc[DVC1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_dvc[DVC1])
+		routeinfo->p_route |= W_DVC1;
+	else
+		routeinfo->p_route &= ~W_DVC1;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static const char * const widget_switch[] = {"Off", "On"};
+
+static const struct soc_enum widget_switch_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(widget_switch), widget_switch);
+
+static const struct snd_kcontrol_new playback_controls[] = {
+	SOC_ENUM_EXT("SSI0 Control", widget_switch_enum,
+	scu_get_ssi0_route, scu_set_ssi0_route),
+	SOC_ENUM_EXT("SRC1 Control", widget_switch_enum,
+	scu_get_src1_route, scu_set_src1_route),
+	SOC_ENUM_EXT("DVC1 Control", widget_switch_enum,
+	scu_get_dvc1_route, scu_set_dvc1_route),
+};
+
+static const struct snd_kcontrol_new capture_controls[] = {
+	SOC_ENUM_EXT("SSI0 CapControl", widget_switch_enum,
+	scu_get_ssi0_caproute, scu_set_ssi0_caproute),
+	SOC_ENUM_EXT("SRC0 Control", widget_switch_enum,
+	scu_get_src0_route, scu_set_src0_route),
+};
+
+static const struct snd_soc_dapm_widget rskrza1_dapm_widgets[] = {
+	/* Playback */
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT0"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT1"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT2"),
+	SND_SOC_DAPM_DAC("MEM_OUT", "HiFi Playback", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_src1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("src1_dvc1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src1_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+
+	/* Capture */
+	SND_SOC_DAPM_ADC("MEM_IN", "HiFi Capture", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_INPUT("SSI0_IN0"),
+	SND_SOC_DAPM_INPUT("SSI0_IN1"),
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_src0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Playback route */
+	/* SSI<-MEM */
+	{"SSI0", NULL, "MEM_OUT"},
+	{"SSI0_OUT0", NULL, "SSI0"},
+	/* SSI<-SRC<-MEM */
+	{"SRC1", NULL, "MEM_OUT"},
+	{"SSI0_SRC1", NULL, "SRC1"},
+	{"SSI0_OUT1", NULL, "SSI0_SRC1"},
+	/* SSI<-DVC<-SRC<-MEM */
+	{"DVC1", NULL, "SRC1"},
+	{"SSI0_DVC1", NULL, "DVC1"},
+	{"SSI0_OUT2", NULL, "SSI0_DVC1"},
+
+	/* Capture route */
+	/* MEM<-SSI */
+	{"SSI0", NULL, "SSI0_IN0"},
+	{"MEM_IN", NULL, "SSI0"},
+	/* MEM<-SRC<-SSI */
+	{"SSI0_SRC0", NULL, "SSI0_IN1"},
+	{"SRC0", NULL, "SSI0_SRC0"},
+	{"MEM_IN", NULL, "SRC0"},
+};
+
+/************************************************************************
+
+	ALSA SoC
+
+************************************************************************/
+static int rskrza1_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret;
+
+	/* set PLL clock */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, 22579200, SND_SOC_CLOCK_IN);
+	if (ret) {
+		pr_err("snd_soc_dai_set_sysclk err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_CBS_CFS |
+				  SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF);
+	if (ret) {
+		pr_err("snd_soc_dai_set_fmt err=%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int rskrza1_hw_free(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static struct snd_soc_ops rskrza1_dai_ops = {
+	.hw_params = rskrza1_hw_params,
+	.hw_free = rskrza1_hw_free,
+};
+
+static int rskrza1_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int ret;
+
+	FNC_ENTRY
+
+	/* Add controls */
+	ret = snd_soc_add_card_controls(rtd->card, playback_controls,
+					ARRAY_SIZE(playback_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(playback) err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_add_card_controls(rtd->card, capture_controls,
+					ARRAY_SIZE(capture_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(capture) err=%d\n", ret);
+		return ret;
+	}
+
+	/* Add widget and route for scu */
+	ret = snd_soc_dapm_new_controls(dapm, rskrza1_dapm_widgets,
+					ARRAY_SIZE(rskrza1_dapm_widgets));
+	if (ret) {
+		pr_err("snd_soc_dapm_new_controls err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+	if (ret) {
+		pr_err("snd_soc_dapm_add_routes err=%d\n", ret);
+		return ret;
+	}
+
+	scu_playback_route_control(dapm);
+	scu_capture_route_control(dapm);
+
+	FNC_EXIT
+	return ret;
+}
+/* rskrza1 digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link rskrza1_dai = {
+	.name		= "max9856",		/* Codec name */
+	.stream_name	= "MAX9856",		/* Stream name */
+	.cpu_dai_name	= "scux-pcm-audio.0",	/* DAI name of the CPU DAI*/
+	.codec_dai_name	= "max9856-hifi",	/* DAI name within the codec */
+	.platform_name	= "scux-pcm-audio.0",	/* device name */
+	.codec_name	= "max9856.3-0010",	/* device name */
+	.ops		= &rskrza1_dai_ops,	/* machine stream operations */
+	.init		= rskrza1_dai_init,	/* machine specific init */
+};
+
+/* rskrza1 audio machine driver */
+static struct snd_soc_card snd_soc_rskrza1 = {
+	.name = "rskrza1-max9856",
+	.owner = THIS_MODULE,
+	.dai_link = &rskrza1_dai,
+	.num_links = 1,
+};
+
+static int rskrza1_probe(struct platform_device *pdev)
+{
+	int ret = -ENOMEM;
+
+	FNC_ENTRY
+
+	routeinfo = scu_get_route_info();
+
+	snd_soc_rskrza1.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_soc_rskrza1);
+
+	if (ret)
+		pr_err("Unable to register sound card\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct platform_driver rskrza1_alsa_driver = {
+	.driver = {
+		.name = "rskrza1_alsa_soc_platform",
+		.owner = THIS_MODULE,
+	},
+	.probe = rskrza1_probe,
+};
+
+module_platform_driver(rskrza1_alsa_driver);
+
+MODULE_AUTHOR(" Renesas Solutions Corp.");
+MODULE_DESCRIPTION("ALSA SoC GENMAI");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/sh/scux_dai.c b/sound/soc/sh/scux_dai.c
new file mode 100644
index 0000000..9ed4dcf
--- /dev/null
+++ b/sound/soc/sh/scux_dai.c
@@ -0,0 +1,1314 @@
+/*
+ * sound/soc/sh/scux_dai.c
+ *     This file is ALSA SoC driver for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/siu_dai.c
+ *
+ * siu_dai.c - ALSA SoC driver for Renesas SH7343, SH7722 SIU peripheral.
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/sh_scux.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static struct scux_reg_info *scux_reg;
+static spinlock_t *sculock;
+static struct scu_audio_info *ainfo;
+static struct scu_platform_data *pdata;
+
+int32_t getvolume0;
+int32_t getvolume1;
+
+struct scu_route_info *scu_get_route_info(void)
+{
+	return &ainfo->routeinfo;
+}
+EXPORT_SYMBOL(scu_get_route_info);
+
+struct scu_platform_data *scu_get_platform_data(void)
+{
+	return pdata;
+}
+EXPORT_SYMBOL(scu_get_platform_data);
+
+/************************************************************************
+	peripheral function
+************************************************************************/
+static void scu_ssif_softreset(int ch)
+{
+	u8 reg;
+
+	switch (ch) {
+	case 0:
+		writeb(SWRSTCR1_SRST16, (u32 *)SWRSTCR1); /* Soft Reset SSIF0 */
+		break;
+	case 1:
+		writeb(SWRSTCR1_SRST15, (u32 *)SWRSTCR1); /* Soft Reset SSIF1 */
+		break;
+	case 2:
+		writeb(SWRSTCR1_SRST14, (u32 *)SWRSTCR1); /* Soft Reset SSIF2 */
+		break;
+	case 3:
+		writeb(SWRSTCR1_SRST13, (u32 *)SWRSTCR1); /* Soft Reset SSIF3 */
+		break;
+	case 4:
+		writeb(SWRSTCR1_SRST12, (u32 *)SWRSTCR1); /* Soft Reset SSIF4 */
+		break;
+	case 5:
+		writeb(SWRSTCR1_SRST11, (u32 *)SWRSTCR1); /* Soft Reset SSIF5 */
+		break;
+	}
+	udelay(10);
+	writeb(SWRSTCR1_INIT, (u32 *)SWRSTCR1);
+	udelay(10);
+	reg = readb((u32 *)SWRSTCR1);	/* dummy read */
+}
+
+static void scu_ssif_init(void)
+{
+	FNC_ENTRY
+
+	/* SSI TDM Mode Register Setting */
+	writel(SSI_SSITDMR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssitdmr);
+	/* SSI Control register setting */
+	writel(SSI_SSICR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssicr);
+	/* SSI FIFO Control register setting */
+	writel(SSI_SSIFCR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssifcr);
+	/* SSI Status register clear */
+	writel(0, &scux_reg->ssifreg[0]->ssisr);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_control(int master_ch, int slave_ch, int mode)
+{
+	FNC_ENTRY
+	/* SSI setting */
+	if ((readl(&scux_reg->ssifreg[master_ch]->ssicr) & SSICR_ENABLE) == 0) {
+		writel(SSICR_PLAY_WM8978_ST,
+			&scux_reg->ssifreg[master_ch]->ssicr);
+		writel(SSITDMR_CONT_EN, &scux_reg->ssifreg[master_ch]->ssitdmr);
+	}
+	if ((mode == SSI_SLAVE) &&
+	    ((readl(&scux_reg->ssifreg[slave_ch]->ssicr) & SSICR_ENABLE) == 0))
+		writel(SSICR_CAP_WM8978_ST,
+			&scux_reg->ssifreg[slave_ch]->ssicr);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_start(int ssi_ch, int ssi_dir)
+{
+	u32 val;
+
+	FNC_ENTRY
+
+	if (ssi_dir == SSI_OUT) {
+		/* SSI enable (figure.39.12 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= (SSICR_TUIEN | SSICR_TOIEN);
+		val &= ~(SSICR_IIEN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = (SSIFCR_TIE | SSIFCR_RFRST);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= SSICR_TEN_EN;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+	} else { /* ssi_dir == SSI_IN */
+		/* SSI enable (figure.39.14 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= (SSICR_RUIEN | SSICR_ROIEN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = (SSIFCR_RIE | SSIFCR_TFRST);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= SSICR_REN_EN;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_stop(int ssi_ch, int ssi_dir)
+{
+	u32 val;
+	int tmout;
+
+	FNC_ENTRY
+
+	if (ssi_dir == SSI_OUT) {
+		/* SSI disable (figure.39.13 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val &= ~(SSICR_TUIEN | SSICR_TOIEN | SSICR_TEN_EN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = SSI_SSIFCR_BASE_INIT_VALUE;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		tmout = 1000;
+		while (--tmout &&
+		       !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IIRQ))
+			udelay(1);
+		if (!tmout)
+			tmout = 1000;
+		while (--tmout &&
+		       !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IDST))
+			udelay(1);
+		if (!tmout)
+			pr_info("timeout waiting for SSI idle\n");
+
+	} else { /* ssi_dir == SSI_IN */
+		/* SSI disable (figure.39.15 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val &= ~(SSICR_RUIEN | SSICR_ROIEN | SSICR_REN_EN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = SSI_SSIFCR_BASE_INIT_VALUE;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		tmout = 1000;
+		while (--tmout &&
+		       !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IDST))
+			udelay(1);
+		if (!tmout)
+			pr_info("timeout waiting for SSI idle\n");
+	}
+
+	scu_ssif_softreset(ssi_ch);
+
+	FNC_EXIT
+}
+
+static void scu_src_control(int src_ch, unsigned int rate, unsigned int sync_sw)
+{
+	u32 reg, futsel;
+
+	FNC_ENTRY
+
+	/* SRC0 is capture,SRC1 is playback */
+	/* Return to prohibit the enable register of sending and receiving */
+	reg = readl(&scux_reg->ssifreg[0]->ssicr);
+	reg &= ~(SSICR_TEN_EN | SSICR_REN_EN);
+	writel(reg, &scux_reg->ssifreg[0]->ssicr);
+
+	/* 1.SCUX RESET:when DVU is already reset from scu_init_dvc() */
+	if (ainfo->routeinfo.p_route != RP_MEM_SRC1_DVC1_SSI0) {
+		writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);
+		udelay(10);
+		writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);
+		udelay(10);
+	}
+
+	/* Capture route */
+	if (src_ch == SRC0) {
+		/* 2.Setting the transfer route */
+		/* FFD and FFU route Setting */
+		writel(FFDPR_NO_PASS_SELECT, &scux_reg->ffdreg[src_ch]->ffdpr);
+		writel(FFUPR_CIM_FFU_OPC_ASYNC,
+			&scux_reg->ffureg[src_ch]->ffupr);
+
+		/* IPC and OPC route Setting */
+		writel(IPSLR_SSIF_IPC_ASYNC, &scux_reg->ipcreg[src_ch]->ipslr);
+		writel(OPSLR_ASYNC_OPC_FFU, &scux_reg->opcreg[src_ch]->opslr);
+
+		/* SSIF route choice */
+		reg = readl(&scux_reg->cimreg->ssirsel_cim);
+		reg &= SSIRSEL_SISEL0_USE_SSIF0;
+		writel(reg, &scux_reg->cimreg->ssirsel_cim);
+
+		/* SRCRSELn_CIM (n=0,1,2,3), MIXRSEL_CIM */
+		/* NO SETTING */
+
+		/* SSICTRL_CIM is Direct send setting */
+		reg = readl((u32 *)&scux_reg->cimreg->ssictrl_cim);
+		reg |= SSICTRL_SSI0RX_EN;
+		writel(reg, &scux_reg->cimreg->ssictrl_cim);
+
+		/* 3.Setting of timing */
+		/* FUTSELn_CIM SCKDIV setting ,AUDIO_X1(22579200Hz) / Fout */
+		reg = AUDIO_X1 / rate;
+		if (reg > SCKDIV_MAX)
+			reg = SCKDIV_MAX;
+
+		/* FFU0_0 : setting clock */
+		reg = (reg << 16);
+		reg |= FUTSEL_SCKSEL_AUIDIO_X1;
+		writel(reg, &scux_reg->cimreg->futsel0_cim);
+		futsel = reg;
+
+		/* FFD0_1 */
+		/* NO Setting */
+
+		/* 4.SSIF setting pin */
+		/* SSIPMD_CIM SSIF pinmode setting */
+		writel(SSIPMD_SSI0CKS, &scux_reg->cimreg->ssipmd_cim);
+
+		/* 5.FFD0_1 */
+		/* NO SETTING */
+
+		/* 6.FFU0_1 */
+		writel(FUAIR_AUDIO_CH_2, &scux_reg->ffureg[src_ch]->fuair);
+		writel(URQSR_CH0CH1_REQ_SIZE_256,
+			&scux_reg->ffureg[src_ch]->urqsr);
+		writel(UEVMR_VALUE, &scux_reg->ffureg[src_ch]->uevmr);
+
+		/* 7.SRCn */
+		writel(SRCBR_BYPASS_OFF, &scux_reg->srcreg[0]->srcbr0);
+		writel((SADIR_OTBL_16BIT | SADIR_AUDIO_CH_2),
+			&scux_reg->srcreg[0]->sadir0);
+
+		/* IFSCRp_2SRC0_m is used setting INTIFS */
+		writel(IFSCR_VALUE, &scux_reg->srcreg[0]->ifscr0);
+
+		/* IFSVRp_2SRC0_m is setting INTIFS */
+		switch (rate) {
+		case SRC_IFS_8KHZ:
+			reg = INTIFS_IN44K_OUT8K;
+			break;
+		case SRC_IFS_11KHZ:
+			reg = INTIFS_IN44K_OUT11K;
+			break;
+		case SRC_IFS_12KHZ:
+			reg = INTIFS_IN44K_OUT12K;
+			break;
+		case SRC_IFS_16KHZ:
+			reg = INTIFS_IN44K_OUT16K;
+			break;
+		case SRC_IFS_22KHZ:
+			reg = INTIFS_IN44K_OUT22K;
+			break;
+		case SRC_IFS_24KHZ:
+			reg = INTIFS_IN44K_OUT24K;
+			break;
+		case SRC_IFS_32KHZ:
+			reg = INTIFS_IN44K_OUT32K;
+			break;
+		default:
+		case SRC_IFS_44KHZ:
+			reg = INTIFS_IN44K_OUT44K;
+			break;
+		case SRC_IFS_48KHZ:
+			reg = INTIFS_IN44K_OUT48K;
+			break;
+		}
+		writel(reg, &scux_reg->srcreg[0]->ifsvr0);
+		writel((SRC_CR_BIT16 | SRC_CR_BIT8 | SRC_CR_BIT4),
+			&scux_reg->srcreg[0]->srccr0);
+		/* MNFSRp_2SRC0_m is setting minimum of FS */
+		/* MINFS = INITFS * 90% */
+		reg = reg * MIN_FS_RATIO_90 / MIN_FS_RATIO_100;
+		writel(reg, &scux_reg->srcreg[0]->mnfsr0);
+
+		/* BFSSRp_2SRC0_m NO Setting*/
+		/* WATSRp_2SRC0_m NO Setting */
+		/* SEVMRp_2SRC0_m NO Setting when transfer start*/
+
+		/* 8.DVUn */
+		/* DVU BYPASS setting */
+		/* NO SETTING */
+
+		/* 9.MIX */
+		/* MIX BYPASS setting */
+		/* NO SETTING */
+
+		/* DMA transfer setting */
+		reg = readl(&scux_reg->cimreg->dmacr_cim);
+		reg |= DMACR_DMAMDFFU0_EN;
+		writel(reg, &scux_reg->cimreg->dmacr_cim);
+
+		/* FFD Init off */
+		writel(FFDIR_INIT_OFF, &scux_reg->ffdreg[src_ch]->ffdir);
+
+		/* FFD BOOT */
+		writel(FFDBR_HALT_ON, &scux_reg->ffdreg[src_ch]->ffdbr);
+
+		/* FFU,SRC,IPC,OPC Init off */
+		writel(INIT_OFF, &scux_reg->ffureg[src_ch]->ffuir);
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcir0);
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcirr1);
+		writel(INIT_OFF, &scux_reg->ipcreg[src_ch]->ipcir);
+		writel(INIT_OFF, &scux_reg->opcreg[src_ch]->opcir);
+
+		/* Send start setting */
+		reg = readl(&scux_reg->ssifreg[0]->ssicr);
+		reg |= SSICR_REN_EN;
+		writel(reg, &scux_reg->ssifreg[0]->ssicr);
+		futsel |= FUTSEL_DIVEN_START;
+		writel(futsel, &scux_reg->cimreg->futsel0_cim);
+
+	} else if (src_ch == SRC1) {
+
+		reg = readl(&scux_reg->cimreg->ssirsel_cim);
+		reg |= SSIRSEL_SOSEL0_USE_SRC1;
+		/* 0xE8209738:SSIRSEL_CIM  SOSEL0 = 01b */
+		writel(reg, &scux_reg->cimreg->ssirsel_cim);
+		/* 0xE8208104:IPSLR_IPC0_n  IPC_PASS_SEL = 011b */
+		writel(IPSLR_FFD_IPC_ASYNC, &scux_reg->ipcreg[src_ch]->ipslr);
+		/* 0xE8208504:OPSLR_OPC0_n  OPC_PASS_SEL = 001b	 */
+		writel(OPSLR_ASYNC_OPC_DVU, &scux_reg->opcreg[src_ch]->opslr);
+		/* 0xE820890C:FFDPR_FFD0_n  PASS = 01b */
+		writel(FFDPR_CIM_FFD_IPC_ASYNC,
+			&scux_reg->ffdreg[src_ch]->ffdpr);
+		/* 0xE8208D0C:FFUPR_FFU0_n  PASS = 00b */
+		writel(FFUPR_NO_PASS_SELECT, &scux_reg->ffureg[src_ch]->ffupr);
+		/* 0xE820975C:SSIPMD_CIM    SSI345EN = 0, SSI012EN = 0 */
+		writel(THIS_CH_NOT_USED, &scux_reg->cimreg->ssipmd_cim);
+
+		/* SSICTRL_CIM is Direct send setting */
+		reg = readl((u32 *)&scux_reg->cimreg->ssictrl_cim);
+		/* SSICTRL_CIM  SSI3RX = 0, SSI3TX = 0	: value = 0xBBFFFFFF */
+		reg &= ~(SSICTRL_SSI3TX_EN | SSICTRL_SSI3RX_EN);
+		/* SSICTRL_CIM  SSI0TX = 1		: value = 0x00004000 */
+		reg |= SSICTRL_SSI0TX_EN;
+		/* 0xE8209760 : SSI0TX = 1 */
+		writel(reg, &scux_reg->cimreg->ssictrl_cim);
+
+		/* FDTSELn_CIM SCKDIV setting */
+		/* FDTSELn_CIM    SCKDIV = AUDIO_X1(22579200Hz) / Fin  */
+		/* FDTSELn_CIM SCKSEL = 0001b(AUDIO_X1) */
+		/* MNFSRp_2SRC0_m MINFS  = (2^22 * Fin / Fout) * 90% */
+		/* IFSVRp_2SRC0_m INTIFS = 2^22 * Fin / Fout  */
+		/* Fin = Input Rate, Fout = Output Rate(44100Hz) */
+		reg = AUDIO_X1 / rate;			/* FDTSELn_CIM SCKDIV */
+		if (reg > SCKDIV_MAX)
+			reg = SCKDIV_MAX;
+		reg = (reg << 16);
+		reg |= FDTSEL_SCKSEL_AUIDIO_X1;
+		writel(reg, &scux_reg->cimreg->fdtsel1_cim);
+
+		/* IFSVRp_2SRC0_m  INTIFS */
+		switch (rate) {
+		case SRC_IFS_8KHZ:
+			reg = INTIFS_IN8K_OUT44K;
+			break;
+		case SRC_IFS_11KHZ:
+			reg = INTIFS_IN11K_OUT44K;
+			break;
+		case SRC_IFS_12KHZ:
+			reg = INTIFS_IN12K_OUT44K;
+			break;
+		case SRC_IFS_16KHZ:
+			reg = INTIFS_IN16K_OUT44K;
+			break;
+		case SRC_IFS_22KHZ:
+			reg = INTIFS_IN22K_OUT44K;
+			break;
+		case SRC_IFS_24KHZ:
+			reg = INTIFS_IN24K_OUT44K;
+			break;
+		case SRC_IFS_32KHZ:
+			reg = INTIFS_IN32K_OUT44K;
+			break;
+		default:
+		case SRC_IFS_44KHZ:
+			reg = INTIFS_IN44K_OUT44K;
+			break;
+		case SRC_IFS_48KHZ:
+			reg = INTIFS_IN48K_OUT44K;
+			break;
+		}
+		writel(reg, &scux_reg->srcreg[0]->ifsvr1);
+		/* MNFSRp_2SRC0_m is setting minimum of FS */
+		/* MINFS = INITFS * 90% */
+		reg = reg * MIN_FS_RATIO_90 / MIN_FS_RATIO_100;
+		writel(reg, &scux_reg->srcreg[0]->mnfsr1);
+		writel(IFSCR_VALUE, &scux_reg->srcreg[0]->ifscr1);
+		/* FUTSELn_CIM NO Setting  */
+		/* FFD Setting */
+		/* 0xE8208904:FDAIR_FFD0_n CHNUM = 0010b(2 channel) */
+		writel(FDAIR_AUDIO_CH_2, &scux_reg->ffdreg[src_ch]->fdair);
+		/* 0xE8208908:DRQSR_FFD0_n SIZE = 0001b(256 data) */
+		writel(DRQSR_REQ_SIZE_256, &scux_reg->ffdreg[src_ch]->drqsr);
+		/* 0xE8208914:DEVMR_FFD0_n DEVMUF = 1, DEVMOF = 1, DEVMOL = 1,
+			      DEVMIUF = 1, DEVMRQ = 0 */
+		writel(DEVMR_VALUE, &scux_reg->ffdreg[src_ch]->devmr);
+
+		/* SRC Setting */
+		/* 0xE820903C:SRCBRp_2SRC0_m  BYPASS = 0 */
+		writel(SRCBR_BYPASS_OFF, &scux_reg->srcreg[0]->srcbr1);
+		/* 0xE8209038:SADIRp_2SRC0_m  OTBL = 01000(16 bit),
+					      CHNUM = 0010(2 channel) */
+		writel((SADIR_OTBL_16BIT | SADIR_AUDIO_CH_2),
+			&scux_reg->srcreg[0]->sadir1);
+		/* 0xE8209048:SRCCRp_2SRC0_m */
+		writel((SRC_CR_BIT16 | SRC_CR_BIT8 | SRC_CR_BIT4),
+			&scux_reg->srcreg[0]->srccr1);
+		/* BFSSRp_2SRC0_m NO Setting*/
+		/* WATSRp_2SRC0_m NO Setting */
+		/* SEVMRp_2SRC0_m NO Setting */
+
+		/* DVU Setting */
+		/* 0xE8209304:VADIR_DVU0_n  OTBL = 01000b(16 bit),
+					    CHNUM = 0010b(2 channel) */
+		writel((VADIR_OTBL_16BIT | VADIR_CHNUM_CH_2),
+			&scux_reg->dvureg[1]->vadir);
+		/* DVU BYPASS setting */
+		/* 0xE8209308:DVUBR_DVU0_n  BYPASS = 1 */
+		if (ainfo->routeinfo.p_route != RP_MEM_SRC1_DVC1_SSI0)
+			writel(DVUBR_BYPASS_ON, &scux_reg->dvureg[1]->dvubr);
+
+		/* MIX BYPASS setting */
+		/* 0xE8209608:MIXBR_MIX0_0  BPSYS 01b(Input Data of system B),
+			      BYPASS = 1 */
+		writel(MIXBR_BYPASS_ON, &scux_reg->mixreg->mdber);
+
+		/* DMA transfer setting */
+		reg = readl(&scux_reg->cimreg->dmacr_cim);
+		/* 0xE8209704:DMACR_CIM  DMAMDFFD1 = 1 */
+		reg |= DMACR_DMAMDFFD1_EN;
+		writel(reg, &scux_reg->cimreg->dmacr_cim);
+
+		/* FFD Init off */
+		/* 0xE8208900:FFDIR_FFD0_n  INIT = 0 */
+		writel(FFDIR_INIT_OFF, &scux_reg->ffdreg[src_ch]->ffdir);
+
+		/* FFD BOOT */
+		/* 0xE8208910:FFDBR_FFD0_n  BOOT = 1 */
+		writel(FFDBR_BOOT_ON, &scux_reg->ffdreg[src_ch]->ffdbr);
+
+		/* SRC,DVU,MIX,IPC,OPC Init off */
+		/* 0xE8208D00:FFUIR_FFU0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->ffureg[src_ch]->ffuir);
+		/* 0xE8209034:SRCIRp_2SRC0_m  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcir1);
+		/* 0xE8209068:SRCIRR_2SRC0_m  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcirr1);
+		/* 0xE8209300:DVUIR_DVU0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->dvureg[1]->dvuir);
+		/* 0xE8209600:MIXIR_MIX0_0  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->mixreg->mixir);
+		/* 0xE8208100:IPCIR_IPC0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->ipcreg[src_ch]->ipcir);
+		/* 0xE8208500:OPCIR_OPC0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->opcreg[src_ch]->opcir);
+		/* Send start setting */
+		reg = readl(&scux_reg->cimreg->fdtsel1_cim);
+		reg |= SCUX_FDTSEL_BIT_DIVEN;
+		/* 0xE8209740:FDTSELn_CIM  DIVEN = 1 */
+		writel(reg, &scux_reg->cimreg->fdtsel1_cim);
+
+		reg = readl(&scux_reg->ssifreg[0]->ssicr);
+		reg |= SSICR_TEN_EN;
+		writel(reg, &scux_reg->ssifreg[0]->ssicr);
+
+	} else
+		pr_info("error SRC CH:%d\n", src_ch);
+	FNC_EXIT
+	return;
+}
+
+static void scu_dvc_deinit(int dvc_ch)
+{
+	FNC_ENTRY
+
+	/* DVUIR : DVU init on */
+	/* 0xE8209300:DVUIR_INIT_ON  */
+	writel(DVUIR_INIT_ON, &scux_reg->dvureg[1]->dvuir);
+
+	FNC_EXIT
+	return;
+}
+
+void scu_dvc_control(int dvc_ch)
+{
+	FNC_ENTRY
+
+	/*  DVU_ADINR */
+	/* only stereo now */
+	/* DVU0_1 VADIR :0xE8209304  */
+	writel((VADIR_OTBL_16BIT | VADIR_CHNUM_CH_2),
+		(u32 *)&scux_reg->dvureg[dvc_ch]->vadir);
+
+	/*  DVU_DVUCR  DVU mode select */
+	/* DVU0_1 DVUCR :0xE820930C  */
+	writel((DVUCR_VVMD_USE | DVUCR_VRMD_USE),
+		(u32 *)&scux_reg->dvureg[dvc_ch]->dvucr);
+	/*  DVU_VRCTR volume ramp action setting */
+	/* DVU0_1 VRCTR : 0xE8209314 */
+	writel((VRCTR_VREN0_EN | VRCTR_VREN1_EN),
+		(u32 *)&scux_reg->dvureg[dvc_ch]->vrctr);
+
+	/* VRPDR volume ramp time setting */
+	/* DVU0_1 VRPDR : 0xE8209318 */	/* SCUX_VRPDR_BIT_VRPDUP */
+	writel((VRPDR_VRPDUP_PERIOD_1 | VRPDR_VRPDDW_PERIOD_1),
+		(u32 *)&scux_reg->dvureg[dvc_ch]->vrpdr);
+
+	/* volume ramp gain level setting */
+	/* DVU0_1 VRDBR : 0xE820931C */
+	writel(VRDBR_VRDB_0DB, (u32 *)&scux_reg->dvureg[dvc_ch]->vrdbr);
+
+	/* Digital Volume Function Parameter */
+	/* DVU0_1 VOL0R : 0xE8209324 */
+	writel(getvolume0, (u32 *)&scux_reg->dvureg[dvc_ch]->vol0r);
+	/* DVU0_1 VOL1R : 0xE8209328 */
+	writel(getvolume1, (u32 *)&scux_reg->dvureg[dvc_ch]->vol1r);
+
+	/* Zero Cross Mute Function */
+	/* DVU0_1 ZCMCR : 0xE8209310 */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->zcmcr);
+
+	/* VRWTR volume ramp wait time setting */
+	/* DVU0_1 VRWTR : 0xE8209320 */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->vrwtr);
+
+	/* vevmr SCUDVIn request intrrupt enable/disable setting */
+	/* DVU0_1 VERVMR : 0xE820934C */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->vevmr);
+
+	/* DVUER */
+	/* DVU0_1 DVUER : 0xE8209344 */
+	writel(DVUER_DVUEN_EN, (u32 *)&scux_reg->dvureg[dvc_ch]->dvuer);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_dvc_stop(int dvc_ch)
+{
+	FNC_ENTRY
+	/* DVU_DVUER */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->dvuer);
+	FNC_EXIT
+	return;
+}
+
+/************************************************************************
+
+	DAPM callback function
+
+************************************************************************/
+void scu_init_ssi(int master_ch, int slave_ch, int mode, int ind, int dir)
+{
+	int ch = (mode == SSI_MASTER) ? master_ch : slave_ch;
+
+	scu_ssif_softreset(ch);
+
+	/* SSI init */
+	scu_ssi_control(master_ch, slave_ch, mode);
+
+	/* SSI start */
+	scu_ssi_start(ch, dir);
+}
+EXPORT_SYMBOL(scu_init_ssi);
+
+void scu_deinit_ssi(int ch, int mode, int ind, int dir)
+{
+	/* SSI stop */
+	scu_ssi_stop(ch, dir);
+
+}
+EXPORT_SYMBOL(scu_deinit_ssi);
+
+void scu_init_src(int src_ch, unsigned int rate, unsigned int sync_sw)
+{
+	scu_src_control(src_ch, rate, sync_sw);
+}
+EXPORT_SYMBOL(scu_init_src);
+
+void scu_deinit_src(int src_ch)
+{
+	/* SCUX reset */
+	/* 0xE8209700:SWRSR_CIM SWRST = 0 */
+	writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);
+	udelay(10);
+	/* 0xE8209700:SWRSR_CIM SWRST = 1 */
+	writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);
+	udelay(10);
+}
+EXPORT_SYMBOL(scu_deinit_src);
+
+void scu_init_dvc(int dvc_ch)
+{
+	/* SCUX reset */
+	/* 0xE8209700:SWRSR_CIM SWRST = 0 */
+	writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);
+	udelay(10);
+	/* 0xE8209700:SWRSR_CIM SWRST = 1 */
+	writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);
+	udelay(10);
+
+	scu_dvc_control(dvc_ch);
+}
+EXPORT_SYMBOL(scu_init_dvc);
+
+void scu_deinit_dvc(int dvc_ch)
+{
+	/* stop dvu */
+	scu_dvc_stop(dvc_ch);
+	scu_dvc_deinit(dvc_ch);
+}
+EXPORT_SYMBOL(scu_deinit_dvc);
+
+/************************************************************************
+
+	dai ops
+
+************************************************************************/
+/* Playback and capture hardware properties are identical */
+static struct snd_pcm_hardware scu_dai_pcm_hw = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED	|
+				   SNDRV_PCM_INFO_MMAP		|
+				   SNDRV_PCM_INFO_MMAP_VALID	|
+				   SNDRV_PCM_INFO_PAUSE),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= SNDRV_PCM_RATE_8000_48000,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= SCU_BUFFER_BYTES_MAX,
+	.period_bytes_min	= SCU_PERIOD_BYTES_MIN,
+	.period_bytes_max	= SCU_PERIOD_BYTES_MAX,
+	.periods_min		= SCU_PERIODS_MIN,
+	.periods_max		= SCU_PERIODS_MAX,
+};
+
+static int scu_dai_info_rate(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = RATE_MAX;
+
+	return 0;
+}
+
+static int scu_dai_get_rate(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		ucontrol->value.integer.value[0] = ainfo->rate[0];
+		break;
+	case CTRL_CAPTURE:
+		ucontrol->value.integer.value[0] = ainfo->rate[1];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int scu_dai_put_rate(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		change |= (ainfo->rate[0] != ucontrol->value.integer.value[0]);
+		if (change)
+			ainfo->rate[0] = ucontrol->value.integer.value[0];
+		break;
+	case CTRL_CAPTURE:
+		change |= (ainfo->rate[1] != ucontrol->value.integer.value[0]);
+		if (change)
+			ainfo->rate[1] = ucontrol->value.integer.value[0];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return change;
+}
+
+static struct snd_kcontrol_new playback_rate_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Sampling Rate",
+	.index		= 0,
+	.info		= scu_dai_info_rate,
+	.get		= scu_dai_get_rate,
+	.put		= scu_dai_put_rate,
+	.private_value	= CTRL_PLAYBACK,
+};
+
+static struct snd_kcontrol_new capture_rate_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Capture Sampling Rate",
+	.index		= 0,
+	.info		= scu_dai_info_rate,
+	.get		= scu_dai_get_rate,
+	.put		= scu_dai_put_rate,
+	.private_value	= CTRL_CAPTURE,
+};
+
+static int scu_dai_info_volume(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = VOLUME_MAX_DVC;
+
+	return 0;
+}
+
+static int scu_dai_get_volume(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		ucontrol->value.integer.value[0] = ainfo->volume[0][0];
+		ucontrol->value.integer.value[1] = ainfo->volume[0][1];
+		/* save volume */
+		getvolume0 = ucontrol->value.integer.value[0];
+		getvolume1 = ucontrol->value.integer.value[1];
+		break;
+	case CTRL_CAPTURE:
+		ucontrol->value.integer.value[0] = ainfo->volume[1][0];
+		ucontrol->value.integer.value[1] = ainfo->volume[1][1];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int scu_dai_put_volume(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+		ucontrol->value.integer.value[0] > VOLUME_MAX_DVC ||
+		ucontrol->value.integer.value[1] < 0 ||
+		ucontrol->value.integer.value[1] > VOLUME_MAX_DVC)
+		return -EINVAL;
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		change |= ((ainfo->volume[0][0] !=
+			ucontrol->value.integer.value[0]) ||
+			(ainfo->volume[0][1] !=
+			ucontrol->value.integer.value[1]));
+		if (change) {
+			ainfo->volume[0][0] = ucontrol->value.integer.value[0];
+			ainfo->volume[0][1] = ucontrol->value.integer.value[1];
+			/* DVU0_1 L:vol0r R:vol1r */
+			/* DVU0_1 VOL0R : 0xE8209324 */
+			writel(ainfo->volume[0][0],
+				&scux_reg->dvureg[1]->vol0r);
+			/* DVU0_1 VOL1R : 0xE8209328 */
+			writel(ainfo->volume[0][1],
+				&scux_reg->dvureg[1]->vol1r);
+		}
+		break;
+	case CTRL_CAPTURE:
+		change |= ((ainfo->volume[1][0] !=
+			ucontrol->value.integer.value[0]) ||
+			(ainfo->volume[1][1] !=
+			ucontrol->value.integer.value[1]));
+		if (change) {
+			ainfo->volume[1][0] = ucontrol->value.integer.value[0];
+			ainfo->volume[1][1] = ucontrol->value.integer.value[1];
+			/* DVU0_0 L:vol1r R:vol0r */
+			writel(ainfo->volume[1][0],
+			       (u32 *)&scux_reg->dvureg[0]->vol1r);
+			writel(ainfo->volume[1][1],
+			       (u32 *)&scux_reg->dvureg[0]->vol0r);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return change;
+}
+
+static struct snd_kcontrol_new playback_volume_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Volume",
+	.index		= 0,
+	.info		= scu_dai_info_volume,
+	.get		= scu_dai_get_volume,
+	.put		= scu_dai_put_volume,
+	.private_value	= CTRL_PLAYBACK,
+};
+
+static struct snd_kcontrol_new capture_volume_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "Capture Volume",
+	.index		= 0,
+	.info		= scu_dai_info_volume,
+	.get		= scu_dai_get_volume,
+	.put		= scu_dai_put_volume,
+	.private_value	= CTRL_CAPTURE,
+};
+
+static int scu_dai_info_mute(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int scu_dai_get_mute(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+
+	ucontrol->value.integer.value[0] = ainfo->mute[0];
+	ucontrol->value.integer.value[1] = ainfo->mute[1];
+
+	return 0;
+}
+
+static int scu_dai_put_mute(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+	u32 mute = 0;
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > 1 ||
+	    ucontrol->value.integer.value[1] < 0 ||
+	    ucontrol->value.integer.value[1] > 1)
+		return -EINVAL;
+
+	change |= ((ainfo->mute[0] != ucontrol->value.integer.value[0]) ||
+			(ainfo->mute[1] != ucontrol->value.integer.value[1]));
+	if (change) {
+		ainfo->mute[0] = ucontrol->value.integer.value[0];
+		ainfo->mute[1] = ucontrol->value.integer.value[1];
+		mute = (ainfo->mute[1] << 1) + ainfo->mute[0];
+		mute = ~mute & 0x3;
+		writel(mute, (u32 *)&scux_reg->dvureg[1]->zcmcr);
+	}
+
+	return change;
+}
+
+static struct snd_kcontrol_new playback_mute_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Switch",
+	.index		= 0,
+	.info		= scu_dai_info_mute,
+	.get		= scu_dai_get_mute,
+	.put		= scu_dai_put_mute,
+};
+
+int scu_dai_add_control(struct snd_card *card)
+{
+	struct device *dev = card->dev;
+	struct snd_kcontrol *kctrl;
+	int i, j, ret;
+
+	/* initial value */
+	for (i = 0; i < 2; i++) {
+		ainfo->rate[i] = 0;
+		ainfo->mute[i] = 1;
+		for (j = 0; j < 2; j++)
+			ainfo->volume[i][j] = VOLUME_DEFAULT;
+	}
+
+	getvolume0 = VOLUME_DEFAULT;
+	getvolume1 = VOLUME_DEFAULT;
+	kctrl = snd_ctl_new1(&playback_rate_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback rate err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&capture_rate_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add capture rate err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&playback_volume_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback volume err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&capture_volume_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add capture volume err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&playback_mute_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback mute err=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scu_dai_add_control);
+
+static int scu_dai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	FNC_ENTRY
+	snd_soc_set_runtime_hwparams(substream, &scu_dai_pcm_hw);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_dai_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return;
+}
+
+static int scu_dai_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_dai_set_fmt(struct snd_soc_dai *dai,
+				unsigned int fmt)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+				unsigned int freq, int dir)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static const struct snd_soc_dai_ops scu_dai_ops = {
+	.startup	= scu_dai_startup,
+	.shutdown	= scu_dai_shutdown,
+	.prepare	= scu_dai_prepare,
+	.set_sysclk	= scu_dai_set_sysclk,
+	.set_fmt	= scu_dai_set_fmt,
+};
+
+static const struct snd_soc_component_driver scu_ssi_component = {
+	.name		= "scu-ssi",
+};
+
+static struct snd_soc_dai_driver scu_ssi_dai = {
+	.name	= "scu-ssi-dai",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+	},
+	.ops = &scu_dai_ops,
+};
+
+static void scu_alloc_scureg(void __iomem *mem)
+{
+	int i;
+	void __iomem *offset;
+
+	/* SCUX common */
+	scux_reg->scuxreg = mem;
+
+	/* IPC */
+	offset = mem;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ipcreg[i] = (struct scux_ipc_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* OPC */
+	offset = mem + 0x0400;
+	for (i = 0; i < 3; i++) {
+		scux_reg->opcreg[i] = (struct scux_opc_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* FFD */
+	offset = mem + 0x0800;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ffdreg[i] = (struct scux_ffd_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* FFU */
+	offset = mem + 0x0C00;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ffureg[i] = (struct scux_ffu_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* SRC */
+	offset = mem + 0x1000;
+	scux_reg->srcreg[SCUX_2SRC0_0] = (struct scux_src_regs *)offset;
+	offset = mem + 0x1100;
+	scux_reg->srcreg[SCUX_2SRC0_1] = (struct scux_src_regs *)offset;
+
+	/* DVU */
+	offset = mem + 0x1200;
+	for (i = 0; i < 3; i++) {
+		scux_reg->dvureg[i] = (struct scux_dvu_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* MIX */
+	offset = mem + 0x1600;
+	scux_reg->mixreg = (struct scux_mix_regs *)offset;
+
+	/* CIM */
+	offset = mem + 0x1700;
+	scux_reg->cimreg = (struct scux_cim_regs *)offset;
+
+	return;
+}
+
+static void scu_alloc_ssif0reg(void __iomem *mem)
+{
+	int i;
+	void __iomem *offset;
+
+	offset = mem;
+	for (i = 0; i < 5; i++) {
+		scux_reg->ssifreg[i] = (struct ssif_regs *)offset;
+		offset += 0x800;
+		DBG_MSG("ssireg[%2d]=%08x\n", i, (int)scux_reg->ssireg[i]);
+	}
+
+	return;
+}
+
+static int scu_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct scu_clock_info *cinfo;
+	struct resource *scu_res;
+	struct resource *scu_region = NULL;
+	struct resource *ssi_res;
+	struct resource *ssi_region = NULL;
+	void __iomem *mem;
+
+	FNC_ENTRY
+	if (pdev->id != 0) {
+		dev_err(&pdev->dev, "current scu support id 0 only now\n");
+		return -ENODEV;
+	}
+	pdata = pdev->dev.platform_data;
+
+	ainfo = kzalloc(sizeof(struct scu_audio_info), GFP_KERNEL);
+	if (!ainfo) {
+		dev_err(&pdev->dev, "no memory\n");
+		return -ENOMEM;
+	}
+	cinfo = &ainfo->clockinfo;
+	scux_reg = &ainfo->reginfo;
+
+	spin_lock_init(&ainfo->scu_lock);
+	sculock = &ainfo->scu_lock;
+
+	/* resource */
+	scu_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!scu_res) {
+		dev_err(&pdev->dev, "No memory (0) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+	ssi_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+
+	if (!ssi_res) {
+		dev_err(&pdev->dev, "No memory (2) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+	scu_region = request_mem_region(scu_res->start,
+					resource_size(scu_res), pdev->name);
+	if (!scu_region) {
+		dev_err(&pdev->dev, "SCUX region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	ssi_region = request_mem_region(ssi_res->start,
+					resource_size(ssi_res), pdev->name);
+	if (!ssi_region) {
+		dev_err(&pdev->dev, "SSI region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	/* mapping scux */
+	mem = ioremap_nocache(scu_res->start, resource_size(scu_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for scu\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	scu_alloc_scureg(mem);
+
+	mem = ioremap_nocache(ssi_res->start, resource_size(ssi_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for ssi\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	scu_alloc_ssif0reg(mem);
+
+	ret = snd_soc_register_platform(&pdev->dev, &scu_platform);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd soc register\n");
+		goto error_unmap;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &scu_ssi_component,
+					 &scu_ssi_dai, 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd soc dais register\n");
+		goto error_unregister;
+	}
+
+	scu_ssif_init();
+
+	FNC_EXIT
+	return ret;
+
+error_unregister:
+	snd_soc_unregister_platform(&pdev->dev);
+
+error_unmap:
+	if (scux_reg->scuxreg)
+		iounmap(scux_reg->scuxreg);
+
+	if (scux_reg->ssireg)
+		iounmap(scux_reg->ssireg);
+
+error_release:
+	if (scu_region)
+		release_mem_region(scu_res->start, resource_size(scu_res));
+	if (ssi_region)
+		release_mem_region(ssi_res->start, resource_size(ssi_res));
+
+error_clk_put:
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	FNC_ENTRY
+	snd_soc_unregister_component(&pdev->dev);
+	snd_soc_unregister_platform(&pdev->dev);
+
+	iounmap(scux_reg->scuxreg);
+	iounmap(scux_reg->ssireg);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+
+	kfree(ainfo);
+
+	FNC_EXIT
+	return 0;
+}
+
+static struct platform_driver scu_driver = {
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "scux-pcm-audio",
+	},
+	.probe		= scu_probe,
+	.remove		= scu_remove,
+};
+
+module_platform_driver(scu_driver);
+
+MODULE_AUTHOR(" Renesas Solutions Corp.");
+MODULE_DESCRIPTION("ALSA SoC RZA1H SCUX driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sh/scux_pcm.c b/sound/soc/sh/scux_pcm.c
new file mode 100644
index 0000000..fede22f
--- /dev/null
+++ b/sound/soc/sh/scux_pcm.c
@@ -0,0 +1,754 @@
+/*
+ * sound/soc/sh/scux_pcm.c
+ *     This file is ALSA SoC driver for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/siu_pcm.c
+ *
+ * siu_pcm.c - ALSA driver for Renesas SH7343, SH7722 SIU peripheral.
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/dma-rza1.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/sh_scux.h>
+
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static u64 dma_mask = DMA_BIT_MASK(32);
+static unsigned int codec_powerup_wait;
+module_param(codec_powerup_wait, uint, 0644);
+
+static struct snd_soc_dai *scu_get_dai(struct snd_pcm_substream *ss)
+{
+	struct snd_soc_pcm_runtime *rtd = ss->private_data;
+
+	return  rtd->cpu_dai;
+}
+
+static void scu_avoid_end_noise(int dir, u32 *st_ptr, int size)
+{
+	if (dir == SNDRV_PCM_STREAM_PLAYBACK) {
+		while (0 < size) {
+			*st_ptr = 0;
+			st_ptr++;
+			size--;
+		}
+	}
+}
+
+static void scu_dma_callback(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	snd_pcm_uframes_t period, buf, tran, remain, threshold, tran_piece;
+	u32 *buf_st_vadr, *buf_end_vadr;
+	snd_pcm_uframes_t st_point;
+	int dir = ss->stream;
+
+	FNC_ENTRY
+
+	period = runtime->period_size;
+	buf = runtime->buffer_size;
+	tran = pcminfo->tran_size;
+	remain = buf - (tran % buf);
+	threshold = period + (period / 2);
+	tran_piece = pcminfo->tran_period_piece;
+	buf_st_vadr = (u32 *)runtime->dma_area;
+	buf_end_vadr = (u32 *)(runtime->dma_area + runtime->dma_bytes);
+	st_point = tran % buf;
+
+	if ((0 < remain) && (remain <= threshold)) {
+		tran += remain;
+		if (remain <= period)
+			tran_piece = period - remain;
+		else
+			tran_piece = (period * 2) - remain;
+		scu_avoid_end_noise(dir, buf_end_vadr - (period / 2),
+								period / 2);
+	} else if (tran_piece > 0) {
+		if ((tran_piece + period) < threshold)
+			tran += (tran_piece + period);
+		else
+			tran += tran_piece;
+		tran_piece = 0;
+		scu_avoid_end_noise(dir, buf_st_vadr, tran % buf);
+	} else {
+		tran += period;
+		if ((0 < st_point) && (st_point < threshold) &&
+							((buf % period) != 0))
+			scu_avoid_end_noise(dir, buf_st_vadr + st_point,
+						(threshold - 1) - st_point);
+	}
+
+	pcminfo->tran_size = tran;
+	pcminfo->tran_period_piece = tran_piece;
+
+	/* Notify alsa */
+	snd_pcm_period_elapsed(ss);
+
+	/* stop dma */
+	if (pcminfo->flag_start == 0)
+		return;
+
+	queue_work(pcminfo->workq, &pcminfo->work);
+
+	FNC_EXIT
+}
+
+static int scu_dmae_req_chan(int sid, struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	struct rza1_dma_slave *param = &pcminfo->de_param[sid];
+	struct dma_slave_config cfg;
+	dma_cap_mask_t mask;
+	int ret = 0;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	FNC_ENTRY
+
+	/* set dma slave id */
+	param->rza1dma_slaveid.slave_id = sid;
+
+	/* request dma channel */
+	if (pcminfo->de_chan[sid] == NULL) {
+		pcminfo->de_chan[sid] = dma_request_channel(mask,
+					      rza1dma_chan_filter, (void *)sid);
+		if (!pcminfo->de_chan[sid]) {
+			snd_printk(KERN_ERR "DMA channel request error\n");
+			return -EBUSY;
+		}
+
+		cfg.slave_id = sid;
+		ret = dmaengine_slave_config(pcminfo->de_chan[sid], &cfg);
+		if (ret < 0) {
+			dma_release_channel(pcminfo->de_chan[sid]);
+			return ret;
+		}
+	}
+
+	DBG_MSG("chan=0x%08x\n", (int)pcminfo->de_chan[sid]);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_dmae_rel_chan(int sid, struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+
+	FNC_ENTRY
+
+	/* release dma channel */
+	if (pcminfo->de_chan[sid]) {
+		dma_release_channel(pcminfo->de_chan[sid]);
+		pcminfo->de_chan[sid] = NULL;
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_dmae_request(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	if (!dir) { /* playback */
+		route = pcminfo->routeinfo->p_route;
+	} else { /* capture */
+		route = pcminfo->routeinfo->c_route;
+	}
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	if (audma_slave_id != -1) {
+		ret = scu_dmae_req_chan(audma_slave_id, ss);
+		if (ret < 0)
+			return ret;
+	}
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_dmae_release(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	if (!dir) /* playback */
+		route = pcminfo->routeinfo->p_route;
+	else /* capture */
+		route = pcminfo->routeinfo->c_route;
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	if (audma_slave_id != -1)
+		scu_dmae_rel_chan(audma_slave_id, ss);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_audma_start(int sid, struct snd_pcm_substream *ss)
+{
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+	struct device *dev = ss->pcm->card->dev;
+	struct dma_async_tx_descriptor *desc;
+	dma_cookie_t cookie;
+	u32 dma_size;
+	u32 dma_paddr;
+	struct snd_soc_dai *dai;
+	snd_pcm_uframes_t period, buf, offset, remain, threshold, period_piece;
+
+	FNC_ENTRY
+
+	dai = scu_get_dai(ss);
+
+	/* DMA physical adddress */
+	dma_paddr = runtime->dma_addr
+			+ frames_to_bytes(runtime, pcminfo->buf_offset);
+	DBG_MSG("dma_paddr=0x%08x\n", dma_paddr);
+
+	period = runtime->period_size;
+	buf = runtime->buffer_size;
+	offset = pcminfo->buf_offset;
+	remain = buf - offset;
+	threshold = period + (period / 2);
+	period_piece = pcminfo->period_piece;
+
+	/* DMA size */
+	if ((0 < remain) && (remain <= threshold)) {
+		dma_size = frames_to_bytes(runtime, remain);
+		offset = 0;
+		if (remain <= period)
+			period_piece = period - remain;
+		else
+			period_piece = (period * 2) - remain;
+	} else if (period_piece > 0) {
+		if (period_piece + period < threshold) {
+			dma_size = frames_to_bytes(runtime,
+						period_piece + period);
+			offset += (period_piece + period);
+		} else {
+			dma_size = frames_to_bytes(runtime, period_piece);
+			offset += period_piece;
+		}
+		period_piece = 0;
+	} else {
+		dma_size = frames_to_bytes(runtime, period);
+		offset += period;
+		if (offset >= buf)
+			offset -= buf;
+	}
+	DBG_MSG("dma_size=%d\n", dma_size);
+
+	pcminfo->buf_offset = offset;
+	pcminfo->period_piece = period_piece;
+
+	dma_sync_single_for_device(dai->dev, dma_paddr, dma_size, DMA_DIR(dir));
+
+	desc = dmaengine_prep_slave_single(pcminfo->de_chan[sid], dma_paddr,
+		dma_size, DMA_DIR(dir), DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!desc) {
+		dev_err(dai->dev, "dmaengine_prep_slave_sg_single() fail\n");
+		return -ENOMEM;
+	}
+
+	desc->callback = (dma_async_tx_callback)scu_dma_callback;
+	desc->callback_param = ss;
+
+	cookie = dmaengine_submit(desc);
+	if (cookie < 0) {
+		dev_err(dev, "Failed to submit a dma transfer\n");
+		FNC_EXIT
+		return cookie;
+	}
+
+	dma_async_issue_pending(pcminfo->de_chan[sid]);
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_audma_stop(int sid, struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+
+	FNC_EXIT
+	return 0;
+}
+
+static void scu_pcm_start(struct snd_pcm_substream *ss, int first_flag)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ssi_depend = 0;
+	int ssi_mode = 0;
+	int src_ch = 0;
+	int src_mode = 0;
+	int dvc_ch = 0;
+	struct scu_pcm_callback callback;
+
+	FNC_ENTRY
+
+	if (!dir) { /* playback */
+		route = pcminfo->routeinfo->p_route;
+		callback = pcminfo->routeinfo->pcb;
+	} else { /* capture */
+		route = pcminfo->routeinfo->c_route;
+		callback = pcminfo->routeinfo->ccb;
+	}
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	ssi_depend = scu_find_data(route, pcminfo->pdata->ssi_depend,
+					pcminfo->pdata->ssi_depend_num);
+	ssi_mode = scu_find_data(route, pcminfo->pdata->ssi_mode,
+					pcminfo->pdata->ssi_mode_num);
+	src_ch = scu_find_data(route, pcminfo->pdata->src_ch,
+					pcminfo->pdata->src_ch_num);
+	src_mode = scu_find_data(route, pcminfo->pdata->src_mode,
+					pcminfo->pdata->src_mode_num);
+	dvc_ch = scu_find_data(route, pcminfo->pdata->dvc_ch,
+					pcminfo->pdata->dvc_ch_num);
+
+	/* start dma */
+	scu_audma_start(audma_slave_id, ss);
+
+	if (first_flag) {
+		/* Four Descripters are registered first */
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start ssi */
+		if (callback.init_ssi)
+			callback.init_ssi(pcminfo->pdata->ssi_master,
+				pcminfo->pdata->ssi_slave,
+				ssi_mode, ssi_depend, dir);
+
+		/* start dvc */
+		if (callback.init_dvc)
+			callback.init_dvc(dvc_ch);
+
+		/* start src */
+		if (callback.init_src)
+			callback.init_src(src_ch, ss->runtime->rate, src_mode);
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_pcm_stop(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ssi_ch = 0;
+	int ssi_depend = 0;
+	int ssi_mode = 0;
+	int src_ch = 0;
+	int dvc_ch = 0;
+	struct scu_pcm_callback callback;
+
+	FNC_ENTRY
+
+	if (!dir) { /* playback */
+		route = pcminfo->routeinfo->p_route;
+		callback = pcminfo->routeinfo->pcb;
+	} else { /* capture */
+		route = pcminfo->routeinfo->c_route;
+		callback = pcminfo->routeinfo->ccb;
+	}
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	ssi_ch = scu_find_data(route, pcminfo->pdata->ssi_ch,
+					pcminfo->pdata->ssi_ch_num);
+	ssi_depend = scu_find_data(route, pcminfo->pdata->ssi_depend,
+					pcminfo->pdata->ssi_depend_num);
+	ssi_mode = scu_find_data(route, pcminfo->pdata->ssi_mode,
+					pcminfo->pdata->ssi_mode_num);
+	src_ch = scu_find_data(route, pcminfo->pdata->src_ch,
+					pcminfo->pdata->src_ch_num);
+	dvc_ch = scu_find_data(route, pcminfo->pdata->dvc_ch,
+					pcminfo->pdata->dvc_ch_num);
+	/* stop src */
+	if (callback.deinit_src)
+		callback.deinit_src(src_ch);
+
+	/* stop dvc */
+	if (callback.deinit_dvc)
+		callback.deinit_dvc(dvc_ch);
+
+	/* stop ssi */
+	if (callback.deinit_ssi)
+		callback.deinit_ssi(ssi_ch, ssi_mode, ssi_depend, dir);
+
+	/* stop dma */
+	scu_audma_stop(audma_slave_id, ss);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_dma_do_work(struct work_struct *work)
+{
+	struct scu_pcm_info *pcminfo =
+			container_of(work, struct scu_pcm_info, work);
+	struct snd_pcm_substream *ss = pcminfo->ss;
+
+	FNC_ENTRY
+
+	/* start pcm process */
+	scu_pcm_start(ss, pcminfo->flag_first);
+	if (pcminfo->flag_first == 1)
+		pcminfo->flag_first = 0;
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_audio_start(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	/* dma channel request */
+	ret = scu_dmae_request(ss);
+	if (ret < 0) {
+		pr_info("scu_dmae_request faild\n");
+		FNC_EXIT
+		return ret;
+	}
+
+	/* DMA control */
+	pcminfo->flag_start = 1;
+	/* PCM 1st process */
+	pcminfo->flag_first = 1;
+
+	pcminfo->buf_offset = 0;
+	pcminfo->tran_size = 0;
+	pcminfo->period_piece = 0;
+	pcminfo->tran_period_piece = 0;
+
+	mdelay(codec_powerup_wait);
+	queue_work(pcminfo->workq, &pcminfo->work);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_audio_stop(struct snd_pcm_substream *ss)
+{
+	int ret = 0;
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+
+	FNC_ENTRY
+
+	/* stop dma */
+	pcminfo->flag_start = 0;
+
+	/* stop pcm process */
+	scu_pcm_stop(ss);
+
+	/* dma channel release */
+	ret = scu_dmae_release(ss);
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct scu_pcm_info *scu_pcm_new_stream(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo;
+
+	FNC_ENTRY
+
+	/* allocate scu_pcm_info structure */
+	pcminfo = kzalloc(sizeof(struct scu_pcm_info), GFP_KERNEL);
+	if (!pcminfo)
+		return pcminfo;
+
+	/* initialize rcar_pcm_info structure */
+	pcminfo->routeinfo   = scu_get_route_info();
+	pcminfo->ss          = ss;
+	pcminfo->pdata       = scu_get_platform_data();
+
+	/* allocate dma_chan structure */
+	pcminfo->de_chan = kzalloc((sizeof(struct dma_chan) *
+					pcminfo->pdata->dma_slave_maxnum),
+					GFP_KERNEL);
+	if (!pcminfo->de_chan) {
+		kfree(pcminfo);
+		return NULL;
+	}
+
+	/* allocate sh_dmadesc_slave structure */
+	pcminfo->de_param = kzalloc((sizeof(struct rza1_dma_slave) *
+					pcminfo->pdata->dma_slave_maxnum),
+					GFP_KERNEL);
+	if (!pcminfo->de_param) {
+		kfree(pcminfo->de_chan);
+		kfree(pcminfo);
+		return NULL;
+	}
+	spin_lock_init(&pcminfo->pcm_lock);
+	pcminfo->workq = alloc_ordered_workqueue("sh_scu_pcm", 0);
+	INIT_WORK(&pcminfo->work, scu_dma_do_work);
+
+	FNC_EXIT
+	return pcminfo;
+}
+
+static void scu_pcm_free_stream(struct snd_pcm_runtime *runtime)
+{
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+
+	FNC_ENTRY
+
+	/* post process */
+	cancel_work_sync(&pcminfo->work);
+	destroy_workqueue(pcminfo->workq);
+	kfree(pcminfo->de_param);
+	kfree(pcminfo->de_chan);
+	kfree(runtime->private_data);	/* free pcminfo structure */
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_pcm_open(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	pcminfo = scu_pcm_new_stream(ss);
+	if (pcminfo == NULL)
+		return -ENOMEM;
+
+	ret = scu_check_route(dir, pcminfo->routeinfo);
+	if (ret < 0)
+		return ret;
+
+	ss->runtime->private_data = pcminfo;
+	ss->runtime->private_free = scu_pcm_free_stream;
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_close(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_hw_params(struct snd_pcm_substream *ss,
+			     struct snd_pcm_hw_params *hw_params)
+{
+	struct device *dev = ss->pcm->card->dev;
+	int ret;
+
+	FNC_ENTRY
+
+	ret = snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw_params));
+	if (ret < 0)
+		dev_err(dev, "snd_pcm_lib_malloc_pages() failed\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_pcm_hw_free(struct snd_pcm_substream *ss)
+{
+	struct device *dev = ss->pcm->card->dev;
+	int ret;
+
+	FNC_ENTRY
+
+	ret = snd_pcm_lib_free_pages(ss);
+	if (ret < 0)
+		dev_err(dev, "snd_pcm_lib_free_pages() failed\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_pcm_prepare(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_trigger(struct snd_pcm_substream *ss, int cmd)
+{
+	int ret = 0;
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+
+	spin_lock(&pcminfo->pcm_lock);
+
+	FNC_ENTRY
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		ret = scu_audio_start(ss);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		ret = scu_audio_stop(ss);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&pcminfo->pcm_lock);
+
+	FNC_EXIT
+	return ret;
+}
+
+static snd_pcm_uframes_t scu_pcm_pointer_dma(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+	snd_pcm_uframes_t position = 0;
+
+	position = pcminfo->tran_size % runtime->buffer_size;
+
+	DBG_MSG("\tposition = %d\n", (u32)position);
+
+	return position;
+}
+
+static int scu_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+	struct snd_card *card = rtd->card->snd_card;
+
+	FNC_ENTRY
+
+	ret = scu_dai_add_control(card);
+
+	if (ret)
+		return ret;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &dma_mask;
+
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	ret = snd_pcm_lib_preallocate_pages_for_all(
+		rtd->pcm,
+		SNDRV_DMA_TYPE_DEV,
+		rtd->card->snd_card->dev,
+		SCU_BUFFER_BYTES_MAX, SCU_BUFFER_BYTES_MAX);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_pcm_free(struct snd_pcm *pcm)
+{
+	FNC_ENTRY
+
+	/* free dma buffer */
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+
+	FNC_EXIT
+}
+
+static struct snd_pcm_ops scu_pcm_ops = {
+	.open		= scu_pcm_open,
+	.close		= scu_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= scu_pcm_hw_params,
+	.hw_free	= scu_pcm_hw_free,
+	.prepare	= scu_pcm_prepare,
+	.trigger	= scu_pcm_trigger,
+	.pointer	= scu_pcm_pointer_dma,
+};
+
+struct snd_soc_platform_driver scu_platform = {
+	.ops		= &scu_pcm_ops,
+	.pcm_new	= scu_pcm_new,
+	.pcm_free	= scu_pcm_free,
+};
+EXPORT_SYMBOL_GPL(scu_platform);
